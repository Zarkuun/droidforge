{"circuits": {"compare": {"category": "logic", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "A value to compare.\n"}, {"default": "0", "type": "cv", "name": "compare", "description": "A reference value to compare the input with.\n"}, {"default": "unpatched", "type": "cv", "name": "ifgreater", "description": "Value to be output if {\\t input} is greater than {\\t compare}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n"}, {"default": "unpatched", "type": "cv", "name": "ifless", "description": "Value to be output if {\\t input} is less than {\\t compare}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n"}, {"default": "unpatched", "type": "cv", "name": "ifequal", "description": "Value to be output if {\\t input} is equal to {\\t compare} within the\nprecision defined by {\\t precision}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n"}, {"default": "0", "type": "cv", "name": "else", "description": "Specifies the output value in case non of the stated conditions are met.\n"}, {"default": "0", "type": "cv", "name": "precision", "description": "An optional precision to be used by {\\t ifequal}\n"}], "description": "This simple utility circuit allows you to make a decision by comparing\nan input value (at {\\t input}) against a reference value (at {\\t compare})\nand output one of three values depending on whether the input is less than,\ngreater than or equal to the reference.\n\nThe following simple example checks if the pot {\\t P1.1} is\nleft of the center (a value less than 0.5). If that is so,\nit outputs {\\t 1}, otherwise {\\t 0}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = 1}    ifless = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nYou can change the default output value of {\\t 0}\nwith the input {\\t else}. That specifies what happens\nif the condition is {\\it not} met. The following example\noutputs {\\t -1}, if {\\t P1.1} is greater or equal to 0.5.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = 1}    ifless = 1\n\\immediate\\write\\patchexamples{    else = @1}    else = -1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\n\\subsubsection{Equality, analog unprecision}\n\nYou can also check if two values are {\\it equal}. This\nis done with {\\t ifequal}. Check this out:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = B1.1}    input = B1.1\n\\immediate\\write\\patchexamples{    compare = 1}    compare = 1\n\\immediate\\write\\patchexamples{    ifequal = 4}    ifequal = 4\n\\immediate\\write\\patchexamples{    else = 8}    else = 8\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow while you hold the button {\\t B1.1} this circuit will\noutput the value {\\t 4} and otherwise {\\t 8}.\n\nNote: equality can be tricky when it comes to values from {\\it analog}\nthings like inputs or potentiometers. They always undergo tiny random\nfluctiations. So the following example, that should compare the current\nvoltages of two inputs, will never really work:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    ifequal = 1 # will never happen!}    ifequal = 1 # will never happen!\n\\immediate\\write\\patchexamples{    output = O1 # This won't work!}    output = O1 # This won't work!\n\\end{droidini}\n\nIf you try this out, you will probably {\\it never} get both inputs equal.\nEven a single electron too much could theoretically make the difference.\nSo in order to make such comparisons possible, there is a way to allow for\na {\\it slight unprecision} when doing the comparison. This is set with the\n{\\t precision} parameter:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    precision = 0.1}    precision = 0.1\n\\immediate\\write\\patchexamples{    ifequal = 1}    ifequal = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow the inputs {\\t I1} and {\\t I2} are being treated as equal as long as\ntheir difference is {\\t 0.1} (1~V) at most.\n\n\n\\subsubsection*{Makeing a three-way switch}\n\nIt is possible to check all three relations at once. Make sure that\nyou apply a {\\t precision} if you deal with analog values:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    precision = 0.1}    precision = 0.1\n\\immediate\\write\\patchexamples{    ifless = 0}    ifless = 0\n\\immediate\\write\\patchexamples{    ifequal = 1}    ifequal = 1\n\\immediate\\write\\patchexamples{    ifgreater = 2}    ifgreater = 2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow you get {\\t 0}, {\\t 1} or {\\t 2}, depending on wether {\\t I1}\nis less, equal or greater than {\\t I2}.\n\nNote: Better do not use just {\\t ifless} and {\\t ifgreater} without\nusing {\\t ifequal} or {\\t else}. This lets the equality undefined\nand will output 0 if for any chance the two input values are equal.\nBetter use {\\t ifless} / {\\t ifgreater} in combination with {\\t else}\nif you are not interested in the exact equality.\n\n\n\\subsubsection*{Omitted inputs}\n\nIt is allowed to omit any of the inputs {\\t ifless}, {\\t ifequal}, {\\t ifgreater}\nor {\\t else}. Any of these is treated as {\\t 0} with one exception:\nIf you omit all four, {\\t ifequal} defaults to {\\t 1}. This make a super\nbasic {\\t compare} circuit just check if two values are equal:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    input = B1.1}    input = B1.1\n\\immediate\\write\\patchexamples{    compare = 0}    compare = 0\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nThis will output {\\t 1} if button {\\t B1.1} as the value {\\t 0} (is not\npressed).\n\n\n\\subsubsection*{Dynamic output values}\n\nAs often, instead of using fixed values for {\\t ifless}, {\\t ifequal}, {\\t\nifgreater} and {\\t else} you can use dynamic values from somewhere else,\nof course.  The following example will output a sine wave at {\\t O1} if the\npot is left of the center or else a square wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    sine = _SINE}    sine = _SINE\n\\immediate\\write\\patchexamples{    square = _SQUARE}    square = _SQUARE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = _SINE}    ifless = _SINE\n\\immediate\\write\\patchexamples{    else = _SQUARE}    else = _SQUARE\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}", "title": " Compare two values", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Here one of {\\t ifgreater}, {\\t ifless} or {\\t ifequal} is output.\n"}], "presets": 0}, "chord": {"category": "pitch", "inputs": [{"default": "0", "type": "integer", "name": "root", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n"}, {"default": "0", "type": "integer", "name": "degree", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n"}, {"default": "unpatched", "type": "gate", "name": "select1", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n"}, {"default": "unpatched", "type": "gate", "name": "select3", "description": "Gate input for selecting the \\nth{3}.\n"}, {"default": "unpatched", "type": "gate", "name": "select5", "description": "Gate input for selecting the \\nth{5}.\n"}, {"default": "unpatched", "type": "gate", "name": "select7", "description": "Gate input for selecting the \\nth{7}.\n"}, {"default": "unpatched", "type": "gate", "name": "select9", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n"}, {"default": "unpatched", "type": "gate", "name": "select11", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n"}, {"default": "unpatched", "type": "gate", "name": "select13", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n"}, {"default": "off", "type": "gate", "name": "selectfill1", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n"}, {"default": "off", "type": "gate", "name": "selectfill2", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill3", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n"}, {"default": "off", "type": "gate", "name": "selectfill4", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill5", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "tuningmode", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n"}, {"default": "0", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n"}, {"default": "0", "type": "voltperoctave", "name": "pitch", "description": "This sets the minimum pitch of the lowest note of the chord.\n"}, {"default": "0", "type": "voltperoctave", "name": "spread", "description": "Selects the range between the lowest and highest note of the\nchord. A spread of 0 means that all chord notes are within one\noctave. Positive values will be added to that, e.g. a spread value\nof 1~V (or 0.1) means that the chord will be spread out up to\ntwo octaves.\n"}, {"default": "0", "type": "integer", "name": "inversion", "description": "Selects the inversion of the chord. {\\t 1} means that the\nroot note should be the lowest note, {\\t 2} will make the second\nselected note the lowest note, {\\t 3} the \\nth3 and {\\t 4} the\n\\nth4. The default, however, is {\\t 0} and doesn't fix the inversion.\nRather that inversion is chosen that creates the chord closest\nto the input pitch.\n"}, {"default": null, "type": "trigger", "name": "trigger", "description": "This jack is optional. If you patch it, the Chord generator just\nreads a new input pitch when it receives a trigger.\n"}], "description": "This circuit creates the pitch information for up to four voices of a musical\nchord. This means that you can attach the Volts per octave inputs of up to\nfour synth voices and they will play a nice musical chord. Hereby you have\nthe flexibility of building your chord out of any of the seven notes of\na selected scale. So you are not limited to root, \\nth3, \\nth5 and \\nth7.\nThe algorithm is similar to that in the Sinfonion but has an adapted mode\nfor three voiced chords in addition.\n\n\\subsubsection*{Minimal example}\n\nHere is the most simple (and probably useless) example: it will play a\nC major 7 chord, i.e. output the according pitch CVs for the notes C, E,\nG and B at the outputs {\\t O1}, {\\t O2}, {\\t O3} and {\\t O4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\nOutput {\\t O1} will be at 0~V, representing a C. Or course, if you\njust have three voices, don't use {\\t output4} and you will get\na C major triad.\n\n\\subsubsection*{Selecting root and scale}\n\nYou will probably not always want to play in C major (or even never!),\nso you can select the root note and the scale with the inputs {\\t root}\nand {\\t degree}. Setting {\\t root} to {\\t 2} and {\\t degree} to {\\t 7},\nfor example, will select D natural minor:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\nBoth {\\t root} and {\\t degree} range from {\\t 0} to {\\t 11}. Please refer\nto the description of {\\t minifonion} (see page \\pageref{minifonion}) for\na complete list of all available scales. It has the same logic for {\\t root}\nand {\\t degree} and is thus compatible with {\\t chord}.\n\nBut why the heck is that input named {\\t degree}?? Well, it's a jargon from\nthe Sinfonion and does make sense there in some contexts. Please have a look\ninto the manual of the Sinfonion if you are interested!\n\n\\subsubsection*{Selecting the pitch of the notes}\n\nPer default all outputs are in the first octave, i.e. in the range 0~V ... 1~V.\nPer convention this is very low and probably sounds ugly. With the {\\t pitch}\ninput you can set the {\\it minimum} pitch of the lowest output chord note. In the\nnext example this is read from {\\t I1}. So you could for example patch a sequencer\nhere and have the chord outputs play a kind of four voiced melody:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\n\nThe {\\t spread} parameter controls the {\\t maximum} pitch of the highest\noutput chord note. It is always relative to the pitch of the {\\it lowest}\nnote {\\it plus one octave}. So if {\\t spread} is 1.5~V (or 0.15), for example,\nthe maximum allowed distance between the lowest and the highest chord note\nis 2.5 octaves. As lowest note the chord generator places the chord note\nthat is nearest above the {\\t pitch} input. As highest note\nit places the one nearest to upper bound of the allowed range and\nthe remaining notes are distributed in between with the most equal spacing\npossible.\n\n\\subsubsection*{Selecting the chord notes}\n\nWhat makes the Sinfonion and also the harmonic circuits in the \\droid\nstand apart from other modules is the flexibility of note selection.\nSo e.g. in C major, you are not limited to playing the chord C/E/G/B.\nIn fact you can choose {\\it any} subset from the currently selected scale.\n\nFor this there are seven inputs {\\t select1}, {\\t select3}, ...\n{\\t select13} that select the notes of the current scale and\nanother five inputs {\\t selectfill1} ... {\\t selectfill5} that\nselect the notes not in the current scale.\nThese 12 inputs are binary inputs that expect either {\\t 0} or\none {\\t 1}. Each of them selects one of the seven intervals of the\nscale for being part of the chord. Here is a table of all these\ninputs and the notes they would select in a C major or C minor scale:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|c|c|c|}\\hline\nInput & interval & step & C$^{maj}$ & C$^{min}$ \\\\\n{\\t select1}  & root               & {\\tt I}   & C & C \\\\\n{\\t select3}  & \\nth{3}            & {\\tt III} & E & E\\flat \\\\\n{\\t select5}  & \\nth{5}            & {\\tt V}   & G & G \\\\\n{\\t select7}  & \\nth{7}            & {\\tt VII} & B & B\\flat \\\\\n{\\t select9}  & \\nth{9} = \\nth{2}  & {\\tt II}  & D & D \\\\\n{\\t select11} & \\nth{11} = \\nth{4} & {\\tt IV}  & F & F \\\\\n{\\t select13} & \\nth{13} = \\nth{6} & {\\tt VI}  & A & A\\flat \\\\\n\\hline\n\\end{tabular}}\n\nOne typical way to select these notes is with seven toggle buttons,\nwhich is then much like the Sinfonion does it. Assign the output\nof each of the seven buttons to one of these functions:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led = L1.2}    led = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led = L1.3}    led = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led = L1.4}    led = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.5}    button = B1.5\n\\immediate\\write\\patchexamples{    led = L1.5}    led = L1.5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.6}    button = B1.6\n\\immediate\\write\\patchexamples{    led = L1.6}    led = L1.6\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.7}    button = B1.7\n\\immediate\\write\\patchexamples{    led = L1.7}    led = L1.7\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    select1 = L1.1}    select1 = L1.1\n\\immediate\\write\\patchexamples{    select3 = L1.2}    select3 = L1.2\n\\immediate\\write\\patchexamples{    select5 = L1.3}    select5 = L1.3\n\\immediate\\write\\patchexamples{    select7 = L1.4}    select7 = L1.4\n\\immediate\\write\\patchexamples{    select9 = L1.5}    select9 = L1.5\n\\immediate\\write\\patchexamples{    select11 = L1.6}    select11 = L1.6\n\\immediate\\write\\patchexamples{    select13 = L1.7}    select13 = L1.7\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\nNow you can use the buttons to change the chord notes on the fly.\nOf course, however, you also can use other signals for the selection.\nMaybe random gates, slowly running LFOs, a sequencer, whatever you like!\n\nBut what happens, if you do {\\bf not} select exactly four notes?\n\n\\begin{itemize}\n\\item If you don't select {\\it any} note (or do not patch the {\\t select}-inputs\nat all), all scale notes are selected.\n\\item If you select just {\\it one} note, all four outputs will play that same note.\n\\item If you select {\\it two} notes, {\\t output1} and {\\t output3} will play\nthe first note and {\\t output2} and {\\t output4} the second one.\n\\item If you select three notes, {\\t output4}  will play the same as {\\t output1}.\n\\item If you select five, six or seven notes, just the first four notes will be used.\n\\end{itemize}\n\nIf some of the notes are doubled and you use a large enough {\\t spread},\nthey will be placed at different octaves.\n\nBy the way: It's of course no problem to just use three or even just two of\nthe outputs, if you don't need or have a total of four voices.\n\n\\subsubsection*{Chord inversion}\n\nThe chord generator lets you nail down the chord structure to a certain\n{\\it inversion}. If you set {\\t inversion} to {\\t 1}, the root note (or,\nto be more precise,\nthe first selected note) will be placed as the lowest note. Similarly\nthe inversions {\\t 2}, {\\t 3} and {\\t 4} will make the respective other\nselected notes the lowest note.\n\nSetting {\\t inversion} to {\\t 0} (which is the default) will allow any note\nto be the lowest. This allows the chord to be closest to the {\\t pitch}\ninput.\n\n\\subsubsection*{Triggered mode}\n\nThe {\\t trigger} input is essentially a sample \\& hold for the {\\it outputs}.\nSo as soon as you patch that input, all outputs are frozen until the next\ntrigger.\n\n\\subsubsection*{Chords with three voices}\n\nThe chord generation circuit can also create chords with just three\noutput voices. Simply omit the output {\\t output4}. When it is not\nconnected, the ``three voice mode'' is activated:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\nAll parameters work as expected but there are some important adaptions.\nThis is {\\it not} the same as using the four voiced mode and just look\nat the first three outputs. For example:\n\n\\begin{itemize}\n\\item The spreading uses a simplified algorithm with just a bottom, middle and top note.\n\\item If just three intervals are selected, you don't get a duplication of\nthe first note on {\\t output2}, as you would otherwise.\n\\end{itemize}\n\n\\subsubsection*{Chords with two voices}\n\nEven if just two outputs are connected, you can still make use of this circuit.\nNow just the first two {\\t select...} inputs are taken into account. But things\nlike inversion and spreading works nevertheless.", "title": " Chord generator", "outputs": [{"count": 4, "start_at": 1, "name": "output1 ... output4", "default": null, "prefix": "output", "type": "voltperoctave", "description": "\\nth1 ... \\nth4 pitch output\n"}], "presets": 0}, "octave": {"category": "pitch", "inputs": [{"default": "0", "type": "voltperoctave", "name": "input", "description": "The general pitch information on a 1~V / octave base to be used\nfor the three VCOs.\n"}, {"default": "0", "type": "stepped", "name": "spread", "description": "The amount of octave spread between {\\t output1} and {\\t output3}.\nAt a value of {\\t 1.0} the spread is four octaves.\n"}, {"default": "0", "type": "fraction", "name": "detune", "description": "The amount of linear detune of VCO~2 and 3. This is {\\it not}\non a 1~V / octave base but corresponds to an absolute frequency\ndifference in Hertz. The exact frequency difference cannot be\nset here, since that depends on how you have tuned your VCOs.\nBut the rule is the following: If {\\t input} is a 0~V and {\\t detune} is {\\t 1.0},\nthe detune is by four semitones. And for\nan input of 1~V (one octave higher) it is just two semitones,\nbecause that results in the same frequency difference. For\n2~V (two octaves up) it ist just one semitone and for 3~V\nhalf a semitone (and so on). Best thing is to simply try out\nand listen!\n"}, {"default": "off", "type": "gate", "name": "fifths", "description": "Set this to {\\t 1} or {\\t on} if you want to include\nperfect fifths as intermediate steps.\n"}], "description": "This circuit is used to control the pitches of three oscillators\nby octave or even fifths. It also allows a linear detune in order\nto make the common sound of the VCOs sound fatter.\n\nHere is an example for a setup where the octave spreading and the detune\nis controlled with two pots:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[octave]}[octave]\n\\immediate\\write\\patchexamples{    input    = I1}    input    = I1\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    output3  = O3}    output3  = O3\n\\immediate\\write\\patchexamples{    spread   = P1.1}    spread   = P1.1\n\\immediate\\write\\patchexamples{    detune   = P1.2}    detune   = P1.2\n\\end{droidini}\n\nPatch the 1~V / octave inputs of three VCOs at {\\t O1}, {\\t O2} and {\\t\nO3}. Tune all VCOs at exactly the same pitch. Patch the pitch output from\nyour sequencer, quantizer or whatever to {\\t I1}.\n\nNow with the pot {\\t P1.1} turned fully left nothing changes. All VCOs will get\nexactly the same pitch. As you turn up the pot the pitches of the VCOs 2\nand 3 will start to get octaved up more and more until VCO~2 is two octaves\nabove VCO~1 and VCO~3 is four octaves above VCO~1.\n\nIf you add {\\t fifths = on} then intermediate steps shift the pitch\nby perfect fifths.\n\nNote: The output {\\t output1} was implemented just for sake of completeness.\nIt passes through the input to {\\t output1}, since the pitch\nof VCO~1 is never detuned nor pitched up. If you are running low in\noutputs then some use a passive multiple or stacked cable and connect\nVCO~1 externally the pitch and thus save one output.\n\n\\subsubsection*{Detune}\n\nIn the example, if you turn {\\t P1.2}, VCO~2 will be detuned up\nand VCO~3 down. A very slight turn will get get you the nice fat classical\ndetune sound. The speciality here is: the detune is {\\it linear}. This means\nthat the detune is always done by the same number of {\\it Hertz} -- regardless\nof the current pitch. This is done by automatically adapting the detune\nvoltage to be less in higher pitches and greater in lower pitches. The result\nis a beating independent of pitch.\n\n\\subsubsection*{Animation}\n\nSince everything in \\droid is CV'able so is {\\t spread}.\nA nice application is to use a sequencer or clocked random generator for\n{\\it animating} the octaving. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = _RANDOM}    output   = _RANDOM\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[octave]}[octave]\n\\immediate\\write\\patchexamples{    input    = I1}    input    = I1\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    output3  = O3}    output3  = O3\n\\immediate\\write\\patchexamples{    spread   = _RANDOM * P1.1}    spread   = _RANDOM * P1.1\n\\end{droidini}\n\nNow {\\t P1.1} controls the depth of random octave animation.\n\n\\clearpage", "title": " Multi-VCO octave animator", "outputs": [{"count": 3, "start_at": 1, "name": "output1 ... output3", "default": null, "prefix": "output", "type": "voltperoctave", "description": "Outputs for the 1~V / octave of the three VCOs. {\\t output1}\nis an exact copy of {\\t input} so you could omit that and rather patch\nVCO~1 to the original pitch CV.\n"}], "presets": 0}, "midiout": {"category": "midi", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": "1", "type": "integer", "name": "channel", "description": "Selects the MIDI channel to send the events on. Default is to send on\nchannel 1. There are 16 channels. Make sure that the receiving device\nlistens to this (or to all) channels.\n"}, {"default": "0", "type": "gate", "name": "usb", "description": "If {\\t usb = 0}, selects the TRS (3.5mm stereo jack) port of the X7\nto send on. This is the default. Set {\\t usb = 1} for sending the MIDI\ndata via the USB-C port.\n"}, {"count": 8, "start_at": 1, "name": "pitch1 ... pitch8", "default": "0", "prefix": "pitch", "type": "voltperoctave", "description": "Pitch of the notes to be played in modular style (1~V/octave).\nThe range is from -2~V (MIDI note 0, usually C-2) to 8.583~V\n(MIDI note 127, usually G9). You can use up to eight pitch inputs\nfor playing up to eight notes in parallel. {\\t pitch1} can\nbe abbreviated with just {\\t pitch}.\n"}, {"count": 8, "start_at": 1, "name": "gate1 ... gate8", "default": null, "prefix": "gate", "type": "gate", "description": "A positive edge into the gate jacks trigger note on messages\n(starts the note at the pitch set by the corresponding {\\t pitch} input).\nA negative edge ends the currently played note.\n"}, {"count": 8, "start_at": 1, "name": "velocity1 ... velocity8", "default": "1", "prefix": "velocity", "type": "fraction", "description": "The velocities for the up to eight notes. The velocity value is\njust picked up at the start of the note (at the positive edge of\nthe corresponding {\\t gate} inputs. It ranges from 0.0 to 1.0.\nA value of 0.0 is practically the same as ``note off''. The\ndefault velocity is 1.0.\n"}, {"count": 8, "start_at": 1, "name": "noteoffvelocity1 ... noteoffvelocity8", "default": "unpatched", "prefix": "noteoffvelocity", "type": "fraction", "description": "MIDI also sends a velocity at the {\\it end} of a note. The idea\nis to model the speed with which a key is being {\\it released}.\nThis is rarely used. If you don't use these jacks, the\nvelocity for ``note off'' events is the same as that for ``note on''\nevents.\n"}, {"count": 8, "start_at": 1, "name": "pressure1 ... pressure8", "default": "unpatched", "prefix": "pressure", "type": "fraction", "description": "Sends key pressure events for individually played notes via\nthe MIDI event ``polyphonic key pressure'' (this is not a CC!).\nThese values are not processed at the time of note on/off events but\nall the time and can also change while a note is already being\nplayed. This corresponds to ``aftertouch'' key pressure on keyboards\nthat have a pressure sensor {\\it per key}.\n\nIf nothing is patched here, no pressure events are sent.\n"}, {"default": "unpatched", "type": "fraction", "name": "channelpressure", "description": "Whenever this CV changes, sends a MIDI channel pressure event,\nalso known as ``aftertouch''. This corresponds to keyboards that\njust have one global pressure sensor and not one per key.\n\nIf nothing is patched here, no channel pressure events are sent.\n"}, {"default": "1", "type": "gate", "name": "pitchstabilization", "description": "Enables or disables pitch stabilization. It is on per default\nand can be disabled by setting this jack to 0. Pitch stabilization\nfixes timing issues where the input pitch needs some time for\nreaching the target pitch after a gate.\n"}, {"default": "0", "type": "cv", "name": "triggerdelay", "description": "Introduces a delay between in the incoming gate signal (just the\npositive edge) and the ``note on'' event. This can tackle the\nproblem when your pitch input (sequencer etc.) needs some time\nafter the gate in order to reach and stabilize the target pitch.\nThe delay is specified in milliseconds, so a typical useful value would\nbe 5 (5~ms). This is an alternative to the automatic\n{\\t pitchstabilization}. Note: {\\t triggerdelay} disables\n{\\t pitchstabilization}, as long as that is not set to {\\t 1}\nexplicitly. If both are used at the same time, the {\\t triggerdelay}\nhappens {\\it before} the pitch stabilization. So it is a {\\it minimum}\ndelay.\n"}, {"default": "0", "type": "integer", "name": "lowestnote", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n"}, {"default": "127", "type": "integer", "name": "highestnote", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. Note gates are not being affected by this bound.\n"}, {"count": 16, "start_at": 1, "name": "notegate1 ... notegate16", "default": null, "prefix": "notegate", "type": "gate", "description": "You can define up to 16 notes that can be directly controlled\nwith a dedicated gate. This is convenient for playing drum sounds\ndirectly from triggers and also for using DROID controllers as\nMIDI controllers. A trigger or gate to {\\t notegate1} will directly\nplay the note whose pitch is set by {\\t note1}.\n"}, {"count": 16, "start_at": 1, "name": "note1 ... note16", "default": "unpatched", "prefix": "note", "type": "integer", "description": "MIDI notes to played via {\\t notegate}. The range is from\n0 to 127.  Per default the notes are set to the MIDI notes 0, 1, 2\n... 15.\n"}, {"count": 16, "start_at": 1, "name": "notegatevelocity1 ... notegatevelocity16", "default": "1", "prefix": "notegatevelocity", "type": "fraction", "description": "Here you can set the velocities use by the notegates.\nIn order to keep simple, this velocity is used for note on\n{\\it and} note off events (nobody cares about the note off\nvelocity anyway). If you do not use these jacks, the note\ngates will always use the maximum velocity.\n"}, {"default": "0", "type": "fraction", "name": "modwheel", "description": "Sets the current value of the modulation wheel. Any change\nhere sends a midi CC\\#1 with a new value for the modulation wheel.\nThe input range is 0.0 ... 1.0 and will be converted into the\nMIDI range of 0 ... 127. Note: in future we might support\nCC\\#33, which is the LSB value of CC\\#1 and increases the resolution\nfrom 128 to 16384 different values, at the cost -- however -- of\ntwo additional bytes being sent.\n"}, {"default": "1", "type": "fraction", "name": "volume", "description": "Sets the volume of the target device. This is done by sending the\nMIDI CC\\#7 (VOLUME MSB) and MIDI CC\\#39 (VOLUME LSB). Using these\ntwo CCs enables a 14 bit high resolution 16384 levels (not just 127).\nSome devices to not react to CC\\#39 and simply ignore the LSB (least\nsignificant byte). The volume CV ranges from 0.0 (silent) to 1.0\n(the default).\n"}, {"default": "0", "type": "cv", "name": "pitchbend", "description": "Bends the pitches of {\\it all} currently played notes up\nand down by a range that is configured or elsewise defined\nby the device that plays our stuff. The range of this CV is\n-1.0 ... 1.0 for covering the maximum pitch bend range. Most\ntimes that range is two semitones up and down. This\nCV does {\\it not} behave in a 1V/oct way!\n"}, {"default": "0", "type": "integer", "name": "pitchtracking", "description": "Pitch tracking is an advanced feature that allows you to track\ncontinuous changes in the incoming pitch CV {\\it while the note\nis already playing}. It does this by listening to the input CV\nand converting any change into a MIDI ``pitch bend'' change.\n\nThis feature has two limitations:\n\\begin{enumerate}\n\\item There is just one global pitch bend value per channel, not\none per note. So this feature only works in a monophonic situation.\nOnly the value of {\\t pitch1} is being tracked.\nWhen you play more than one note per channel, funny things might\nprobably happen.\n\\item The maximum range is limited by the pitch bend range of\nyour target device. That is usually preset to 2 semitones up and\ndown. If you can make this larger, please also adapt {\\t pitchbandrange}\nso this circuit knows about it.\n\\end{enumerate}\n\nPitch tracking has two levels: {\\t pitchbandrange = 1} will\nalter the pitch of the current note within the maximum range\nof pitch bend and will clip any further changes.\n{\\t pitchbendrange = 2}, in contrast, plays a new note if the\ncurrent range is exceeded. Depending on your sound settings\nthis ``dent'' might be audible or not.\n\nNote: When you use pitch tracking at the same time as\n{\\t pitchbend}, both pitch alterations will add up.\n"}, {"default": "$\\frac{1}{6}$V", "type": "voltperoctave", "name": "pitchbendrange", "description": "Defines the range of the effect of pitch bend at the target\ndevice on a 1V/oct base. Note: You cannot {\\it change} that actual\nrange here. You just can make sure that this circuit has the correct\nassumption of that range.\n\nIf your target device has a configuration for extending the range,\nand you have set that for example to 1 octave, set {\\t pitchbendrange} to 1~V.\nThis allows {\\t pitchtracking} to correctly adapt in-note pitch\nchanges. Note: This has {\\it no} effect on the {\\t pitchbend} CV.\n"}, {"count": 8, "start_at": 1, "name": "ccnumber1 ... ccnumber8", "default": "0", "prefix": "ccnumber", "type": "integer", "description": "Specifies up to eight different CC numbers that can be continuously\nupdated via the corresponding {\\tt cc1} through {\\tt cc4} inputs.\nThe value needs to be an integer number from {\\t 0} to {\\t 127}.\n"}, {"count": 8, "start_at": 1, "name": "cc1 ... cc8", "default": "unpatched", "prefix": "cc", "type": "fraction", "description": "The current value of the CCs that are specified with {\\tt ccnumber1}\nthrough {\\t ccnumber8}. The range is always from 0.0 to 1.0 (which is\nmapped to the number 0 to 127 on the MIDI wire).\n\nIf you don't patch anything here, no CC events will be sent, of course.\n"}, {"count": 8, "start_at": 1, "name": "cctrigger1 ... cctrigger8", "default": null, "prefix": "cctrigger", "type": "trigger", "description": "Usually {\\t midiout} will send out a new CC event every time the\ninput value of a CC has changed (with some rate limit in order to\nto flood the MIDI stream).\n\nWhen you use these inputs, an alternative method is enabled. Now\nCC events are created whenever a trigger arrives here. No more\nupdates will be sent automatically.\n\nThis is useful for target devices that use CCs just as {\\it messages},\ni.e. as one time events and not for updating a continous value.\n"}, {"default": "unpatched", "type": "integer", "name": "bank", "description": "Selects the current ``bank''.\nSome MIDI devices have more than 128 programs (i.e., patches,\ninstruments, preset, etc). A MIDI Program Change message supports\nswitching between only 128 programs. So, ``Bank Select''\n(sometimes also called bank switch) is sometimes used to allow switching\nbetween groups of 128 programs. Bank select uses the MIDI CCs \\#0 (MSB)\nand \\#32 (LSB) together to form a number of 16384 different banks. The\ninput value thus ranges from 1 to 16384.\nMost devices, however, restrict themselves to just 128 banks and just\nuse the MSB (CC\\#0). If that is the case, you need to set\n{\\t bank} to {\\t 128} for bank 2, {\\t 256} for bank 3 and so on. This\ncan be done by simply multiplying the actual bank number with 128.\n"}, {"default": "unpatched", "type": "integer", "name": "program", "description": "Select the current ``program''. This is a number from {\\t 1} to {\\t 128}.\n"}, {"default": null, "type": "trigger", "name": "programchange", "description": "A trigger here will send out a ``program change'' MIDI message even\nif the value of {\\t bank} or {\\t program} has not changed.\n"}, {"default": null, "type": "trigger", "name": "start", "description": "If you send a trigger here, the MIDI message START will be emitted.\nDon't use this jack if you also use {\\t running}. Note: START/STOP\nmessages are not bound to a specific channel.\n"}, {"default": null, "type": "trigger", "name": "stop", "description": "If you send a trigger here, the MIDI message STOP will be emitted.\nDon't use this jack if you also use {\\t running}. Note: START/STOP\nmessages are not bound to a specific channel.\n"}, {"default": null, "type": "gate", "name": "running", "description": "This is an alternative to the jacks {\\t start} and {\\t stop}. It combines\nboth into one ``running'' state. When this gate input goes high,\na START message is sent, when it goes low a STOP message. So you can\nwork with a state rather than with state changes. Note: START/STOP\nmessages are not bound to a specific channel.\n"}, {"default": null, "type": "trigger", "name": "systemreset", "description": "A trigger here will send the MIDI real-time message ``RESET'',\nthat is supposed to bring the device into some start state.\n"}, {"default": null, "type": "trigger", "name": "allnotesoff", "description": "A trigger here will send the MIDI CC\\#123 ``ALL NOTES OFF'', which\nis essentially the same as releasing all currently held keys.\n"}, {"default": null, "type": "trigger", "name": "allsoundoff", "description": "A trigger here will send the MIDI CC\\#120 ``ALL SOUND OFF'', which\nis supposed to make the device silent as soon as possible.\n"}, {"default": "0", "type": "gate", "name": "damper", "description": "This gate input simulates a hold or damper pedal. This is done\nvia the CC\\#64. If the gate goes to high, a value of 127 is being\nsent, when it goes back to low, a value of 0. When the damper pedal\nis pressed, the device is supposed to hold all currently played\nnotes and not react to any subsequent ``NOTE OFF'' {\\it of those\nnotes} as long as the pedal is held. When the pedal is released,\nall notes that had been held be the pedal should be released.\n"}, {"default": "0", "type": "gate", "name": "portamento", "description": "Controls the portamento pedal. The receiver is meant to activate\nsome kind of glide effect as long as this gate is high.\n"}, {"default": "0", "type": "gate", "name": "sostenuto", "description": "This enables the sustain pedal. This is similar to but not exactly\nthe same as the damper pedal as it just holds notes that are pressed\nwhile the pedal goes down.\n"}, {"default": "0", "type": "gate", "name": "soft", "description": "Controls the soft pedal. The receiving synth voice is meant to\nplay notes softer while this pedal is hold down.\n"}, {"default": "0", "type": "gate", "name": "legato", "description": "Controls the legato pedal, which ties subsequent notes together.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "If you feed a steady clock here, a MIDI clock signal will be\nderived from this and sent through the output wire. The {\\it MIDI beat\nclock} or simply {\\it MIDI clock} is defined to send pulses at 24~PPQN:\n24 pulses per quarter note. One quarter note has four \\nth{16}s, so\nthe MIDI clock is running at 6 pulses per \\nth{16} note, and in the modular\nenvironment it is very common to work with \\nth{16} pulses as a master\nclock. So this {\\t clock} jack is meant to retrieve a modular master clock,\nmultiplies this by 6 and creates a MIDI clock from it.\n"}, {"default": null, "type": "trigger", "name": "midiclock", "description": "This is an alternative to {\\t clock}: don't use both at the same\ntime. Here you can directly send the MIDI clock in 24~PPQN.\n"}, {"default": "1", "type": "gate", "name": "activesensing", "description": "This is a switch that disables or enabled {\\t active sensing}. This\nis a MIDI feature where a MIDI sender emits one message of the type\n``active sensing'' every 300~ms. The receiver can use this in order\nto detect if we are still connected and active and also immediately\nreset (und turn all sound off) if these messages stop. Active sensing\nis enabled per default. You can disable it here by setting {\\t\nactivesensing = 0}.\n"}, {"default": "50", "type": "cv", "name": "updaterate", "description": "Specifies the maximum rate at which continuous controllers like\nthe CCs, volume, pitchbend and channelpressure are updated. This\nlimitation is necessary in order not to flood the MIDI interface\nwith too many updates because of just minimal changes. This\nrate is specified in update per second and the default is 50.\nA zero or negative value will completely stop all updates.\n\nNote: depending on how many events are happening on your channel,\nfewer updates might be possible. MIDI over a classical cable is limited\nto 3125 bytes per second. Events typically need 1, 2 or 3 bytes each.\n"}], "description": "This circuit allows you to ``play'' notes via MIDI on an external hardware\nor software synth. You also can send all sorts of other MIDI events. You\nneed the X7 expander for that to work (see page \\pageref{x7}).\n\nThe MIDI implementation of {\\t midiout} is very comprehensive. Please look\nat the table of input jacks for all features. Here I just want to show some\nbasic examples to get you quickly started. Fun fact: This is the only\ncircuit that does not have any outputs, because all output is done via MIDI!\n\n\\subsubsection*{Basic operation}\n\nEasy things should be easy and complex things should be possible.\nSo we start with the easy things. Here is a patch that converts a\nCV / gate input from {\\t I1} / {\\t I2} into a stream of MIDI notes\nand sends them out via the 3.5~mm TRS jack on MIDI channel 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\end{droidini}\n\nEvery time the gate input at {\\t I2} goes from off to on, the current pitch\n(1V/Oct) is read from {\\t I1}. Then one MIDI ``note on'' event is being\ncreated. The ``velocity'' of that note is set to the default value of 1.0,\nwhich is the maximum (every MIDI note event has a velocity, which is meant\nto reflect the speed at which the key of the keyboard has been pressed).\n\nYou can specify any velocity you like with the jack {\\t velocity}. Let's\nrandomize that. Since the velocity jack is just read just at the note\nstarts, we don't need a sample and hold here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    minimum = 0.5 # minimum allowed velocity}    minimum = 0.5 # minimum allowed velocity\n\\immediate\\write\\patchexamples{    maximum = 1.0 # maximum allowed velocity}    maximum = 1.0 # maximum allowed velocity\n\\immediate\\write\\patchexamples{    output = _VELOCITY}    output = _VELOCITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    velocity = _VELOCITY}    velocity = _VELOCITY\n\\end{droidini}\n\nNote: the range of the velocity goes from 0.0 to 1.0 -- just as all other\nparameters in {\\t midiout} do. Internally MIDI uses the integer numbers\n0 to 127.\n\n\\subsubsection*{Polyphonic patches}\n\nOne great motivation for doing CV to MIDI at all is playing polyphonic\nmusic on hardware synths, because polyphony in Eurorack is quite costly and\nvery time and space consuming. One {\\t midiout} circuit can play up to eight notes\nat the same time and if that's not enough, add a second {\\tt midiout}\ncircuit. For each simultaneous note add one pair of {\\t pitch} and {\\t gate}\njacks:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch1 = I1}    pitch1 = I1\n\\immediate\\write\\patchexamples{    pitch2 = I2}    pitch2 = I2\n\\immediate\\write\\patchexamples{    pitch3 = I3}    pitch3 = I3\n\\immediate\\write\\patchexamples{    gate1 = I5}    gate1 = I5\n\\immediate\\write\\patchexamples{    gate2 = I6}    gate2 = I6\n\\immediate\\write\\patchexamples{    gate3 = I7}    gate3 = I7\n\\end{droidini}\n\nIf you work with velocity, each voice has its own velocity input:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch1 = I1}    pitch1 = I1\n\\immediate\\write\\patchexamples{    pitch2 = I2}    pitch2 = I2\n\\immediate\\write\\patchexamples{    pitch3 = I3}    pitch3 = I3\n\\immediate\\write\\patchexamples{    gate1 = I5}    gate1 = I5\n\\immediate\\write\\patchexamples{    gate2 = I6}    gate2 = I6\n\\immediate\\write\\patchexamples{    gate3 = I7}    gate3 = I7\n\\immediate\\write\\patchexamples{    velocity1 = 0.6}    velocity1 = 0.6\n\\immediate\\write\\patchexamples{    velocity2 = 0.8}    velocity2 = 0.8\n\\immediate\\write\\patchexamples{    velocity3 = 1.0}    velocity3 = 1.0\n\\end{droidini}\n\n\\subsubsection*{CC and other controllers}\n\nThere are several continuous values that you can change over time.\nThe following example lets you control the MIDI CC number 17\nvia input {\\t I3} (at a range from 0~V to 10~V) and the\nvolume and modulation wheel with two pots:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    ccnumber1 = 17}    ccnumber1 = 17\n\\immediate\\write\\patchexamples{    cc1 = I3}    cc1 = I3\n\\immediate\\write\\patchexamples{    volume = P1.1}    volume = P1.1\n\\immediate\\write\\patchexamples{    modwheel = P1.2}    modwheel = P1.2\n\\end{droidini}\n\n\\subsubsection*{Note gates}\n\nNote gates are a convenient way to directly trigger certain\nnotes. Here you select up to eight notes and get one dedicated\ntrigger for each. You select the note number with {\\t note1}, {\\t note2}, etc.\nThese are MIDI note numbers from 0 to 127, where 0 is\nusually a C-2 (and 24 a C0). When you send a trigger into the\ncorresponding {\\t notegate} input, that note will be played.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    note2 = 25}    note2 = 25\n\\immediate\\write\\patchexamples{    notegate1 = I1}    notegate1 = I1\n\\immediate\\write\\patchexamples{    notegate2 = I2}    notegate2 = I2\n\\end{droidini}\n\nThis is sometimes convenient when triggering drum voices.\n\n\\subsubsection*{Creating a MIDI clock}\n\nIf you want your to simulate a MIDI sequencer, you need to provide\na MIDI clock. This can be injected into the output either by sending a\nmodular clock that is running on \\nth{16} notes into {\\t clock}, or a raw\nMIDI clock into {\\t midiclock}.\n\nExample: You want your clock to run at 120 BPM. BPM means beats per minute.\nAnd a beat is ment to be a quarter note. 120 quarter notes a minute means\ntwo quarter notes a second and that means eight \\nth{16} notes a second,\nhence our clock needs to run at 8~Hz.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 8 # 120 BPM}    hz = 8 # 120 BPM\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\end{droidini}\n\nNote: The input jack {\\t clock} receives \\nth{16} clocks. The actual MIDI\nclock is derived from that by multiplying it by 6. This means that the\ncircuit interpolates the clock by measuring its speed and introducing five\nartifical clocks ticks inbetween the original ticks. While this works\nreasonably well for a steady clock, changes in clocks speed cannot be picked\nup very fast.\n\nSo if you work with a clock that can change the speed, better use the jack {\\t\nmidiclock} instead and directly supply the MIDI clock (at a six times higher\nspeed). Here is the same example but now we directly create the MIDI clock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 48 # 120 BPM MIDI clock}    hz = 48 # 120 BPM MIDI clock\n\\immediate\\write\\patchexamples{    square = _MIDICLOCK}    square = _MIDICLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    midiclock = _MIDICLOCK}    midiclock = _MIDICLOCK\n\\end{droidini}\n\n\\subsubsection*{Start, Stop, Reset}\n\nMIDI sequencers also output ``start'' and ``stop'' messages.\nYou can send them either via triggers into {\\t start} and {\\t stop}\nor use the input {\\t running} for both. When running goes high,\na ``start'' message is sent, when it goes low a ``stop'' message.\n\n\\subsubsection*{Pitch tracking}\n\nPitch tracking is an advanced feature that works in monophonic\nsetups. Here {\\t midiout} watches the input pitch all the time and\nadapts the pitch of the currently played note via MID pitchbend events\nin order to reflect the pitch changes. See the documentation of\nthe {\\t pitchtracking} jack for details.\n\n\\subsubsection*{Pitch stabilization}\n\nMIDI output appears simple to implement, but isn't when you look\nat the details. One tricky problem is that many modules that output\npitch information are not very precise in timing. Sequencers often\nneed a couple of milliseconds for the pitch CV to reach its final\nvalue and stabilize there after the gate is being output.\n\nThe following diagram shows a gate signal going high (blue) and a\npitch signal with a small ramp reaching its final destination\nshortly afterwards (red):\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 60, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    legend style={at={(0.99,0.38)}},\n]\n\\addplot [color=red]\ncoordinates { (0, 5.5) (20, 5.5) (23, 8.2) (60, 8.2) };\n\\addplot [color=blue]\ncoordinates { (0,0) (20,0) (20, 5) (30, 5) (30, 0) (60, 0) };\n\\legend{Pitch,Gate}\n\\end{axis}\n\\end{tikzpicture}\n\nI've seen a very similar situation indeed when I attached\nan oscilloscope to the output of a very famous Eurorack sequencer.\n\nNow when you would issue ``note on'' right at the beginning of the gate,\nyou would obviously output the wrong pitch. What you need to do is to first\n{\\it wait} for some time. You need to {\\it delay} the note event until the\npitch is stable. Of course this introduces some undesirable latency, so\nit is crucial to keep that as short as possible.\n\nThe {\\tt midiout} circuit has two methods for doing this. The first one\nis enabled per default and called {\\t pitchstabilization}. Here, as soon\nas the gate goes high, it watches how {\\t pitch} evolves\nover time. And it delays the ``note on'' as long as the pitch is still {\\it\nmoving}. When it has stabilized -- i.e. on the same level for at least some\nvery short time -- the note event is issued immediately. This keeps the\nlatency at a minimum.\n\nIf that does not work out well for you, you can deactivate this algorithm.\nOne reason could be that your pitch {\\it never} stabilizes, since it is\nsome ever evolving random data:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    pitchstabilization = 0}    pitchstabilization = 0\n\\end{droidini}\n\nThe second method is introducing a fixed delay of the gate signal with\nthe input {\\t triggerdelay}. Using that parameter automatically disables\npitch stabilization:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    triggerdelay = 3.5 # delay gate by 3.5 ms}    triggerdelay = 3.5 # delay gate by 3.5 ms\n\\end{droidini}\n\nNow the gate is delayed {\\it exactly} 3.5~ms every time. You need to try out\nvarious useful values yourself. The best value depends on your sequencer\n(or whatever other source you are using).\n\nYou can also activate both methods at once. This makes sense in situations,\nwhere the pitch is stable for a very short time after the gate but afterwards\nbegins to move, like in the following diagram:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 60, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    legend style={at={(0.99,0.38)}},\n]\n\\addplot [color=red]\ncoordinates { (0, 5.5) (22, 5.5) (25, 8.2) (60, 8.2) };\n\\addplot [color=blue]\ncoordinates { (0,0) (20,0) (20, 5) (30, 5) (30, 0) (60, 0) };\n\\legend{Pitch,Gate}\n\\end{axis}\n\\end{tikzpicture}\n\nAs you can see, now after the gate comes high the pitch lingers on\nfor 2~ms at its old value until the ramp starts. Here set the\n{\\t triggerdelay} to 2 and explicitly set {\\t pitchstabilization = 1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    triggerdelay = 2}    triggerdelay = 2\n\\immediate\\write\\patchexamples{    pitchstabilization = 1}    pitchstabilization = 1\n\\end{droidini}", "title": " CV to MIDI converter", "outputs": [], "presets": 0}, "burst": {"category": "clock", "inputs": [{"default": "0", "type": "cv", "name": "rate", "description": "Frequency control: The default frequency of the burst rate is 1~Hz\n(one trigger per second or 60~BPM if you like). Each volt doubles\nthe frequency. So an input of 1~V (a number of {\\t 0.1}) speeds up\nto two triggers per second (120~BPM), 2~V ({\\t 0.2}) creates triggers\nat 4~Hz (240~BPM) and so on. On the other hand negative voltages reduce the speed, so\n-1~V ({\\t -0.1}) will give 0.5~Hz (30~BPM) and so on.\n"}, {"default": null, "type": "trigger", "name": "taptempo", "description": "Feed a steady clock here and the burst will run at the speed of\nthat clock -- albeit optionally modified by {\\t rate}. At least\ntwo clock ticks are needed for synchronisation, but always the\nlast three ticks are averaged.\n"}, {"default": "1", "type": "cv", "name": "hz", "description": "Set the frequency in Hz directly by setting a number here. This\nis exclusive to {\\t taptempo}, but will work in combination with\n{\\t rate}.\n"}, {"default": null, "type": "trigger", "name": "trigger", "description": "Send a trigger here in order to start the bursts\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Send a trigger here to immediately stop any ongoing burst.\n"}, {"default": "1", "type": "integer", "name": "count", "description": "Number of triggers to send in one burst.\n"}, {"default": "0", "type": "integer", "name": "skip", "description": "Number of time slots to wait before starting with the burst.\n"}], "description": "This circuit produces -- when triggered -- a number of pulses.\nIt can be used for solving various musical or technical tasks.\nLook at this example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    hz       = 10}    hz       = 10\n\\immediate\\write\\patchexamples{    count    = 5}    count    = 5\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\nWhen a trigger arrives at {\\t I1}, the output {\\t O1} will\nsend five triggers in a row, with a distance of 0.1 seconds (thus\n10~Hz). The gate length is fixed to half of the cycle (thus here 0.05 seconds).\nThis means that the pulse width is 50\\% -- or in other words -- the faster the\nburst the shorter the outgoing triggers.\n\nNote: When a new trigger arrives while the current burst is still ongoing,\nit will not be finished but restarted from the beginning immediately.\n\nIf you want the bursts to be synchronized to a musical clock, you\ncan use the {\\t taptempo} input (here {\\t I2}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I2}    taptempo = I2\n\\immediate\\write\\patchexamples{    count    = 4}    count    = 4\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\nSimilar to the circuit \\circuit{lfo}, there is a third input for selecting\nthe speed: {\\t rate}. This works on a 1~V/Oct base, so here is an example\nfor outputting the bursts at half of the clock speed (-1~V pitches down one\noctave, which is the same as half of the speed):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I2}    taptempo = I2\n\\immediate\\write\\patchexamples{    rate     = @1V}    rate     = -1V\n\\immediate\\write\\patchexamples{    count    = 4}    count    = 4\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\n\n{\\t burst} can also be used for very fast switching through things like presets in\nexternal gear. Here you might want fast updates. Simply set a very high frequency.\nBurst makes sure that the actual output rate is limited to the maximum the DROID\nhardware can do, so not one single burst can get lost. Also you might want to use\nthe {\\t skip} input, which skips a certain number of ticks before starting. This\ncan be used to send out a reset signal to some input and {\\it after that} sending\na couple of {\\t skip forward} triggers to some other input:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    hz = 5000}    hz = 5000\n\\immediate\\write\\patchexamples{    skip = 5}    skip = 5\n\\immediate\\write\\patchexamples{    count = 3}    count = 3\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\n\\subsubsection*{Simple clocked trigger delay}\n\nAnother application of {\\t burst} is a clocked trigger delay. Consider the following\npatch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I1}    taptempo = I1\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    skip = 7}    skip = 7\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nA trigger at {\\t I2} will be delayed by 7 clock cycles.\n\n{\\bf Note:}: This simple trigger delay has no memory of more than one\ntrigger. Any ongoing trigger currently being delayed is overridden and\nforgotten as soon as the next trigger arrives. If that is what you want,\nfine. If you are looking for a more complex trigger delay, you find one\nin the circuit \\circuit{triggerdelay} circuit.\n\n\\pagebreak", "title": " Generate burst of pulses", "outputs": [{"default": null, "type": "trigger", "name": "output", "description": "The triggers are output here.\n"}], "presets": 0}, "clocktool": {"category": "clock", "inputs": [{"default": null, "type": "trigger", "name": "clock", "description": "Patch a steady clock here for this circuit to be of any use\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the internal counters. This is useful if you\nuse the clock divider and want to restart the internal counting from 0,\nin order to align the clock divider with some external sequencers or the like\n"}, {"default": "1", "type": "stepped", "name": "divide", "description": "Number to divide the clock through. This will be rounded to the nearest integer\nnumber. Note: if you want to use an external CV then you need to multiply\nthat with some useful number, since otherwise you will get a number between {\\t 0}\nand {\\t 1} which is not useful at all. Remember: 10 V translates to a number of {\\t 1}.\n"}, {"default": "1", "type": "stepped", "name": "multiply", "description": "Number to multiply the clock with. Same considerations hold as for {divide}.\n"}, {"default": "unpatched", "type": "bipolar", "name": "dutycycle", "description": "Output duty cycle of the clock -- which is essentially a square wave --\nin a range from {\\t 0.0} to {\\t 1.0} or {\\t 0\\%} to {\\t 100\\%}. If you\ndon't patch anything here, the length of the trigger output pulses will\nbe 10~ms (\\droid's standard trigger duration).\n"}, {"default": "unpatched", "type": "cv", "name": "gatelength", "description": "This jack is alternative to {\\t dutycycle} and will override it if it is used.\nIt sets the length of each output pulse to a fixed value that is independent\nof the incoming clock. A value of {\\t 0.5} (a CV of 5 volts) translates into a\ngate length of 0.5 seconds.\n"}, {"default": "0", "type": "cv", "name": "delay", "description": "This CV allows you to shift the {\\it input} clock beat around in time. A value of\n{\\t 0.1} will delay each beat by 10\\% of a clock cycle. A value of {\\t -0.1} is\nalso allowed and shifts the beat 10\\% {\\it ahead}. But this is exactly the same as\n{\\t 0.9}.\n"}], "description": "This circuit implements various clock modifications, such as a clock divider,\na clock multiplier, a tool for changing the length of an incoming gate signal\nand a clock time shift. Here is an example of a simple clock divider that\ndivides the incoming clock by 7 (i.e. for 7 incoming clocks one outgoing\nclock is being produced).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    divide   = 7}    divide   = 7\n\\end{droidini}\n\nThis example doubles the speed of the clock by inserting one additional clock tick\nright in the middle between two incoming ones:\nright in the middle between\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    multiply = 2}    multiply = 2\n\\end{droidini}\n\nBy using multiplication and division at the same time you can create rhythms like\n``two over three'':\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    divide   = 3}    divide   = 3\n\\immediate\\write\\patchexamples{    multiply = 2}    multiply = 2\n\\end{droidini}\n\nPer default the outgoing clock as a duty cycle of 50%, which means that it is\n50% of the time high and 50% of the time low -- basically a symmetrical square wave.\nYou can change this with the {\\t dutycycle} input, e.g. to 20%:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    dutycycle = 20% # same as 0.2}    dutycycle = 20% # same as 0.2\n\\end{droidini}\n\nThe CV {\\t delay} can be used to delay the clock signal -- assumed that the\ninput clock is {\\it steady}. A value of {\\t 1.0} is equivalent of delaying\neach clock by exactly one cycle -- which is pretty useless, since it results\nin the same output clock. But for example a value of {\\t 0.1} will delay\nthe clock by 10\\%. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    delay     = 0.1 # same as 10%}    delay     = 0.1 # same as 10%\n\\end{droidini}\n\nPlease note that this is {\\it not} a trigger delay, since it requires\na steady input clock. Otherwise funny and strange things can happen. But:\nin exchange for that limitation it can also shift a clock {\\it ahead}.\nUsing a small negative number will result in a clock that is always slightly\n{\\it before} the original clock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    delay     = @0.1}    delay     = -0.1\n\\end{droidini}\n\nFeeding a trigger sequencer (like the {\\t algoquencer}, see page \\pageref{algoquencer}) with\na shifted clock allows you fine tuning the exact timing of that voice. You can easily map the\nshift amount to a pot for tuning that live by ear:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = _SHIFTED_CLOCK}    output    = _SHIFTED_CLOCK\n\\immediate\\write\\patchexamples{    delay     = P1.1 * 0.2 @ 0.1 # limit to +/@ 10%}    delay     = P1.1 * 0.2 - 0.1 # limit to +/- 10%\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock     = _SHIFTED_CLOCK}    clock     = _SHIFTED_CLOCK\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\\subsubsection*{Gate length}\n\nPer default the length of the output gate is 10~ms -- independently of the\nlength of the input gate. You can change the gate length either with the\njack {\\t gatelength} and specify a fixed number of seconds, or by using {\\t\ndutycycle}, which is a percentage of the {\\it output} clock rate. Please note:\nif your gate length exceeds the time until the next output gate, both will be\n\"joined\" and thus no new gate will be emitted.\n\nPlease note if you use {\\t dutycycle}: right at the start of the clock signal\nor after a greater speed change of the clock, {\\t clocktool} needs a short\ntime to learn the new clock speed and correctly adapt the new gate length. This\nmight lead to two merging gates, which in turn causes a missing gate output.\n\n\\pagebreak", "title": " Clock divider / multiplier / shifter", "outputs": [{"default": null, "type": "gate", "name": "output", "description": "Here comes the modified clock\n"}, {"default": null, "type": "cv", "name": "inputpitch", "description": "Experimental output that outputs a representation of the input clock's pitch\non a 1V/octave base, based on the reference of 60~BPM (1~Hz). This means that an input\nclock of 120~BPM will output 1V (a value of {\\t 0.1}), since 120~BPM it is one\noctave higher than 60~BPM. If you feed that value to the {\\t rate} input of an LFO\nyou get that running at exactly the same speed (not in the same phase, however).\n"}, {"default": null, "type": "cv", "name": "outputpitch", "description": "Same for the modified output clock\n"}], "presets": 0}, "lfo": {"category": "modulation", "inputs": [{"default": "0", "type": "cv", "name": "rate", "description": "Frequency control: The default frequency of the LFO is 1~Hz\n(one cycle per second or 60~BPM if you like). Each volt doubles\nthe frequency. So an input of 1~V (a number of {\\t 0.1}) speeds up\nthe LFO to 2~Hz (120~BPM), 2~V ({\\t 0.2}) create 4~Hz (240~BPM) and\nso on. On the other hand negative voltages reduce the speed, so\n-1~V ({\\t -0.1}) will give 0.5~Hz (30~BPM) and so on.\n"}, {"default": null, "type": "trigger", "name": "taptempo", "description": "Feed a steady clock here and the LFO will run at the speed of\nthat clock -- albeit optionally modified by {\\t rate}.\n"}, {"default": "1", "type": "cv", "name": "hz", "description": "Set the frequency in Hz directly by setting a number here. Note:\nyou cannot use {\\t hz} at that same time as {\\t taptempo}. But\nboth can be combined with {\\t rate}.\n"}, {"default": "1", "type": "cv", "name": "level", "description": "The maximum positive output level of the LFO. The default of {\\t 1.0}\nmeans a swing between 0~V and 10~V -- unless you enable {\\t bipolar},\nin which case it moves from -10~V to 10~V.\n"}, {"default": "0", "type": "fraction", "name": "randomize", "description": "Randomization is an experimental new feature that combines random\nvoltages with an LFO. If you turn this parameter up, then for each\n{\\it hill} of the LFO's waveform output a new random attenuation is being chosen\nand multiplied with the current level. The result is an output,\nwhere each cycle of the waveform has a different level.\n"}, {"default": "0", "type": "cv", "name": "offset", "description": "The output of the LFO is shifted by that voltage right before\nthe output. This is the same as adding or mixing a\nfixed voltage to the output. Not very fancy, but practical if\nyou want to output a modulation voltage within a certain range.\n"}, {"default": "0", "type": "gate", "name": "bipolar", "description": "If this switch is set to {on}, then the LFO will output a full\nswing from -{level} to +{level}. When set to {off} it will swing\nbetween 0V and +{level}.\n"}, {"default": "0", "type": "fraction", "name": "phase", "description": "Shift the LFOs phase by this value. A value of {\\t 0.0} leaves the LFO\nrun in its normal phase. {\\t 0.5} will shift bei $180^\\circ$.\nAnd {\\t 1.0} will shift by a complete phase of $360^\\circ$, which\nis the same as {\\t 0.0}.\n"}, {"default": "0.5", "type": "bipolar", "name": "pulsewidth", "description": "This sets the pulse width of the square LFO and only affects the\noutput {\\t square}. It ranges from {\\t 0.0} to {\\t 1.0}. Please note that\nals pulse width of exactly 0.0 or 1.0 will make the output stick\nto the lower or upper level.\n"}, {"default": "0.5", "type": "bipolar", "name": "skew", "description": "Modifies the symmetry of the triangle output by shifting the\n``peak'' of the triangle left and right. The default of {\\t 0.5}\ncreates a symmetric waveform. Smaller values speed up the rising\npart of the triangle and create more and more a ramp like waveform\nuntil a skew of {\\t 0.0} creates an exact ramp -- just the same as\nthe {\\t ramp} output. A skew of {\\t 1.0} create a sawtooth waveform.\n"}, {"default": null, "type": "trigger", "name": "sync", "description": "A positive trigger edge at this input will reset the LFO. It will\nforce to restart the waveform at its ``beginning''. By using the\ninput {syncphase} you can change that behaviour.\n"}, {"default": "0", "type": "fraction", "name": "syncphase", "description": "This input changes the behaviour of the {\\t sync} input. I changes\nthe phase the waveform restarts at when it receives a sync trigger.\nE.g. by setting this to {\\t 0.5} a sync trigger will restart the waveform\nright at its middle. This is an interesting feature that cannot be\nfound in analog LFOs since it would be very hard to build in actual\ncircuits.\n"}, {"default": "0", "type": "cv", "name": "waveform", "description": "If you use {\\t output} -- rather than the individual waveform outputs like\n{\\t square}, {\\t saw} and so on -- this input selects the Wave form. An integer\nnumber from {\\t 0} to {\\t 6} selects one of the seven available waveforms. Any number\nin between selects a mixture of the two neighboring waveforms. That way you can smoothly\nmorph through all the available waveforms. The codes for the waveforms are:\n\n\\begin{tabular}{|ll|ll|ll|ll|ll|ll|ll|} \\hline\n\\t 0 & square  & \\t 1 & sawtooth & \\t 2 & triangle & \\t 3 & ramp & \\t 4 & paraboloid & \\t 5 & sine & \\t 6 & cosine \\\\  \\hline\n\\end{tabular}\n\\medskip\n"}], "description": "This circuit implements a very flexible low frequency oscillator (LFO) with\nseven different waveforms, each of which is available at its own output as well\nas on a common output with waveform selection.  It offers phase modulation,\na flexible sync mechanism, randomization and other interesting features.\n\nPlease note also that this LFO is not intended to be used at audio rate. It can\nprobably operate until roughly 1000-1500 Hz, but will sound ugly, distorted\nand with many digital artefacts -- especially the waveforms with steep edges like\nsquare, ramp and sawtooth. If that's exactly what you intend, then maybe\nyou will have fun anyway.\n\n\\subsubsection*{Waveforms}\n\nHere is the simplest possible patch. In this example the frequency is\nspecified in Hertz (cycles per seconds) and the {\\t triangle} output\nis routed directly to {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\nThe resulting output looks like this:\n\n\\newenvironment{lfounipolar}[1]{\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = #1, ymin = 0, ymax = 10,\n    yscale = 0.5,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]}\n{\\end{axis}\n\\end{tikzpicture}}\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,0) (.125,10) (.25,0) (.375,10) (.5,0)\n    (.625,10) (.75,0) (.875,10) (1,0) };\n\\end{lfounipolar}\n\n\\columnbreak\nThis is how the {\\t sawtooth} output looks like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    sawtooth = O1}    sawtooth = O1\n\\end{droidini}\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates { (0,0) (0.25,10) (0.25,0) (0.5, 10) (0.5, 0) (0.75, 10) (0.75, 0) (1.0, 10)  };\n\\end{lfounipolar}\n\nThe {\\t ramp} is similar but falling instead of rising:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates { (0,10) (0.25,0) (0.25,10) (0.5, 0) (0.5, 10) (0.75, 0) (0.75, 10) (1.0, 0)  };\n\\end{lfounipolar}\n\nThe waveforms {\\t \\textcolor{blue}{sine}} and {\\t \\textcolor{magenta}{cosine}}\nare similar but are one quarter cycle (90\\textdegree{}) apart:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue,samples=100] {(sin(x * 360 * 4) + 1) * 5};\n\\addplot [domain=0:1,color=magenta,samples=100] {(cos(x * 360 * 4) + 1) * 5};\n\\end{lfounipolar}\n\n\\columnbreak\n{\\t paraboloid} is {\\it very} similar to sine, but is constructed based\non quadratic equations (which is faster):\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0.0:0.0625,color=blue,samples=20]   {(2-(1-((x-0.0)    * 16))^2) * 5};\n\\addplot [domain=0.0625:0.125,color=blue,samples=20] {(2-(0+((x-0.0625) * 16))^2) * 5};\n\\addplot [domain=0.125:0.1875,color=blue,samples=20] {(0+(1-((x-0.125)  * 16))^2) * 5};\n\\addplot [domain=0.1875:0.25,color=blue,samples=20]  {(0+(0+((x-0.1875) * 16))^2) * 5};\n\\addplot [domain=0.25:0.3125,color=blue,samples=20]  {(2-(1-((x-0.25)   * 16))^2) * 5};\n\\addplot [domain=0.3125:0.375,color=blue,samples=20] {(2-(0+((x-0.3125) * 16))^2) * 5};\n\\addplot [domain=0.375:0.4375,color=blue,samples=20] {(0+(1-((x-0.375)  * 16))^2) * 5};\n\\addplot [domain=0.4375:0.5,color=blue,samples=20]   {(0+(0+((x-0.4375) * 16))^2) * 5};\n\\addplot [domain=0.5:0.5625,color=blue,samples=20]   {(2-(1-((x-0.5)    * 16))^2) * 5};\n\\addplot [domain=0.5625:0.625,color=blue,samples=20] {(2-(0+((x-0.5625) * 16))^2) * 5};\n\\addplot [domain=0.625:0.6875,color=blue,samples=20] {(0+(1-((x-0.625)  * 16))^2) * 5};\n\\addplot [domain=0.6875:0.75,color=blue,samples=20]  {(0+(0+((x-0.6875) * 16))^2) * 5};\n\\addplot [domain=0.75:0.8125,color=blue,samples=20]  {(2-(1-((x-0.75)   * 16))^2) * 5};\n\\addplot [domain=0.8125:0.875,color=blue,samples=20] {(2-(0+((x-0.8125) * 16))^2) * 5};\n\\addplot [domain=0.875:0.9375,color=blue,samples=20] {(0+(1-((x-0.875)  * 16))^2) * 5};\n\\addplot [domain=0.9375:1.0,color=blue,samples=20]   {(0+(0+((x-0.9375) * 16))^2) * 5};\n\\end{lfounipolar}\n\nMaybe the simplest waveform is {\\t square}:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,10) (0.125,10) (0.125,0) (0.25, 0) (0.25, 10) (0.375, 10) (0.375, 0) (0.5, 0)\n    (0.5,10) (0.625,10) (0.625,0) (0.75, 0) (0.75, 10) (0.875, 10) (0.875, 0) (1.0, 0)\n\n    };\n\\end{lfounipolar}\n\n\n\\subsubsection*{Bipolar output, Level and Offset}\n\nPlease note that the LFO outputs just positive voltage ranges until you set\n{\\t bipolar = on}. That extends the waveform to negative voltages (while\ndoubling the peak-to-peak voltage):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    bipolar  = on}    bipolar  = on\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\n\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 1, ymin = -10, ymax = 10,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,-10)\n    (.125,10)\n    (.25,-10)\n    (.375,10)\n    (.5,-10)\n    (.625,10)\n    (.75,-10)\n    (.875,10)\n    (1,-10)\n};\n\\end{axis}\n\\end{tikzpicture}\n\nThe inputs {\\t level} and {\\t offset} can be used to control the voltage range\nof the outputs -- which is here for your convenience and avoids the need for\nadditional circuits for doing this. The following example outputs a sine\nwave at 5 Hz to {O4} that is gently oscillating between 2 V and 3.5V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 5}    hz          = 5\n\\immediate\\write\\patchexamples{    level       = 1.5V}    level       = 1.5V\n\\immediate\\write\\patchexamples{    offset      = 2V}    offset      = 2V\n\\immediate\\write\\patchexamples{    sine        = O4}    sine        = O4\n\\end{droidini}\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 1, ymin = 0, ymax = 4.5,\n    ymajorgrids = true,\n    ytick={0, 1, 2, 3, 4},\n    grid style = dashed,\n]\n\\addplot [domain=0:1,color=blue,samples=100] {0.75 * sin(x * 360 * 5) + 2.75};\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{Frequency control}\n\nThe frequency of the LFO can be controlled in various ways. In the upper\nexamples we used the input {\\t hz}. Here you specify the frequency of\nthe LFO directly in Hz. This is ideal when you want to set a fixed\nfrequency with a discrete number, rather than a control voltage. Here\nis a rectangle LFO running at 1.5 cycles per second (90~BPM):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz         = 1.5}    hz         = 1.5\n\\immediate\\write\\patchexamples{    rectangle  = O3}    rectangle  = O3\n\\end{droidini}\n\nA more eurorack-like way is using the {\\t rate} input, which works on a 1~V /\noctave scheme. One ``octave'' here means that the frequency doubles. Here is an\nexample for creating a triangle LFO running at 4~Hz, since 2~V doubles the base\nfrequency of 1~Hz two times (instead of {\\t 2V} you could also write {\\t 0.2}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    rate     = 2V}    rate     = 2V\n\\immediate\\write\\patchexamples{    bipolar  = on}    bipolar  = on\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\n\nThe third way is to use {\\it tap tempo} by sending a steady clock into {\\t\ntaptempo}. The LFO than mimics the speed of that input clock. This can\neven be combined with {\\t rate}: If you use both, then first {\\t taptempo}\nis being used to set the speed and then {\\t rate} is used for altering that\nspeed. So sending -1~V into {\\t rate} will create an LFO running at half clock\nspeed (since -1~V pitches down the LFO by one octave).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    taptempo   = G1 # steady clock here}    taptempo   = G1 # steady clock here\n\\immediate\\write\\patchexamples{    rate       = @1V # run at half clock speed}    rate       = -1V # run at half clock speed\n\\immediate\\write\\patchexamples{    sawtooth   = O2}    sawtooth   = O2\n\\end{droidini}\n\n\n\\subsubsection*{Randomization}\n\nRandomization is an experimental new feature that combines random voltages\nwith an LFO. If you turn this parameter up, then for each ``hill'' of the\noutput waveform has a different height. The parameter {\\t randomize} controls\nhow strong that effect is. With {\\t 0.0} randomization is turned off.\nAt {\\t 1.0} it is at its strongest and the random level of each hill is\nin the range 0.0 \\dots\\ 1.0.\n\nHere is an example of a randomized sine wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz        = 0.5}    hz        = 0.5\n\\immediate\\write\\patchexamples{    randomize = 0.8}    randomize = 0.8\n\\immediate\\write\\patchexamples{    sine      = O1}    sine      = O1\n\\end{droidini}\n\nThe original wave if printed \\textcolor{blue!20!white}{\\bf light} and the\nand the randomized wave at output {\\t O1} is \\textcolor{magenta}{\\bf magenta}:\n\n\n\\begin{lfounipolar}{6}\n\\addplot [domain=0:8,color=blue!20!white,samples=100] {sin(x * 180) + 1) * 5};\n\\addplot [domain=-0.5:1.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 9.5};\n\\addplot [domain=1.5:3.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 4};\n\\addplot [domain=3.5:5.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 6};\n\\addplot [domain=5.5:7.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 2};\n\\addplot [domain=7.5:8,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 7};\n\\end{lfounipolar}\n\nPlease note: If you turn {\\t bipolar} on, then a ``hill'' is considered\nto be something {\\it above} or {\\it below} the zero line. That means that\nnow the sine wave has twice as much hills and the randomization works\ndifferent. Here is an example patch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz        = 0.5}    hz        = 0.5\n\\immediate\\write\\patchexamples{    randomize = 0.8}    randomize = 0.8\n\\immediate\\write\\patchexamples{    sine      = O1}    sine      = O1\n\\immediate\\write\\patchexamples{    bipolar   = 1}    bipolar   = 1\n\\end{droidini}\n\nAnd this is how the output looks like:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 6, ymin = -10, ymax = 10,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:8,color=blue!20!white,samples=100] {sin(x * 180) * 10};\n\\addplot [domain=0:1,color=magenta,samples=100] {sin(x * 180) * 9.5};\n\\addplot [domain=1:2,color=magenta,samples=100] {sin(x * 180) * 3.5};\n\\addplot [domain=2:3,color=magenta,samples=100] {sin(x * 180) * 4};\n\\addplot [domain=3:4,color=magenta,samples=100] {sin(x * 180) * 2};\n\\addplot [domain=4:5,color=magenta,samples=100] {sin(x * 180) * 6};\n\\addplot [domain=5:6,color=magenta,samples=100] {sin(x * 180) * 7};\n\\addplot [domain=6:7,color=magenta,samples=100] {sin(x * 180) * 2};\n\\addplot [domain=7:8,color=magenta,samples=100] {sin(x * 180) * 8};\n\\end{axis}\n\\end{tikzpicture}\n\nNote: Since not all waveform have there ``hills'' at the same place and the\nstart and end of a hill might even be affected by {\\t skew} or {\\t pulsewidth},\neach waveform output has its own independent randomization. Therefore\n{\\t cosine} is {\\it not} the phase shifted output of {\\t sine} anymore,\nif you use randomization.\n\n\\subsubsection*{Wave form selection and morphing}\n\nAs an alternative to the seven indiviual waveform outputs there is a common\noutput simply called {\\t output}. The waveform can be selected with the\ninput {\\t waveform} and defaults to {\\t 0}, which means {\\it square wave}.\nSo for a simple clock you can write:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    output = G1}    output = G1\n\\end{droidini}\n\nA triangle wave is selected with the code {\\t 2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    output = G1}    output = G1\n\\immediate\\write\\patchexamples{    waveform = 2}    waveform = 2\n\\end{droidini}\n\nHere is the complete list of available waveforms:\n\n\\begin{tabular}{|l|l|} \\hline\n \\t 0 & square  \\\\ \\hline\n \\t 1 & sawtooth \\\\ \\hline\n \\t 2 & triangle \\\\ \\hline\n \\t 3 & ramp \\\\ \\hline\n \\t 4 & paraboloid \\\\ \\hline\n \\t 5 & sine \\\\ \\hline\n \\t 6 & cosine \\\\  \\hline\n\\end{tabular}\n\nIt is allowed to use non-integer values, like {\\t 0.5}. This will create a mixture\nbetween two adjacent waveforms -- while respecting the ratio. For example {\\t 2.1}\nwill select 90\\% triangle and 10\\% ramp. That way you can smoothly morph through\nthe available waveforms. Here is an example. Let's start with {\\t waveform = 0.0},\nwhich gives a plain square wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 0.0}    waveform = 0.0\n\\end{droidini}\n\nAnd this is what it looks like:\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,10) (0.5,10) (0.5,0) (1.0,0)\n    (1,10) (1.5,10) (1.5,0) (2.0,0)\n    (2,10) (2.5,10) (2.5,0) (3.0,0)\n    (3,10) (3.5,10) (3.5,0) (4.0,0)\n};\n\\end{lfounipolar}\n\nAt {\\t 1.0} we get a saw tooth:\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 1.0}    waveform = 1.0\n\\end{droidini}\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,0) (1,10)\n    (1,0) (2,10)\n    (2,0) (3,10)\n    (3,0) (4,10)\n};\n\\end{lfounipolar}\n\nAnd in between -- at {\\t 0.5} -- we get some\nmixture:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 0.5}    waveform = 0.5\n\\end{droidini}\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,5.0) (0.25,6.25) (0.5, 7.5) (0.5, 2.5) (0.75, 3.75) (1.0, 5.0)\n    (1,5.0) (1.25,6.25) (1.5, 7.5) (1.5, 2.5) (1.75, 3.75) (2.0, 5.0)\n    (2,5.0) (2.25,6.25) (2.5, 7.5) (2.5, 2.5) (2.75, 3.75) (3.0, 5.0)\n    (3,5.0) (3.25,6.25) (3.5, 7.5) (3.5, 2.5) (3.75, 3.75) (4.0, 5.0)\n};\n\\end{lfounipolar}\n\n\n\n\\pagebreak", "title": " Low frequency oscillator (LFO)", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Main output of the LFO.\n"}, {"default": null, "type": "cv", "name": "square", "description": "A square waveform -- modified by {\\t pulsewidth}.\n"}, {"default": null, "type": "cv", "name": "sawtooth", "description": "Outputs a sawtooth waveform -- i.e. a rising ramp\n"}, {"default": null, "type": "cv", "name": "triangle", "description": "Outputs a triangle waveform -- modified by {\\t skew}.\n"}, {"default": null, "type": "cv", "name": "ramp", "description": "Outputs a falling ramp -- like a sawtooth that is mirrored. Note:\nif the LFO is set to bipolar then this is the negation of {\\t sawtooth}.\nIf it is set to unipolar then this is not the case. The waveform\nwill be positive then!\n"}, {"default": null, "type": "cv", "name": "paraboloid", "description": "An experimental waveform that looks very similar to a sine\nwave but is derived from a triangle by computing the square\nof each waypoint's distance to {\\t level}.\n"}, {"default": null, "type": "cv", "name": "sine", "description": "A sine waveform.\n"}, {"default": null, "type": "cv", "name": "cosine", "description": "A sine waveform shifted by $90^\\circ$. This output is for your\nconvenience and avoids needing two LFO circuits in cases where you\nwant to make quadrature applications. Please note that $180^\\circ$\nand $270^\\circ$ can easily be achieved by negating the outputs {\\t sine}\nand {\\t cosine} at a later stage.\n"}], "presets": 0}, "random": {"category": "modulation", "inputs": [{"default": null, "type": "trigger", "name": "clock", "description": "Optional triggger: if this input is used then the output holds\nthe current random number until the next clock impulse (sample \\& hold)\n"}, {"default": "0", "type": "cv", "name": "minimum", "description": "Minimum possible random number\n"}, {"default": "1", "type": "cv", "name": "maximum", "description": "Maximum possible random number\n"}, {"default": "0", "type": "integer", "name": "steps", "description": "Number of different voltage levels. If this is set to 0 (default),\nany voltage can appear, there is no limit. If this is {\\t 1}, then there is no\nrandom any more since there is only one allowed step (which is the average\nbetween {\\t minimum} and {\\t maximum}. At {\\t 2} the only two possible\noutput values are {\\t minimum} and {\\t maximum}. At {\\t 3} the possible\nlevels are {\\t minimum}, $\\frac{{\\t minimum} + {\\t maximum}}{2}$\nand {\\t maximum} and so on...\n"}], "description": "This circuit creates random numbers between two tunable levels\n{\\t minimum} and {\\t maximum}. In clocked mode each clock creates and holds\na new random value. In unclocked mode the random values change\nat the maximum possible speed (about 6000 times per second).\n\nSimple example for clocked random numbers between {\\t 0.0} and {\\t 1.0}\n({\\t 1.0} translates into 10~V at the output):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nExample for creating random output voltages between 1~V and 3~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\immediate\\write\\patchexamples{    minimum = 1V}    minimum = 1V\n\\immediate\\write\\patchexamples{    maximum = 3V}    maximum = 3V\n\\end{droidini}", "title": " Random number generator", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Output of the random number / voltage\n"}], "presets": 0}, "sample": {"category": "cv", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Input signal to be sampled\n"}, {"default": null, "type": "trigger", "name": "sample", "description": "A positive trigger here will read the current value from\n{\\t input} and store it internally.\n"}, {"default": null, "type": "gate", "name": "gate", "description": "This is an alternative way of making the circuit take a sample\nfrom the input. Here it is sampling all the time while the gate\nis high. In that way it is a bit like {\\t bypass}. But as soon\nas the gate goes low again, the output sticks to the last sample\nvalue just before that.\n"}, {"default": "0", "type": "cv", "name": "timewindow", "description": "This optional parameter helps tackling a problem that\nmany (non-analog) sequencers show: often their pitch CV\nis not at its final destination value at the time their\ngate is being output. Often you see a very short ``slew''\nramp of say 5~ms after the gate. During that time the pitch\nCV moves from its former to the new value.\n\nNow if you trigger the {\\t sample} circuit with the sequencer's\ngate you will essentially sample the {\\it previous} pitch\nCV instead of the new one. Or maybe something in between.\n\nNow the {\\t timewindow} parameter introduces a short time window after\nthe {\\t sample} trigger. During that time period the sample \\& hold\ncircuit will constantly adapt to a changed input CV (is essentially\nin bypass mode). When that time is over, the input is finally frozen.\n\nThe {\\t timewindow} parameter is in seconds. So when you set {\\t\ntimewindow} to say 0.005 (which means 5~ms), you give the\ninput CV 5~ms time for settling to its final value after a trigger\nto {\\t sample} before freezing it.\n"}, {"default": null, "type": "gate", "name": "bypass", "description": "While this gate input is high, the circuit is bypassed and\n{\\t input} is copied to {\\t output}.\n"}], "description": "This is a simple sample \\& hold circuit. Each time a positive trigger is\nseen at the jack {\\t sample} a new value is sampled from {\\t input} and sent\nto the {\\t output}.\n\nExample:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sample]}[sample]\n\\immediate\\write\\patchexamples{    input       = I1}    input       = I1\n\\immediate\\write\\patchexamples{    sample      = I2}    sample      = I2\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}", "title": " Sample \\& Hold Circuit", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "The most recently sampled value is sent here.\n"}], "presets": 0}, "fold": {"category": "pitch", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Input CV to be folded.\n"}, {"default": "0.1", "type": "cv", "name": "foldby", "description": "Amount to be added or substracted from the input CV if\nit is not within the allowed range. This CV must be positive.\nIf it is negative or zero, no folding will be done.\n"}, {"default": "unpatched", "type": "cv", "name": "minimum", "description": "Lower bound of the allowed range. If unpatched, no lower\nbound will be applied.\n"}, {"default": "unpatched", "type": "cv", "name": "maximum", "description": "Upper bound of the allowed range. If unpatched, no upper\nbound will be applied.\n"}], "description": "This circuit can keep an incoming CV within defined bounds,\nbut not by limiting to these bounds, but by {\\it folding} it\nin case it exceeds these bounds.\n\nThe main application is keeping the pitch of a voice within a certain range by\noctaving it up and down when necessary. Octaving keeps the actual note value.\nHere is an example for that application:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V # one octave}    foldby = 1V # one octave\n\\immediate\\write\\patchexamples{    minimum = 1.2V}    minimum = 1.2V\n\\immediate\\write\\patchexamples{    maximum = 2.5V}    maximum = 2.5V\n\\end{droidini}\n\nIf the input value at {\\t I1} is going below 1.2~V, 1~V will\nbe added over and over until the output voltage is at least 1.2~V.\nSo the upper example will convert as follows:\n\n\\begin{itemize}\n\\item 0.7~V $\\rightarrow$ 1.7~V\n\\item 2.0~V $\\rightarrow$ 2.0~V\n\\item -4.3~V $\\rightarrow$ 1.7~V\n\\item 4.4~V $\\rightarrow$ 2.4~V\n\\end{itemize}\n\nIf you apply that to a bass voice, you make sure that it never\ngoes to low or too high, which is helpful if that voice is the\nresult of a combination of sequences, random numbers, transpositions\nand other funny generative ideas.\n\nNote: If you do not specify {\\t minimum} or {\\t maximum},\nno folding will take place at that boundary. If you specify\nneither of them, this circuit is completely useless.\n\n\\subsubsection*{Anomalies}\n\nTwo anomalies can happen if the parameters are a bit ``crazy''.\nThis first one happens, when the space between {\\t minimum} and {\\t maximum}\nis less than one {\\t foldby}. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V}    foldby = 1V\n\\immediate\\write\\patchexamples{    minimum = 1.1V}    minimum = 1.1V\n\\immediate\\write\\patchexamples{    maximum = 1.3V}    maximum = 1.3V\n\\end{droidini}\n\nNow if the input voltage is e.g. 1.0~V, it will be folded up to 2.0~V, which\nis then above the maximum range. But it will stay there, since there is no way\nto fold it into the range anyway.\n\nThe second anomaly is if {\\t minimum} is greater than {\\t maximum}. Look:\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V}    foldby = 1V\n\\immediate\\write\\patchexamples{    minimum = 2.5V}    minimum = 2.5V\n\\immediate\\write\\patchexamples{    maximum = 1.5V}    maximum = 1.5V\n\\end{droidini}\n\nHere any voltage below 2.5~V will be folded up until it is above that value.\nso 2.4~V will be folded to 3.4~V. Well, you could also argue that because\n2.4~V is also above the maximum value it should get folded down instead. While\nthat is true, {\\t fold} behaves asymmetrical here and gives folding up the precedence.\n\nBut why would you set such strange parameters? Well, because they can be CVs\nof course. Try the following patch and send the output {\\t O1} to the pitch\ninput of a voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P1.1}    hz = 2 * P1.1\n\\immediate\\write\\patchexamples{    triangle = _CV}    triangle = _CV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P1.2}    hz = 2 * P1.2\n\\immediate\\write\\patchexamples{    triangle = _MIN}    triangle = _MIN\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P2.1}    hz = 2 * P2.1\n\\immediate\\write\\patchexamples{    triangle = _MAX}    triangle = _MAX\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P2.2}    hz = 2 * P2.2\n\\immediate\\write\\patchexamples{    triangle = _FOLDBY}    triangle = _FOLDBY\n\\immediate\\write\\patchexamples{    level = 2V}    level = 2V\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = _CV}    input = _CV\n\\immediate\\write\\patchexamples{    minimum = _MIN}    minimum = _MIN\n\\immediate\\write\\patchexamples{    maximum = _MAX}    maximum = _MAX\n\\immediate\\write\\patchexamples{    foldby = _FOLDBY}    foldby = _FOLDBY\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    rate = O1 * 0.2}    rate = O1 * 0.2\n\\immediate\\write\\patchexamples{    hz = 110}    hz = 110\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\end{droidini}\n\nHere all four inputs are from slowly running LFOs and funny things happen.\nPlay with the four pots and you will get all sorts of very interesting\nrandom patterns.", "title": " CV folder -- keep (pitch) CV within certain bounds", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Folded output voltage\n"}], "presets": 0}, "droid": {"category": "other", "inputs": [{"default": "1", "type": "cv", "name": "ledbrightness", "description": "Let's you dim all of the 24 LEDs of the master and the G8. This\nis mainly for those who think they are too bright. But since this\nparameter can be CV-controlled, you could of course also do funny\nthings with it. Beware: if you set this to zero, the LEDs will\nbe completely dark. This also includes possible error messages.\n"}, {"count": 8, "start_at": 1, "name": "maxslope1 ... maxslope8", "default": "0.25", "prefix": "maxslope", "type": "cv", "description": "Sets a threshold for a voltage change between two samples until\nthe internal logic of the \\droid outputs assumes that\nthis step is intentional and should not be smoothed out.\nA typical case where you do not want smoothing is the pitch\noutput of a sequencer.\n\nThe default value is {\\t 0.25}. A value of {\\t 0.0} turns\noff smoothing altogether since the slightest voltage change\nis considered an intentional jump.\n"}, {"count": 8, "start_at": 1, "name": "lpfilter1 ... lpfilter8", "default": "0.25", "prefix": "lpfilter", "type": "fraction", "description": "Configures a digital low pass filter on the output in order\nto smooth out digital noise resulting from the \\droid's main\nloop. This loop is running somewhere between 3 and 6 kHz -- depending\non the number of circuits you use.\n\nPer default this filter is set to {\\t 0.25} -- which means a mild\nfiltering -- thus still allowing fast and snappy envelopes and\nother rapidly changing signals while filtering away most of the\ndigital artefacts.\n\nIf you use an output for a slow envelope that is combined with an\naudio path in a way that you hear digital artifacts then increase\nthat value. This is e.g. the case if you modulate a VCA that in\nturn modulates a very low pitched audio wave with very few harmonics\n(such as a sine or triangle wave).\n\nThe maximum value of {\\t 1.0} leads to a very strong filtering -- i.e.\nremoving all fast transients. Snappy envelopes will be smoothed out\nheavily. Square wave LFOs will be converted into lower level almost\nsine waves.\n"}], "description": "This circuit gives access to some general \\droid configuration\nsettings. It does not make sense to create more than one\ninstance of this.", "title": " General DROID controls", "outputs": [], "presets": 0}, "mixer": {"category": "cv", "inputs": [{"count": 8, "start_at": 1, "name": "input1 ... input8", "default": "0", "prefix": "input", "type": "cv", "description": "\\nth1 ... \\nth 8 mixing input\n"}], "description": "The main task of this circuit is simply adding up to eight inputs. Furthermore\nit can do simple operations like minimum, maximum and average. Please note that\nsince every input always can be offset and attenuated, it's like a mixer\nwith a CV controlled level and CV controlled offset per input channel.\n\nMinimal example, mixing together two inputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nSince every input can add an offset, mixing four inputs can be\ndone with two lines if you like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{    input1 = I1 + I2}    input1 = I1 + I2\n\\immediate\\write\\patchexamples{    input2 = I3 + I4}    input2 = I3 + I4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nPlease note that an unpatched input is (sometimes) not the same as an input where {0.0}\nis being sent. The difference arises if you use {\\t minimum}, {\\t maximum} and {\\t average}, since\nthese just consider the patched inputs.\n\nIf eight inputs are not enough then you can simply create a mesh by mixing together the\noutputs of several submixers.", "title": " CV mixer", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Sum of all patched inputs\n"}, {"default": null, "type": "cv", "name": "maximum", "description": "Maximum of all patched inputs of this circuit. This can e.g. be used for mixing together the\nenvelopes from several sequencer tracks without making them ``louder''\nor distorting them when two sequencers play a note at the same time.\n"}, {"default": null, "type": "cv", "name": "minimum", "description": "Minimum of all patched inputs of this circuit.\n"}, {"default": null, "type": "cv", "name": "average", "description": "Average of all patched inputs of this circuit.\n"}], "presets": 0}, "sequencer": {"category": "sequencing", "inputs": [{"default": null, "type": "trigger", "name": "clock", "description": "Each trigger into this jack advances the sequence\nby one step.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the sequence to the first step\n"}, {"default": "unpatched", "type": "integer", "name": "stages", "description": "Number of inputs of {\\t pitch..}, {\\t gate..}, {\\t slew..}, {\\t cv} and\n{\\t repeats} that should be used. If you set stages to a number higher\nthan the number of used inputs, all inputs will be used.\nIf you omit this parameter, all used inputs will be used.\n"}, {"default": "0", "type": "integer", "name": "steps", "description": "With this input you can force the sequencer to begin from start\nafter a certain number of clock cycles. If you omit the parameter\nor if it is set to 0, the sequencer will play all stages with all\nrepeats until it resets to the beginning.\n"}, {"default": "0", "type": "cv", "name": "transpose", "description": "This voltage is added to the pitch output.\n"}, {"default": "1", "type": "cv", "name": "outputscaling", "description": "The output pitch is multiplied by this parameter.\n"}, {"default": "unpatched", "type": "cv", "name": "gatelength", "description": "The length of the output gates. If it is unpatched, the original\ninput clock is fed through 1:1 (with its own duty cycle). When used it\nis a ratio from {\\t 0.0} to {\\t 1.0} and relative to the cycle of the\ninput clock.\n"}, {"count": 8, "start_at": 1, "name": "pitch1 ... pitch8", "default": "0", "prefix": "pitch", "type": "cv", "description": "These are the pitches of the various steps. You can put fixed numbers\nhere but also of course pots or variable inputs. Note: The number of\n{\\it used} {\\t input} jacks defines the length of the sequence,\nunless you override that with {\\t stages}.\n"}, {"count": 8, "start_at": 1, "name": "cv1 ... cv8", "default": "0", "prefix": "cv", "type": "cv", "description": "Each step has an optional CV assigned. You can use that CV for\nmodulating something or even outputting a second pitch information.\n"}, {"count": 8, "start_at": 1, "name": "gate1 ... gate8", "default": "1", "prefix": "gate", "type": "gate", "description": "The gate inputs should be {\\t 0} ({\\t off}) or {\\t 1} ({\\t on}).\nFor stages with a 0-gate no output gate is produced and the pitch\ninformation is kept at the previous state. Unpatched gates are\nconsidered to be on!\n"}, {"count": 8, "start_at": 1, "name": "slew1 ... slew8", "default": "0", "prefix": "slew", "type": "cv", "description": "Enables slew limiting for that stage. The input is not binary but\nyou can set the amount of slew here -- individually for each step.\n{\\t 0.0} switches the slew off, higher values create slower slews.\n"}, {"count": 8, "start_at": 1, "name": "repeat1 ... repeat8", "default": "1", "prefix": "repeat", "type": "cv", "description": "Set this to a positive integer number like {\\t 1}, {\\t 2}, and so on.\nIt sets the number of times this stage should be repeated until the\nnext stage will be approached.\nIt is currently not allowed to have {\\t 0} repeats -- although this would\nmake sense in a future version.\n"}, {"default": "unpatched", "type": "gate", "name": "chaintonext", "description": "If you set this input to {\\t 1}, the next sequencer circuit's {\\t pitch}\nand other step inputs will be added to this sequencer. See the general circuit\nnotes for details.\n"}], "description": "This circuit implements a sequencer that is a bit similar to the widely known\nMetropolis sequencer by Intellijel. It lacks a couple of its features --\nbut most of these can be patched externally by use of other circuits. On\nthe other hand it is not limited to 8 stages since you can chain multiple\ninstance of this sequencer together to form one large sequencer very easily.\n\nSince {\\it everything} in the \\droid is controllable via CV, of course pitch\nand gate signals are included, which makes the circuit much more versatile\nthan it may seem at a first look.\n\nHere is a small example of a CV sequencer that is playing four voltages in\na turn (it needs a clock into {\\t I1}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = I1}    clock       = I1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    pitch1      = 1V}    pitch1      = 1V\n\\immediate\\write\\patchexamples{    pitch2      = 3.5V}    pitch2      = 3.5V\n\\immediate\\write\\patchexamples{    pitch3      = 8V}    pitch3      = 8V\n\\immediate\\write\\patchexamples{    pitch4      = @2V}    pitch4      = -2V\n\\end{droidini}\n\nIf you set the {\\t outputscale} parameter to $\\frac{1}{12}$~V\n(which is the same as the number $\\frac{1}{120}$, you\ncan specify pitches directly in {\\it semitones}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = I1}    clock       = I1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    outputscale = 1/120}    outputscale = 1/120\n\\immediate\\write\\patchexamples{    pitch1      = 0}    pitch1      = 0\n\\immediate\\write\\patchexamples{    pitch2      = 12}    pitch2      = 12\n\\immediate\\write\\patchexamples{    pitch3      = 10}    pitch3      = 10\n\\immediate\\write\\patchexamples{    pitch4      = 7}    pitch4      = 7\n\\immediate\\write\\patchexamples{    pitch5      = 5}    pitch5      = 5\n\\immediate\\write\\patchexamples{    pitch6      = 3}    pitch6      = 3\n\\immediate\\write\\patchexamples{    pitch7      = 5}    pitch7      = 5\n\\immediate\\write\\patchexamples{    pitch8      = 7}    pitch8      = 7\n\\end{droidini}\n\nThe following example uses four expander buttons for turning the\nsteps on or off and four pots, which are scaled down to a range of\n0V ... 3V.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led    = L1.2}    led    = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led    = L1.3}    led    = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led    = L1.4}    led    = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = _CLOCK}    clock       = _CLOCK\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput  = O2}    gateoutput  = O2\n\\immediate\\write\\patchexamples{    pitch1      = P1.1 * 3V}    pitch1      = P1.1 * 3V\n\\immediate\\write\\patchexamples{    pitch2      = P1.2 * 3V}    pitch2      = P1.2 * 3V\n\\immediate\\write\\patchexamples{    pitch3      = P2.1 * 3V}    pitch3      = P2.1 * 3V\n\\immediate\\write\\patchexamples{    pitch4      = P2.2 * 3V}    pitch4      = P2.2 * 3V\n\\immediate\\write\\patchexamples{    gate1       = L1.1}    gate1       = L1.1\n\\immediate\\write\\patchexamples{    gate2       = L1.2}    gate2       = L1.2\n\\immediate\\write\\patchexamples{    gate3       = L1.3}    gate3       = L1.3\n\\immediate\\write\\patchexamples{    gate4       = L1.4}    gate4       = L1.4\n\\end{droidini}\n\nNote: the pitch values you dial in with the pots are not quantized,\nso it's a bit hard to hit a musical pitch. Please have a look at the\ncircuits {\\t quantizer} (page \\pageref{quantizer}) and {\\t minifonion}\n(page \\pageref{minifonion}) for how to quantize pitch values.\n\n\\subsubsection*{Making longer sequences}\n\nThe {\\t sequencer} circuit is limited to 8 steps. But: you can easily\nchain a large number of these circuits together to form longer sequences.\nThis is super easy. Just set the jack {\\t chaintonext} to {\\t 1} and\nplace another {\\t sequencer} circuit with more steps after that. Here\nis an example for a 12 step sequencer:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = P1.1 * 30}    hz = P1.1 * 30\n\\immediate\\write\\patchexamples{    output = _CLOCK}    output = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = B1.1}    reset = B1.1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput = O2}    gateoutput = O2\n\\immediate\\write\\patchexamples{    outputscaling = 1/120}    outputscaling = 1/120\n\\immediate\\write\\patchexamples{    pitch1 = 1}    pitch1 = 1\n\\immediate\\write\\patchexamples{    pitch2 = 8}    pitch2 = 8\n\\immediate\\write\\patchexamples{    pitch3 = 13}    pitch3 = 13\n\\immediate\\write\\patchexamples{    pitch4 = 25}    pitch4 = 25\n\\immediate\\write\\patchexamples{    pitch5 = 4}    pitch5 = 4\n\\immediate\\write\\patchexamples{    pitch6 = 11}    pitch6 = 11\n\\immediate\\write\\patchexamples{    pitch7 = 7}    pitch7 = 7\n\\immediate\\write\\patchexamples{    pitch8 = 21}    pitch8 = 21\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 2}    pitch1 = 2\n\\immediate\\write\\patchexamples{    pitch2 = 9}    pitch2 = 9\n\\immediate\\write\\patchexamples{    pitch3 = 14}    pitch3 = 14\n\\immediate\\write\\patchexamples{    pitch4 = 26}    pitch4 = 26\n\\end{droidini}\n\nYou can make the chain longer by adding more {\\t sequencer}\ncircuits. All but the last must have {\\t chaintonext} set to\n{\\t 1}. Here comes a 19 step sequencer:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = P1.1 * 30}    hz = P1.1 * 30\n\\immediate\\write\\patchexamples{    output = _CLOCK}    output = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = B1.1}    reset = B1.1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput = O2}    gateoutput = O2\n\\immediate\\write\\patchexamples{    outputscaling = 1/120}    outputscaling = 1/120\n\\immediate\\write\\patchexamples{    pitch1 = 1}    pitch1 = 1\n\\immediate\\write\\patchexamples{    pitch2 = 8}    pitch2 = 8\n\\immediate\\write\\patchexamples{    pitch3 = 13}    pitch3 = 13\n\\immediate\\write\\patchexamples{    pitch4 = 25}    pitch4 = 25\n\\immediate\\write\\patchexamples{    pitch5 = 4}    pitch5 = 4\n\\immediate\\write\\patchexamples{    pitch6 = 11}    pitch6 = 11\n\\immediate\\write\\patchexamples{    pitch7 = 7}    pitch7 = 7\n\\immediate\\write\\patchexamples{    pitch8 = 21}    pitch8 = 21\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 2}    pitch1 = 2\n\\immediate\\write\\patchexamples{    pitch2 = 9}    pitch2 = 9\n\\immediate\\write\\patchexamples{    pitch3 = 14}    pitch3 = 14\n\\immediate\\write\\patchexamples{    pitch4 = 26}    pitch4 = 26\n\\immediate\\write\\patchexamples{    pitch5 = 2}    pitch5 = 2\n\\immediate\\write\\patchexamples{    pitch6 = 9}    pitch6 = 9\n\\immediate\\write\\patchexamples{    pitch7 = 14}    pitch7 = 14\n\\immediate\\write\\patchexamples{    pitch8 = 26}    pitch8 = 26\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 3}    pitch1 = 3\n\\immediate\\write\\patchexamples{    pitch2 = 10}    pitch2 = 10\n\\immediate\\write\\patchexamples{    pitch3 = 15}    pitch3 = 15\n\\end{droidini}\n\nNotes:\n\\begin{itemize}\n\\item Define all the input and output jacks like {\\t clock}, {\\t pitchoutput}\netc. just for the first sequencer. All subsequent ones just have {\\t pitch}, {\\t gate}, {\\t repeat}, {\\t slew} and {\\t cv} definitions.\n\\item The parameter {\\t chaintonext} is {\\it dynamic}. You could make or break\nthe chain with a toggle {\\t button} or something else if you like.\n\\end{itemize}\n\n\n\\pagebreak", "title": " Eight step sequencer", "outputs": [{"default": null, "type": "cv", "name": "pitchoutput", "description": "The pitch output. It is unquantized.\n"}, {"default": null, "type": "cv", "name": "cvoutput", "description": "The optional CV output, in case you use the {\\t cv1} ... {\\t cv8} inputs.\n"}, {"default": null, "type": "gate", "name": "gateoutput", "description": "The gate output.\n"}], "presets": 0}, "switchedpot": {"category": "ui", "inputs": [{"default": null, "type": "fraction", "name": "pot", "description": "The pot that you want to overlay, e.g. {\\t P1.1}\n"}, {"default": null, "type": "gate", "name": "bipolar", "description": "If this input is set to 1, the usual pot range of 0 ... 1 will be\nmapped to -1 ... +1, which converts this to a bipolar potentiometer.\nThis is done by multiplying the output with 2.0 and substracting\n1.0 afterwards.\n"}, {"count": 8, "start_at": 1, "name": "switch1 ... switch8", "default": null, "prefix": "switch", "type": "gate", "description": "These inputs select which of the virtual pots should be changed\nwhen the physical pot is being turned. These should be set to {\\t 0}\nor {\\t 1} (or {\\t off} and {\\t on}).\n"}], "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit {\\t pot}\n(see page \\pageref{pot}). {\\t pot} can do all {\\t switchedpot} can do and much\nmore. So {\\t switchedpot} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis circuit allows you to use one of your potentiometers on your controllers\nfor up to eight different functions. It is like creating up to eight {\\it\nvirtual} pots. With the inputs {\\t switch1} \\dots\\ {\\t switch8} you select,\nwhich of these virtual pots are currently active. When you turn the (physical)\npot, all active virtual pots are being changed.\n\nThe values of all virtual pots start at center position ({\\t 0.5}).\n\nThe current values of all virtual pots are saved in the \\droid's internal\nflash memory, so next time you power on you have all settings of the\nvirtual pots reserved.\n\nHere is an example, where one pot is used to control both decay and\nrelease of an envelope.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switchedpot]}[switchedpot]\n\\immediate\\write\\patchexamples{    pot       = P1.1}    pot       = P1.1\n\\immediate\\write\\patchexamples{    switch1   = B1.1}    switch1   = B1.1\n\\immediate\\write\\patchexamples{    switch2   = B1.2}    switch2   = B1.2\n\\immediate\\write\\patchexamples{    output1   = _DECAY}    output1   = _DECAY\n\\immediate\\write\\patchexamples{    output2   = _RELEASE}    output2   = _RELEASE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate      = I1}    gate      = I1\n\\immediate\\write\\patchexamples{    decay     = _DECAY}    decay     = _DECAY\n\\immediate\\write\\patchexamples{    release   = _RELEASE}    release   = _RELEASE\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\nNow -- while you press {\\it and hold} button {\\t B1.1} and turn the knob, the\ndecay parameter will change. Holding {\\t B1.2} will change release. Holding\n{\\it both} at the same time is also possible and will change decay and\nrelease at the same time.\n\nHints:\n\\begin{itemize}\n\\item If you do not like to hold the buttons then you might want to use the {\\t\nbutton} circuit for converting the buttons into toggle buttons.\n\\item If you want one button per function and want always one pot to\nbe selected, you can use the {\\t buttongroup} circuit for combining\nthe buttons into a group.\n\\end{itemize}\n\n\\subsubsection*{Picking up the pots}\n\nPots are no encoders. So when reusing a pot for more than one function at\na time there is always the problem that when you switch to one pot function\nthe pot probably currently is not set to the current value of the function.\nAs an example let's assume that -- using the upper example -- you first press\n{\\t B1.1} and set decay fully CW {\\t 1.0}. Now you select release. Because\n{\\t 0.5} is the start position of every virtual pot that is the current\nvalue of release. But the physical pot is at {\\t 1.0}.\n\n\\droid solves this in the following way:\n\n\\begin{itemize}\n\\item If you turn the physical pot {\\it right}, then the value of the virtual pot is always\nincreased until both pots reach {\\t 1.0} at the same time.\n\\item If the physical pot is already at {\\t 1.0} when you select a virtual pot, it cannot\nbe increased further. You first have to turn the pot left a bit and then right again.\n\\item If you turn the physical pot {\\it left}, then the value of the virtual pot is always\n{\\it decreased} until both pots reach {\\t 0.0} at the same time.\n\\item If the physical pot is already at {\\t 0.0} when you select a virtual pot, it cannot\nbe decreased further. You first have to turn the pot right a bit and then left again.\n\\end{itemize}\n\nLet's assume that the virtual pot is at {\\t 0.4} when you select it. And\nlet's further assume that the physical pot is at position {\\t 0.8}. When you\nturn it {\\it left} the physical pot as a way of {\\t 0.8} go until {\\t 0.0}\nand the virtual just {\\t 0.4}. So the virtual pot is moving with half of the\nspeed, so that both reach {\\t 0.0} at the same time. When you turn the pot\n{\\it right}, on the other hand, the virtual pot has {\\t 0.6} to go until\nmaximum while the physical pot has just {\\t 0.2} left until it reaches its\nmaximum. So now the virtual pot moves three times faster than the physical.\n\nThis algorithm is different than the common ``picking up'' up pots that\nyou see in Eurorack land quite a lot in such situations. We preferred\nour solution over that because it seems to be more convenient -- especially\nif you just want to change a value just a little bit. Also it allows to have\nmultiple virtual pots to be selected at the same time.\n\nBy the way: in the upper example it is possible to select {\\it none} of\nthe pots. That is a convenient way to reset the physical pot to the middle\nposition so that you always have headroom for movement left {\\it and} right,\nbefore selecting one of the virtual pots.\n\n\\clearpage", "title": " Overlay pot with multiple functions (OBSOLETE)", "outputs": [{"count": 8, "start_at": 1, "name": "output1 ... output8", "default": null, "prefix": "output", "type": "fraction", "description": "The output of the up to eight virtual pots.\n"}], "presets": 0}, "matrixmixer": {"category": "cv", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"count": 4, "start_at": 1, "name": "input1 ... input4", "default": "0", "prefix": "input", "type": "cv", "description": "The up to four CV inputs that you want to mix\n"}, {"count": 4, "start_at": 1, "name": "auxin1 ... auxin4", "default": null, "prefix": "auxin", "type": "cv", "description": "These auxiliary inputs will be mixed directly into the four\noutputs {\\t output1} \\dots\\ {\\t output4} and are used for\ncascading several matrix mixers into one with more than four\ninputs.\n"}, {"default": "0", "type": "fraction", "name": "mixmax", "description": "If this is {\\t 0.0}, normal mixing is done (the\nenabled inputs CVs will be added). At a value of {\\t 1.0}\ninstead each outputs is the maximum of the enabled inputs.\nAny number in between will create a weighted average between\nthese two values.\n"}, {"default": "unpatched", "type": "integer", "name": "startvalue", "description": "If you use this input, persisting the state on the SD card\nis disabled. Rather the matrix starts with a standard configuration\nof which buttons are active. This configuration is set by the\nvalue of {\\t startvalue}:\n\n{\\footnotesize\n\\begin{tabular}{|l|p{140mm}|} \\hline\n{\\t 0} & All buttons are cleared \\\\ \\hline\n{\\t 1} & The buttons on the diagonal are active, so {\\t input1} is\nsent to {\\t output1}, {\\t input2} to {\\t output2} and so on. \\\\ \\hline\n{\\t 2} & All buttons are set \\\\ \\hline\n\\end{tabular}}\n\nIf you don't use this jack, the matrix starts for the very first time\nwith the buttons of the diagonal being active and saves the status\nto the SD card from then on.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the matrix to its initial state, which can\nbe configured with {\\t startvalue}.\n"}, {"count": 4, "start_at": 1, "name": "button11 ... button14", "default": null, "prefix": "button1", "type": "gate", "description": "These four buttons decide, to which of the four outputs {\\t input1}\nis being mixed.\n"}, {"count": 4, "start_at": 1, "name": "button21 ... button24", "default": null, "prefix": "button2", "type": "gate", "description": "These four buttons decide, to which of the four outputs {\\t input2}\nis being mixed.\n"}, {"count": 4, "start_at": 1, "name": "button31 ... button34", "default": null, "prefix": "button3", "type": "gate", "description": "These four buttons decide, to which of the four outputs {\\t input3}\nis being mixed.\n"}, {"count": 4, "start_at": 1, "name": "button41 ... button44", "default": null, "prefix": "button4", "type": "gate", "description": "These four buttons decide, to which of the four outputs {\\t input4}\nis being mixed.\n"}], "description": "This circuit is a 4$\\times$4 matrix mixer with four inputs and four outputs\nthat is operated by push buttons. Each of the 16 matrix nodes has a toggle\nbutton for adding or removing one specific input to or from one specific\noutput. The mixing is always done with unity gain. This means that each\noutput is the sum of all inputs that are enabled on its path.\n\nThe following picture shows a matrix with the four inputs {\\t I1} \\dots\\ {\\t I4}\nand the four outputs {\\t O1} \\dots\\ {\\t O4}. As you can see\nthe button 23 mixes input 2 to output 3.\n\nIf you have not pushed any buttons yet, the mixer enables four buttons\nin a diagonal so that inputs {\\t I1} is connected to output {\\t O1}\nand so on:\n\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.8cm,\n                    semithick]\n  \\tikzstyle{every state}=[fill=lightgray,draw=none,text=white]\n  \\tikzstyle{on}=[fill=black,draw=black,text=white]\n  \\tikzstyle{jacks}=[fill=white,draw=black,text=black]\n\n  \\node[state,jacks] (I1)       {\\t I1};\n  \\node[state,on] (B11) [right of=I1]  {11};\n  \\node[state] (B12) [right of=B11] {12};\n  \\node[state] (B13) [right of=B12] {13};\n  \\node[state] (B14) [right of=B13] {14};\n\n  \\node[state,jacks] (I2) [below of=I1]  {\\t I2};\n  \\node[state] (B21) [right of=I2]  {21};\n  \\node[state,on] (B22) [right of=B21] {22};\n  \\node[state] (B23) [right of=B22] {23};\n  \\node[state] (B24) [right of=B23] {24};\n\n  \\node[state,jacks] (I3) [below of=I2]  {\\t I3};\n  \\node[state] (B31) [right of=I3]  {31};\n  \\node[state] (B32) [right of=B31] {32};\n  \\node[state,on] (B33) [right of=B32] {33};\n  \\node[state] (B34) [right of=B33] {34};\n\n  \\node[state,jacks] (I4) [below of=I3]  {\\t I4};\n  \\node[state] (B41) [right of=I4]  {41};\n  \\node[state] (B42) [right of=B41] {42};\n  \\node[state] (B43) [right of=B42] {43};\n  \\node[state,on] (B44) [right of=B43] {44};\n\n  \\node[state,jacks] (O1) [below of=B41] {\\t O1};\n  \\node[state,jacks] (O2) [below of=B42] {\\t O2};\n  \\node[state,jacks] (O3) [below of=B43] {\\t O3};\n  \\node[state,jacks] (O4) [below of=B44] {\\t O4};\n\n  \\path\n        (I1)  edge node {} (B11)\n        (B11) edge node {} (B12)\n        (B12) edge node {} (B13)\n        (B13) edge node {} (B14)\n\n        (B11) edge node {} (B21)\n        (B12) edge node {} (B22)\n        (B13) edge node {} (B23)\n        (B14) edge node {} (B24)\n\n        (I2)  edge node {} (B21)\n        (B21) edge node {} (B22)\n        (B22) edge node {} (B23)\n        (B23) edge node {} (B24)\n\n        (B21) edge node {} (B31)\n        (B22) edge node {} (B32)\n        (B23) edge node {} (B33)\n        (B24) edge node {} (B34)\n\n        (I3)  edge node {} (B31)\n        (B31) edge node {} (B32)\n        (B32) edge node {} (B33)\n        (B33) edge node {} (B34)\n\n        (B31) edge node {} (B41)\n        (B32) edge node {} (B42)\n        (B33) edge node {} (B43)\n        (B34) edge node {} (B44)\n\n        (I4)  edge node {} (B41)\n        (B41) edge node {} (B42)\n        (B42) edge node {} (B43)\n        (B43) edge node {} (B44)\n\n        (B41) edge node {} (O1)\n        (B42) edge node {} (O2)\n        (B43) edge node {} (O3)\n        (B44) edge node {} (O4)\n\n\n        ;\n\\end{tikzpicture}\n\nAs an alternative operation, instead of summing the enabled signals you\ncan compute the {\\it maximum} signal. This is useful when combining\nenvelope signals -- e.g. from different rhythmic patterns.\nAdding envelope signals would either make them ``too loud'' or even\ndistort them.\n\nThe current state of the sixteen buttons is saved in the \\droid's\ninternal flash memory.\n\nOf course it is possible to use a less part of the matrix, e.g.  just\n3$\\times$2, simply by not patching the according inputs, outputs and buttons.\nHere is an example of a 3$\\times$2 mixer:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[matrixmixer]}[matrixmixer]\n\\immediate\\write\\patchexamples{    input1   = I1}    input1   = I1\n\\immediate\\write\\patchexamples{    input2   = I2}    input2   = I2\n\\immediate\\write\\patchexamples{    input3   = I3}    input3   = I3\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    button11 = B1.1}    button11 = B1.1\n\\immediate\\write\\patchexamples{    button12 = B1.2}    button12 = B1.2\n\\immediate\\write\\patchexamples{    button21 = B2.1}    button21 = B2.1\n\\immediate\\write\\patchexamples{    button22 = B1.3}    button22 = B1.3\n\\immediate\\write\\patchexamples{    button31 = B1.4}    button31 = B1.4\n\\immediate\\write\\patchexamples{    button32 = B2.3}    button32 = B2.3\n\\immediate\\write\\patchexamples{    led11    = L1.1}    led11    = L1.1\n\\immediate\\write\\patchexamples{    led12    = L1.2}    led12    = L1.2\n\\immediate\\write\\patchexamples{    led21    = L2.1}    led21    = L2.1\n\\immediate\\write\\patchexamples{    led22    = L1.3}    led22    = L1.3\n\\immediate\\write\\patchexamples{    led31    = L1.4}    led31    = L1.4\n\\immediate\\write\\patchexamples{    led32    = L2.3}    led32    = L2.3\n\\end{droidini}\n\nThis matrix looks like this:\n\n\\begin{center}\n\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.8cm,\n                    semithick]\n  \\tikzstyle{every state}=[fill=lightgray,draw=none,text=white]\n  \\tikzstyle{on}=[fill=black,draw=black,text=white]\n  \\tikzstyle{jacks}=[fill=white,draw=black,text=black]\n\n  \\node[state,jacks] (I1)       {\\t I1};\n  \\node[state,on] (B11) [right of=I1]  {11};\n  \\node[state] (B12) [right of=B11] {12};\n\n  \\node[state,jacks] (I2) [below of=I1]  {\\t I2};\n  \\node[state] (B21) [right of=I2]  {21};\n  \\node[state,on] (B22) [right of=B21] {22};\n\n  \\node[state,jacks] (I3) [below of=I2]  {\\t I3};\n  \\node[state] (B31) [right of=I3]  {31};\n  \\node[state] (B32) [right of=B31] {32};\n\n  \\node[state,jacks] (O1) [below of=B31] {\\t O1};\n  \\node[state,jacks] (O2) [below of=B32] {\\t O2};\n\n  \\path\n        (I1)  edge node {} (B11)\n        (B11) edge node {} (B12)\n\n        (B11) edge node {} (B21)\n        (B12) edge node {} (B22)\n\n        (I2)  edge node {} (B21)\n        (B21) edge node {} (B22)\n\n        (B21) edge node {} (B31)\n        (B22) edge node {} (B32)\n\n        (I3)  edge node {} (B31)\n        (B31) edge node {} (B32)\n\n        (B31)  edge node {} (O1)\n        (B32) edge node {} (O2)\n        ;\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection*{Mixers with more inputs / outputs}\n\nThe four auxiliary inputs {\\t auxin1} \\dots\\ {\\t auxin4} can be\nused to create matrix mixers with more than four inputs. You\ncan create a mixer with 8 inputs and 4 outputs by sending the\nfour outputs of one matrix mixer into the four auxiliary inputs\nof a second one.\n\nIf you want to create a mixer with more than 4 {\\it outputs} then\nsimply use several mixers and feed the same inputs to all of them.", "title": " Matrix mixer for CVs", "outputs": [{"count": 4, "start_at": 1, "name": "output1 ... output4", "default": null, "prefix": "output", "type": "cv", "description": "The four outputs\n"}, {"count": 4, "start_at": 1, "name": "led11 ... led14", "default": null, "prefix": "led1", "type": "fraction", "description": "The LEDs in the buttons {\\t button11} \\dots {\\t button14}\n"}, {"count": 4, "start_at": 1, "name": "led21 ... led24", "default": null, "prefix": "led2", "type": "fraction", "description": "The LEDs in the buttons {\\t button21} \\dots {\\t button24}\n"}, {"count": 4, "start_at": 1, "name": "led31 ... led34", "default": null, "prefix": "led3", "type": "fraction", "description": "The LEDs in the buttons {\\t button31} \\dots {\\t button34}\n"}, {"count": 4, "start_at": 1, "name": "led41 ... led44", "default": null, "prefix": "led4", "type": "fraction", "description": "The LEDs in the buttons {\\t button41} \\dots {\\t button44}\n"}], "presets": 0}, "contour": {"category": "modulation", "inputs": [{"default": "unpatched", "type": "gate", "name": "gate", "description": "Patch a gate signal here that triggers the envelope. Gate means\nthat the length of the signal is relevant. While the gate is high\nthe sustain phase holds on. As soon as gate is going low the release\nphase is being entered.\n"}, {"default": null, "type": "trigger", "name": "trigger", "description": "This is an alternative method of starting the envelope.\nIf you use {\\t trigger} instead of {\\t gate} then there are the\nfollowing differences:\n\n\\begin{itemize}\n\\item The duration of the trigger signal is being ignored.\n\\item There is no decay / sustain phase. Attack and hold are\nimmediately followed by release. The inputs {\\t sustain} and\n{\\t decay} have no impact anymore.\n\\item The predelay and attack phases are continued until their\nend even when the trigger signal ends (When using {\\t gate}\nand the gate signal ends during predelay, the envelope does\nnot start. When it ends during attack, decay / sustain are\nbeing skipped and release starts at the current level of the envelope.\nThat way short gates can result in ``quieter`' envelopes).\n\\end{itemize}\n"}, {"default": "1", "type": "gate", "name": "retrigger", "description": "If you patch {\\t 0} or {\\t off} here, a gate or trigger impulse\nwill {\\bf not} immediately restart the envelope unless it already has\nreached its release phase.  The default {\\t on},\nwhich means that a trigger will immediately restart the envelope in any\ncase.\n"}, {"default": "0", "type": "gate", "name": "startfromzero", "description": "If you set this to {\\t 1} or {\\t on}, a trigger or gate will\nreset the envelope's current level immediately to zero. This is sometimes\ncalled ``digital mode''. In the normal analog mode the envelope\nresumes from where it is. This means that when a trigger occurs right\nin the release phase where the level is still high, will start\nit's attack not from zero but from this hight value.\n"}, {"default": "0", "type": "gate", "name": "abortattack", "description": "This is an {\\t on} / {\\t off} setting that decides what happens\nif the input gate goes {\\t off} while the predelay or attack phase\nis still not finished. Per default that phase will be finalized\nregardless of the gate state.  If {\\t abortattack} is {\\t on} then the\nend of the gate will immediately stop the attack phase and move on\nto hold. Note: The value of the envelope will not reach the maximum\nlevel in that case. If the gate ends during the predelay phase, no\nenvelope will be started at all.\n\nNote: This setting is only functional when the {\\t gate} input\nis being used for triggering the envelope. If you use {\\t trigger}, then\nthe attack phase is always completely executed and this setting\nhas no influence.\n"}, {"default": "0", "type": "gate", "name": "loop", "description": "This is an {\\t on} / {\\t off} input that switches loop on or off. When\nloop is {\\t on}, the envelope will immediately start again once it\nhas finished. It also starts without triggering. This converts\ncontour into a kind of fancy LFO.\n\n{\\t gate} / {\\t trigger} and {\\t loop} can be combined. Any gate or\ntrigger will restart the envelope just as usual -- even in loop mode.\n"}, {"default": "0", "type": "cv", "name": "predelay", "description": "The predelay phase inserts a delay between the incoming gate\nand the begin of the envelope. The length of the predelay is\n0.1 seconds per volt, so a value of {\\t 1.0} means 1 second\n"}, {"default": "0", "type": "cv", "name": "attack", "description": "Length of the attack phase, i.e. the time from the beginning of\nthe gate until the maximum {\\t level} is reached. See the general\ndescription for information about the scaling of this input.\n"}, {"default": "0", "type": "cv", "name": "hold", "description": "If this is none-zero then the envelopes lingers a certain amount\nof time at its maximum level after the attack and before the decay\nphase. A value of {\\t 0.5} (this is 5~V) will create a hold time of\n5 seconds.\n"}, {"default": "0.2", "type": "cv", "name": "decay", "description": "Time of the decay phase\n"}, {"default": "0.5", "type": "fraction", "name": "sustain", "description": "Sustain level\n"}, {"default": "0", "type": "fraction", "name": "swell", "description": "If this jack is set to a value greater than {\\t 0.0},\nthen the level of the envelope will go\nup or down again during the sustain phase until it reaches\n{\\t swelllevel}.\n"}, {"default": "5", "type": "cv", "name": "swelltime", "description": "Time of the swell phase\n"}, {"default": "1", "type": "cv", "name": "swelllevel", "description": "Level the swell phase is approaching. Setting this to the\nsame as {\\t sustain} effectively disables swell.\n"}, {"default": "0.2", "type": "cv", "name": "release", "description": "Timing of the release phase\n"}, {"default": "1", "type": "cv", "name": "level", "description": "Maximum level and scaling of the envelope. It is basically an\noutput attenuator of the envelope. Sudden changes in the level will\nimmediately have an (audible) impact on the envelope.\n"}, {"default": "1", "type": "cv", "name": "velocity", "description": "{\\it energy} of the attack: The velocity is similar to the {level},\nbut is effective just during the attack phase. During that phase that\nmaximum voltage that is read from the {velocity} jack and will be used\nas the velocity of the envelope. Further changes during the other phases\nwill be ignored. This makes it ideal of using with a sequencer. For example\nyou can patch an {\\it accent} output here and add some offset.\nSudden changes in this input will not affect the shape of the envelope.\n"}, {"default": "0", "type": "voltperoctave", "name": "pitch", "description": "This is a {\\it one volt per octave} input affecting all timings of\nthe envelope. When you set this to {\\t 0} (the default), it is neutral.\nA value of {0.1} (1 Volt) will exactly double the speed of all phases -\njust as one octave up doubles the frequency of an oscillator. This jack\ncan be used to easily implement envelopes where the length very naturally\nfollows this pitch - just like on a piano, glockenspiel or marimba lower\nnotes last longer than higher ones.\n"}, {"default": null, "type": "trigger", "name": "taptempo", "description": "Tap tempo is an alternative method of specifying a pitch information.\nWhen you patch a clock to tap tempo, all time parameters in\nthe envelope are relative to that clock. If the clock speeds up,\nthe envelope gets faster and vice versa. The reference speed is 120 BPM.\nThis means that if you patch a 120 BPM clock here then nothing changes.\nClocks faster than 120 BPM will speed up the envelope. Clocks slower\nthan 120 BPM will slow it down.\n"}, {"default": "0.5", "type": "bipolar", "name": "shape", "description": "If you use this jack then it sets the shape for all of the\nrelevant phases, which are attack, decay, swell and release. Note:\nthis input is only effective for those phases where the dedicated\ninput (like {\\t attackshape}, etc.) is {\\it not} being used.\n"}, {"default": "unpatched", "type": "cv", "name": "attackshape", "description": "Shape of the attack curve. If nothing is patched here, the value\nof {\\t shape} will be used.\nSee the general description for how curve shapes work.\n"}, {"default": "unpatched", "type": "bipolar", "name": "decayshape", "description": "Shape of the curve in the decay phase. If nothing is patched here,\nthe value of {\\t shape} will be used.\n"}, {"default": "unpatched", "type": "bipolar", "name": "swellshape", "description": "Shape of curve during the swell phase. If nothing is patched here,\nthe value of {\\t shape} will be used.\n"}, {"default": "unpatched", "type": "bipolar", "name": "releaseshape", "description": "Shape of the curing in the release phase. If nothing is patched\nhere, the value of {\\t shape} will be used.\n"}, {"default": "unpatched", "type": "cv", "name": "zerocrossing", "description": "This is an experimental feature: If you patch the output of an\noscillator here, an incoming gate or trigger signal will be\ndelayed until the next zero crossing of that signal. That allows\nyou to start the envelope exactly when the audio signal is at 0\nand avoid nasty klicks, even if the attack is set to 0. It comes\nat a price, however. The delay between the trigger and the first\nzero crossing might vary a lot from note to note and that could\nmake your rhythm untight, especially if the frequency of the oscillator\nis low.\n"}], "description": "This circuit implements an enhanced version of the classic ADSR-envelope\ngenerator. It has six phases: predelay, attack, hold, decay, sustain and\nrelease. For triggering there are two alternative inputs: {\\t gate} and {\\t\ntrigger}. Use {\\t trigger} if you are not interested in the length of the\ngate signal. There will be no decay / sustain phase in that case.\n\nThe minimal patch just connects {\\t gate} or {\\t trigger} and the output. It\ncreates an envelope with standard timings, triggered at {\\t I1} and\noutput to {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate   = I1}    gate   = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nAssigning pots to the classic four inputs lets you use\nthe \\droid just as a normal ADSR envelope:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate    = I1}    gate    = I1\n\\immediate\\write\\patchexamples{    attack  = P1.1}    attack  = P1.1\n\\immediate\\write\\patchexamples{    decay   = P1.2}    decay   = P1.2\n\\immediate\\write\\patchexamples{    sustain = P2.1}    sustain = P2.1\n\\immediate\\write\\patchexamples{    release = P2.2}    release = P2.2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nWhen you try this out, you will notice that the time range of the {\\t attack}\nparameter is much shorter than that of {\\t decay} and {\\t release}. If fact\nit is just $\\frac1{20}$ of these. This has been chosen in this way because I\nbelieve that this makes sense from a musical point of view. Very long attack\ntimes are quite unusual and I wanted to be able to directly map the four\nvalues to pots. But if you don't like that you can -- of course -- make all\nthree timing parameters have the same range simply by multiplying attack by 20:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate    = I1}    gate    = I1\n\\immediate\\write\\patchexamples{    attack  = P1.1 * 20}    attack  = P1.1 * 20\n\\immediate\\write\\patchexamples{    decay   = P1.2}    decay   = P1.2\n\\immediate\\write\\patchexamples{    sustain = P2.1}    sustain = P2.1\n\\immediate\\write\\patchexamples{    release = P2.2}    release = P2.2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nIf you do not change the {\\t shape} parameter, the duration of\nthe attack phase is 0.1~sec at a value of 1. The phases\ndecay and release have a duration of 2.0~sec at a value of 1.\n\n\\subsubsection*{The Phases}\n\nIn addition to the traditional ADSR phases this circuit also has a an\noptional predelay ({\\bf P}) phase -- which acts like a delay before the\nenvelope starts -- and an optional hold ({\\bf H}) phase which keeps the envelope at\nmaximum level for a short time right after attack and before decay.\n\nThe following diagram shows an example envelope with all six phases. The gate\nstarts at 0 ms and ends at 200 ms.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [color=cyan]    coordinates { (0,0) (10,0) };\n\\addplot [color=red]     coordinates { (10,0) (25,10) };\n\\addplot [color=blue]    coordinates { (25,10) (40,10) };\n\\addplot [color=orange]  coordinates { (40,10) (60,5) };\n\\addplot [color=green]   coordinates { (60,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{P,A,H,D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{Attack, Decay and Release}\n\nThe phases attack, decay, release are phases where the level of the envelope\nstarts at one level and then approaches another level within a certain time.\nIn the upper example all these phases had a {\\it linear} characteristic.\nThat means that the output voltage changes by a constant amount per time.\n\n\\droid's {\\t contour} allows you to control the shape of these phases in\norder to get them {\\it bent} in either direction. For that purpose there\nare the inputs {\\t attackshape}, {\\t decayshape} and {\\t releaseshape}.\n\nLet's take decay as an example. During the decay phase the envelopes voltage\nfalls from the maximum level of 10 V (you can change this with the input {\\t\nlevel}) to the sustain level defined by the input {\\t sustain}. For simplicity\nlet's assume that you have not used these inputs, so the maximum level is\n10~V ({\\t 1.0}) and the sustain level is 5~V ({\\t 0.5}). Also we assume\nattack, predelay and hold to be {\\t 0.0}.\n\nWhen {\\t decayshape} is not patched or otherwise set to its default of {\\t 0.5}\nthen the shape of the decay curve is {\\it linear}. This means that it\ngoes down by the same voltage each second until it reaches {\\t 0.5}.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [color=orange]  coordinates { (0,10) (60,5) };\n\\addplot [color=green]   coordinates { (60,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\nNow, if you set {\\t decayshape} to {\\t 0.0} then curve\nis completely {\\it exponential}:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [domain=0:100,color=orange,samples=100] {5 + 5 * 0.95^x};\n\\addplot [color=green]   coordinates { (100,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\nSuch an envelope sounds completely different -- of course also depending on\nwhether you feed this into a linear VCA, exponential VCA or a VCF.\nFor fine control you can use any number between {\\t 0.0} and {\\t 0.5} of\ncourse. In that case you will get a curve that is bent to a certain degree.\nAssigning {\\t decayshape} to a pot helps you {\\it listening} to the different\nsounds:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate        = I1}    gate        = I1\n\\immediate\\write\\patchexamples{    decayshape  = P1.1}    decayshape  = P1.1\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nIf the shape gets a value greater than {\\t 0.5} then the curve\nis bent into the opposite direction (some call this {\\it logarithmic}\nbut mathematically this is not true). Here is an example where {\\t decayshape}\nis set to {\\t 1.0}:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [domain=0:100,color=orange,samples=100] {10 - (5 * 0.95^(100-x))};\n\\addplot [color=green]   coordinates { (100,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\n\n% \\newpage", "title": " Contour generator", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Main output of the envelope. Patch this to your filter, VCA or\nwherever you like.\n"}, {"default": null, "type": "cv", "name": "negated", "description": "The negated output is the same as the output but in negative\nvoltage.\n"}, {"default": null, "type": "cv", "name": "inverted", "description": "The inverted output always outputs {\\it positive} voltages but\nis inverted relative to the level of the envelope. When the normal\n{output} outputs 0 V, then the inverted output outputs {level} and\nvice versa\n"}, {"default": null, "type": "trigger", "name": "endofpredelay", "description": "This output will emit a trigger with a length of 10 ms when the\npredelay phase has ended.\n"}, {"default": null, "type": "trigger", "name": "endofattack", "description": "This output will emit a trigger with a length of 10 ms when the\nattack phase has ended.\n"}, {"default": null, "type": "trigger", "name": "endofhold", "description": "This output will emit a trigger with a length of 10 ms when the\nhold phase has ended.\n"}, {"default": null, "type": "trigger", "name": "endofdecay", "description": "This output will emit a trigger with a length of 10 ms when the\ndecay phase has ended.\n"}, {"default": null, "type": "trigger", "name": "endofrelease", "description": "This output will emit a trigger with a length of 10 ms when the\nrelease phase has ended.\n"}], "presets": 0}, "quantizer": {"category": "cv", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Patch the unquantized input voltage here\n"}, {"default": null, "type": "trigger", "name": "trigger", "description": "This jack is optional. If you patch it, the quantizer will\nwork in triggered mode. Here the output pitch is always frozen until the\nnext trigger happens.\n"}, {"default": "12", "type": "integer", "name": "steps", "description": "Number of steps that one Volt should be divided in. The default\nis {\\t 12} and will quantize the input voltage to semitones.\nThe number of steps is related to a value of 1 V which means {\\t 0.1}.\nIt {\\it is} allowed to use a fractional number here. E.g. the value\n{\\t 1.2} will quantize to 12 steps per 10 V (which means 12 steps\nper {\\t 1.0}, which can make sense. A value of {\\t 0.0} (or lower)\nwill basically mean an {\\it infinite} number of steps and thus\npractically disable quantization.\n"}, {"default": "0", "type": "gate", "name": "bypass", "description": "If you set this gate input to {\\t 1} then quantization is bypassed\nand the input voltage is directly copied to the output.\n"}], "description": "This quantizer circuit is very simple. It reads an input voltage,\nquantizes it to the next discrete step that you configured and\noutputs it.\n\nYou {\\it can} use it for musical purposes by setting the number of steps\nto 12 per Volt (which is default). It will quantize the\ninput to semitones.\n\nThe following example scales down a pot {\\t P1.1} to 1~V\n(i.e. one octave) and then quantizes it to semitones. Since {\\t 12}\nis the default value for {\\t steps} this parameter can be\nomitted here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input  = P1.1 * 1V}    input  = P1.1 * 1V\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNote$^1$: In fact you can select {\\it 13} semitones here because\nif you turn the pot fully CW it will output 1, which will be scaled\nto 1 V and then quantized to 1 V -- which is the \\nth{13} semitone\nabove the lowest possible note.\n\nNote$^2$: if you are looking for a more musical quantizer then have a\nlook at the Minifonion circuit.\n\nYou can use the Quantizer circuit as a sample \\& hold circuit if you\nset {\\t steps} to {\\t 0} and use the trigger input:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    steps   = 0}    steps   = 0\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}", "title": " Non-musical quantizer", "outputs": [{"default": null, "type": "stepped", "name": "output", "description": "Here comes your quantized output voltage\n"}], "presets": 0}, "nudge": {"category": "ui", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": null, "type": "trigger", "name": "buttonup", "description": "Button for nudging the value up by one step\n"}, {"default": null, "type": "trigger", "name": "buttondown", "description": "Button for nudging the value down by one step\n"}, {"default": "0.1", "type": "cv", "name": "amount", "description": "Amount to modify the value by on each press. This must be a value $> 0$\n"}, {"default": "0", "type": "cv", "name": "startvalue", "description": "The value this circuit starts with or is being reset to if you use\nthe {\\t reset} input.\n"}, {"default": "unpatched", "type": "cv", "name": "minimum", "description": "The minimum possible value. If you do not wire this, the value can go down infinitely.\n"}, {"default": "unpatched", "type": "cv", "name": "maximum", "description": "the maximum possible value. If you do not wire this, the value can go up infinitely.\n"}, {"default": "0", "type": "gate", "name": "wrap", "description": "Set this to {\\t 1} in order to have the value wrap around\nif the minimum or the maximum has been exceeded. Note: {\\t wrap}\ndoes only work if you set {\\t minimum} and {\\t maximum}.\n"}, {"default": "0", "type": "cv", "name": "offset", "description": "This value is being added to the output.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here will reset the value to its start value\n"}, {"default": "1", "type": "gate", "name": "persist", "description": "Set this to {\\t 0} if you do not like the current value to be saved and reloaded from flash after\na restart of your modular system. The default is {\\t 1}, which means that the current\nvalue will automatically saved.\n"}], "description": "This small utility allows you to modify a value up and down\nin fixed steps using two buttons. This value can be persistent\nso it survives a power cycle.\n\nHere is an example for a simple CV source that outputs\na value between -2~V and 2~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    minimum    = @2V}    minimum    = -2V\n\\immediate\\write\\patchexamples{    maximum    = 2V}    maximum    = 2V\n\\immediate\\write\\patchexamples{    amount     = 1V}    amount     = 1V\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\end{droidini}\n\n{\\bf Note}: If you press both buttons at the same time, the value will be reset to\nits start value.\n\nYou can extend this into an octave switch by using the input\n{\\t offset}, which will be added to the output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    minimum    = @2V}    minimum    = -2V\n\\immediate\\write\\patchexamples{    maximum    = 2V}    maximum    = 2V\n\\immediate\\write\\patchexamples{    amount     = 1V}    amount     = 1V\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\immediate\\write\\patchexamples{    offset     = I1}    offset     = I1\n\\end{droidini}\n\nIf you now feed some V/Oct source, such as the pitch output of a\nsequencer, to {\\t I1}, it will be shifted up and down for up to two octaves.\n\nAnother application might be to fine tune an oscillator. Here you\nset the nudge steps (set by {\\t amount}) a lot smaller. Also it is\nallowed to leave out {\\t minimum} and {\\t maximum} and thus make the possible\nrange unrestricted. Note: {\\t 1V / 1200} means essentially a step size of\n$\\frac{1}{1200}$ of an octave, which is $\\frac{1}{100}$ of a semitone, which is\nalso known as {\\it one cent}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    amount     = 1V / 1200}    amount     = 1V / 1200\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\immediate\\write\\patchexamples{    offset     = I1}    offset     = I1\n\\end{droidini}\n\n\nA third application could be a button for selecting a certain input\nnumber for -- let's say -- an euclidean rhythm pattern:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    amount = 1}    amount = 1\n\\immediate\\write\\patchexamples{    buttonup = B1.1}    buttonup = B1.1\n\\immediate\\write\\patchexamples{    ledup = L1.1}    ledup = L1.1\n\\immediate\\write\\patchexamples{    minimum = 3}    minimum = 3\n\\immediate\\write\\patchexamples{    maximum = 7}    maximum = 7\n\\immediate\\write\\patchexamples{    wrap = 1}    wrap = 1\n\\immediate\\write\\patchexamples{    output = _BEATS}    output = _BEATS\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = _BEATS}    beats   = _BEATS\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nNote: Here just one button is wired. In addition {\\t wrap} is set to {\\t\n1}, which means that after reaching the maximum value, the next value will\nbe the minimum value.  Here each press of the button {\\t B1.1} forwards the\nnumber of beats in the matter 3 $\\rightarrow$ 4 $\\rightarrow$ 5 $\\rightarrow$\n6 $\\rightarrow$ 7 $\\rightarrow$ 3 and so on...\n\n\\subsubsection*{Understanding the LEDs}\n\nBy nudging the value below the center value the buttonup LED will be off and\nthe brightness of the buttondown LED will gradually increase indicating how\nmuch the value is set below this center value. It remains maximally bright\nat the minimum.\n\nVice versa by nudging the value above the center value the buttondown LED\nwill be off and the brightness of the buttonup LED will gradually increase\nindicating how much the value is set above this center value. It remains\nmaximally bright at the maximum.\n\nAnd if the value is exactly in the middle between {\\t maximum} and {\\t\nminimum}, both LEDs are maximally bright. Here you have to have in\nmind that this must be {\\t exactly} in the middle. This only works if\nthe distance between {\\t maximum} and {\\t minimum} is an exact odd\nnumber of {\\t amount}s, of course.\n\n\n\\clearpage", "title": " Modify -- ``nudge'' -- a value using two buttons", "outputs": [{"default": null, "type": "stepped", "name": "ledup", "description": "Wire this to the LED in the button for nuding up. It will indicate the current value.\n"}, {"default": null, "type": "stepped", "name": "leddown", "description": "Wire this to the LED in the button for nuding down. It will indicate the current value.\n"}, {"default": null, "type": "cv", "name": "output", "description": "The output of the current value plus value if {\\t offset}.\n"}], "presets": 0}, "superjust": {"category": "pitch", "inputs": [{"count": 8, "start_at": 1, "name": "input1 ... input8", "default": "unpatched", "prefix": "input", "type": "voltperoctave", "description": "\\nth1 ... \\nth8 pitch input\n"}, {"default": "0", "type": "gate", "name": "tuningmode", "description": "While this is {\\t 1}, all outputs output the value set\nby {\\t tuningpitch}. This is for tuning all outputs. Since\nperfect tuning is crucial for perfect intonation, this is\nquite useful.\n"}, {"default": "0", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "gate", "name": "bypass", "description": "While this is {\\t 1}, all inputs are passed through\nto the outputs without changes.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "This value is being added to all outputs, but not\nin tuning or bypass mode. It can e.g. be used for\nmaking a vibrato on a chord.\n"}], "description": "\\subsubsection*{Introduction}\n\nThis circuit automatically creates a perfect pure intonation for up to eight\ninput pitches. This means that all pitches are in just intervals, which\ncorrespond to small whole number ratios such as $\\frac{3}{2}$ or $\\frac{5}{4}$.\nAssuming that you have perfectly tuned and calibrated VCOs, If these pitches\nare used to play a chord, there will be no or just minimal\naudible beatings and the chord will sound very pure.\n\nIn normal tempered intonation all intervals are a multiple of $\\sqrt[12]{2}$\nand thus there is no just interval at all, with the exception of the octave.\nSo all chords will sound impure.\n\nThe problem about pure or just intonation is, that you need to decide for\njust one scale, e.g. C major, and then tune all 12 notes in a way that\nchords from that scale sound good. But as soon as you change the scale,\nthe intervals will sound ugly.\n\nWhat makes the {\\t superjust} unique is that fact, that it automatically\ncreates a pure intonation in a {\\it dynamic} way. At every time it ``listens''\nto the notes that are {\\it currently} being played and creates a perfect\nintonation just for those, not for a scale or so. As soon as at least one\nnote changes, all notes are retuned in order to find a new perfect tuning.\nThis is a bit like a well-trained string ensemble or choir, where each\nmusician listens and adjusts his or her pitch in relation to all others.\n\n\\subsubsection*{Usage}\n\nThe nice thing is: you don't need any configuration. You need not specify\nany information about the root note, the scale or anything else. Neither\nneed the inputs be quantized so some scale or tuned to 440~Hz. The circuit\nwill simply analyse all input pitches, apply its algorithm (patent pending)\nand then just slightly raises or lowers each note so that at the end each\npair of frequencies have a rational oscillation ratio with small numerator\nand denominator. This is done in a way that the average pitch does not change.\nJust pipe your pitches through that circuit and you are done. And if you\nwant to use a quantizer, use {\\t superjust} {\\it after} quantization.\n\nHere an example for three voices:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\end{droidini}\n\n\\subsubsection*{Tuning}\n\nOf course, an exact tuning of your VCOs is crucial, since the pitch\ndifferences between a normal tempered intonation and a perfect intonation\nare quite small. The circuit helps you in the process of tuning with the\ninputs {\\t tuningmode}, which you can map to a toggle button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\end{droidini}\n\nNow when the button {\\t B1.1} is active, all outputs will output\nzero volts. Tuning with 0~V is not optimal in some cases.\nYou should tune your VCOs always roughly in the average pitch\nyou play them.  So you can set the tuning voltage with the parameter\n{\\t tuningpitch}. Here it is set to 2~V (2 octaves higher then 0~V):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\immediate\\write\\patchexamples{    tuningpitch = 2V}    tuningpitch = 2V\n\\end{droidini}\n\nSometimes it is desirable to change the tuning pitch to other\noctaves on the fly. This example uses pot {\\t P1.1} for going through\nseveral octaves, and uses a quantizer for creating steps of 1~V each:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    steps = 1 # 1 step per octave}    steps = 1 # 1 step per octave\n\\immediate\\write\\patchexamples{    output = _TUNINGPITCH}    output = _TUNINGPITCH\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\immediate\\write\\patchexamples{    tuningpitch = _TUNINGPITCH}    tuningpitch = _TUNINGPITCH\n\\end{droidini}\n\n\n\\subsubsection*{Perfect VCO calibration}\n\nIf you {\\it really} want to eliminate all beatings in your chords while\nusing analog VCOs, you probably need something to correct tracking\ndeviations. Here I strongly recommend using the circuit {\\t calibrator}\n(see page \\pageref{calibrator}). Here is an example with three voices,\nwhere buttons of a P2B8 are used for fine tuning the VCO tracking\nin each octave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = _O1}    output1 = _O1\n\\immediate\\write\\patchexamples{    output2 = _O2}    output2 = _O2\n\\immediate\\write\\patchexamples{    output3 = _O3}    output3 = _O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O1}    input = _O1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    nudgeup = B1.1}    nudgeup = B1.1\n\\immediate\\write\\patchexamples{    nudgedown = B1.3}    nudgedown = B1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O2}    input = _O2\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    nudgeup = B1.2}    nudgeup = B1.2\n\\immediate\\write\\patchexamples{    nudgedown = B1.4}    nudgedown = B1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O3}    input = _O3\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{    nudgeup = B1.5}    nudgeup = B1.5\n\\immediate\\write\\patchexamples{    nudgedown = B1.7}    nudgedown = B1.7\n\\end{droidini}\n\nThe number of pitch inputs and pitch outputs you patch\nshould be identical.", "title": " Perfect intonation of up to eight voices", "outputs": [{"count": 8, "start_at": 1, "name": "output1 ... output8", "default": null, "prefix": "output", "type": "voltperoctave", "description": "\\nth1 ... \\nth8 pitch output\n"}], "presets": 0}, "calibrator": {"category": "pitch", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": "0", "type": "voltperoctave", "name": "input", "description": "Patch your V/Oct pitch input here.\n"}, {"default": null, "type": "trigger", "name": "nudgeup", "description": "A trigger here (most likely a button press) will modify the tuning of\nthe currently played note (as read by {\\t input}) {\\it upwards} by\none cent (or by {\\t nudgeamount} if that is used.\n"}, {"default": null, "type": "trigger", "name": "nudgedown", "description": "A trigger here will modify the tuning of\nthe currently played note down.\n"}, {"default": "0.01", "type": "cv", "name": "nudgeamount", "description": "Changes the amount each button press detunes. A value of one would mean\none semitone, so the default value of 0.01 corresponds to one cent ($\\frac{1}{100})$\nof a semitone.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Resets all tunings to 0 -- or to the values of the according {\\t tune...} inputs\nif they are used.\n"}, {"count": 9, "start_at": 0, "name": "tune0 ... tune8", "default": "0", "prefix": "tune", "type": "cv", "description": "Explicit tuning of the octaves 0 through 8 -- if you do not want\nto nudge manually. {\\t tune0} sets the tuning for the input\npitch of 0~V, {\\t tune1} for 1~V and so on. A value of 1 means a tune adjustment\nof one semitone -- which is 100 cent. The maximum detuning is $\\pm$ 1~Octave (\nat a value of $\\pm 12$).\n"}, {"default": "0", "type": "cv", "name": "tunelowtail", "description": "Tuning adaption for the negative voltage range.\nA value of 1 means an upwards tuning of one semitone\n{\\it per octave}, -1 likewise downwards.\n"}, {"default": "0", "type": "cv", "name": "tunehightail", "description": "Tuning adaption for voltages $>$ 8~V. A value of 1 means\nan upwards tuning of one semitone {\\it per octave}, -1 likewise\ndownwards.\n"}], "description": "\\subsubsection*{Introduction}\n\nThis circuit allows you to precisely compensate for decalibrated or otherwise\nimperfectly tracking VCOs -- which is probably a property of all existing\nanalog VCOs to some degree.  It does this by applying one specific adaptation\nvalue per individual octave. This way you can make even those VCO track well\nover 10 octaves, that would normally only do 2 or 3.\n\nThe calibration of the error compensation is done manually -- by you.\nAt first this may seem like a disadvantage. In practice, however, this is\nmuch easier and more accurate than the way some ``autotune'' modules do it.\nThose modules have an additional input for ``listening'' to a waveform output\nof the oscillator and measure and adjust the tracking at a button press.\n\nThe advantages of manual tuning are:\n\n\\begin{itemize}\n\n\\item You don't need an extra waveform output of your VCO.\n\n\\item You can calibrate sound sources with complex wave forms, whose pitch\nis are hard to grab by autotune devices.\n\n\\item You can change the correction at any time during a live performance without\nyour audience noticing.\n\n\\item It's possible to make one VCO follow the (imperfect) tracking of a second\none, in order to create perfect FM sounds while just one VCO\nneeds to be adapted.\n\n\\item It's also possible to fix the tracking of unprecise pitch CV {\\it\ngenerators}, such as sequencers, quantizers or MIDI interfaces.\n\n\\end{itemize}\n\nThe calibrator circuit happily profits from the \\droid's highly\nprecise, linear and low-jitter ADCs and DACs. And using eight such\ncircuits one \\droid could fix the tuning of up to eight VCOs.\n\n\\subsubsection*{How to use}\n\nHere is a typical patch for the use of the calibrator:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input     = I1}    input     = I1\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    nudgeup   = B1.1}    nudgeup   = B1.1\n\\immediate\\write\\patchexamples{    nudgedown = B1.3}    nudgedown = B1.3\n\\immediate\\write\\patchexamples{    ledup     = L1.1}    ledup     = L1.1\n\\immediate\\write\\patchexamples{    leddown   = L1.3}    leddown   = L1.3\n\\end{droidini}\n\nThe original pitch information from the sequencer, quantizer, MIDI converter\nor whatever comes into {\\t I1}. The adapted pitch goes to {\\t O1} and\nfrom there to the V/Oct input of your VCO. Of course the pitch information\ncould also come from some internal circuit like the {\\t minifonion} (page\n\\pageref{minifonion}).  In that case {\\t input} is connected to an internal patch cable\ncoming from that circuit.\n\nNow with the two buttons {\\t B1.1} and {\\t B1.3} you can adjust the tuning up\nand down at any time while playing. Each button press just very slightly shifts\nthe pitch up or down. The adjustment is just done for the octave that's\ncurrently played. {\\t calibrator} saves one calibration value for each octave\nfrom 0 to 8 and also one for the pitches below 0~V and those about 8~V. Your\ntuning profile is saved to the memory card automatically.\n\nPressing both buttons at the same time resets the calibration of the current\noctave.\n\nFor a good result I suggest either using a precise tuner or playing the voice\nat the same time as a reference voice and try to minimize the audible beatings.\n\nAs second way of using the VCO calibrator is specifying a tuning adjustment for\neach octave by a fixed number (or a potentiometer if you can afford). This is\ndone with the inputs {\\t tune0} ... {\\t tune8} and {\\t tunelowtail} and {\\t\ntunehightail}.A value of 1.0 means an upwards tuning of one semitone (100 cents)\n{\\it per octave}, and -1.0 likewise downwards.\n\n\\subsubsection*{Persistence}\n\nAs always, the internal state of the {\\t calibrator} circuit is saved\nto your SD card and automatically loaded when your \\droid starts.\n\nBut what if you are using several calibrators, each for a different (and\ndifferently tracking) VCO? How do you know which of the saved calibration\nstates is applied to which VCO?\n\nThe answer to this is: all calibrators in your patch are enumerated starting\nfrom 1. For each of them there is one configuration saved to the SD card,\nbased on that number. So when you modify the calibration of the third {\\t\ncalibrator} circuit in your patch, the modified configuration will be saved\nas belonging to calibrator number 3.\n\nSo if you make sure that each VCO is always handled by the same {\\t calibrator}\ncircuit you will always get the right configuration.\n\nIf you for example remove the first calibrator from your patch, the second\none will become the new first one and load its calibration state when you\nload the new patch. If you don't want that to happen, simply keep the calibrator\nin the patch even if you don't need it anymore. It is sufficient to keep\njust the line {\\t [calibrator]} without any further jack specifications.\n\n\\clearpage", "title": " VCO Calibrator", "outputs": [{"default": null, "type": "voltperoctave", "name": "output", "description": "The calibrated pitch goes out here.\n"}, {"default": null, "type": "fraction", "name": "ledup", "description": "When {\\t nudgeup} is mapped to a button (which is most likely),\nmap this output to the according LED and it will indicate whenever\nit's currently adjusting the output pitch upwards.\n"}, {"default": null, "type": "fraction", "name": "leddown", "description": "This is the LED for {\\t nudgedown}, which indicates downwards\nadjustment.\n"}], "presets": 0}, "switch": {"category": "cv", "inputs": [{"count": 8, "start_at": 1, "name": "input1 ... input8", "default": "0", "prefix": "input", "type": "cv", "description": "\\nth1 ... \\nth8 input\n"}, {"default": null, "type": "trigger", "name": "forward", "description": "If a trigger or gate is received here, the switch adds one\nto the current internal switch offset. So every output moves to the\nnext input and every input moves to the previous output.\n"}, {"default": null, "type": "trigger", "name": "backward", "description": "Similar then {\\t forward}, but switches backwards\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Resets the switch to its initial position. Assuming {\\t offset} is at {\\t 0},\n{\\t input1} is connected to {\\t output1}, {\\t input2} to {\\t output2} etc.\n\nIf {\\t reset} and a trigger at {\\t forward} / {\\t backward} happen at the\nsame time (within\n5~ms), the reset will win and the switch is being reset to offset\n0. This avoids problems with unprecise timing of external sequencers.\n"}, {"default": "0", "type": "integer", "name": "offset", "description": "This is for CV addressable switching. The number read here is being used\na shifting offset and is always added to the internal offset.\nFor example if you send {\\t 5} here, it is like\nyou have triggered {\\t forward} five times after the last reset. Please\nnote, then {\\t 5} would mean 50 Volts, not 5 Volts. So if you patch an\nexternal CV like {\\t I1} here, you probably want to multiply with some\nuseful number.\n"}], "description": "This circuit supports a set of various switching operations. It can switch\nseveral inputs to one output either by means of addressing the input via CV\nor by stepping forward and backward. You can do the same vice versa:\nconnecting one input to one of several outputs while setting the inactive\noutputs to 0~V.\n\nYou can even use several inputs {\\it and} outputs at the same time and\nthus create an $n \\times m$ switch with the option of rotating the outputs against\nthe inputs by means of addressing or stepping.\n\nAt minimum you need to patch two inputs and one output (or vice versa), plus\na switch like {\\t forward}, {\\t backward} or {\\t offset}.\n\nThe first example switches four inputs {\\t I1} ... {\\t I4} to one output {\\t\nO1} be means of a trigger at {\\t forward}. At the beginning {\\t I1} is wired to\n{\\t O1}. Each time a trigger is seen at {\\t forward} the switch switches to the\nnext input and at the end starts over at {\\t I1} again. So\nit cycles through {\\t I1} $\\rightarrow$ {\\t I2}\n$\\rightarrow$ {\\t I3}  $\\rightarrow$ {\\t I4} $\\rightarrow$ {\\t I1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    input4  = I4}    input4  = I4\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nPlease note, that {\\t output} and {\\t output1} are synonyms here. You\ncan use either way you like. Just the same is {\\t input} just a shorthand\nfor {\\t input1}.\n\nNow Let's do the opposite thing: distribute one input to four different\noutputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nNow when you try this out you might notice that a trigger to {\\t forward}\nmoves the selected output {\\it backwards}! This is no bug but very logical.\nThe reason will get more clear if we build a switch with several inputs\n{\\it and} outputs. Let's make a 3$\\times$3 switch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nNow a trigger to {\\t forward} moves each output forward to the next\ninput. That is the same as saying each input moves {\\it backward} to\nthe previous output. Of course you can change the direction by using\n{\\t backward} instead of {\\t forward}.\n\nInstead of moving the switch with a trigger you also can {\\it address} it\nby using a CV at the input {\\t offset}. In this example we use a steady CV\nbeing either 0 (for selecting {\\t O1}) or 1 (10~V) for selecting {\\t O2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    offset  = I7}    offset  = I7\n\\end{droidini}\n\nUsing two inputs and two outputs creates a switch that can swap these two. Here\nwith offset 0 {\\t input1} is connected to {\\t output1}\nand {\\t input2} to {\\t output2}. If {\\t offset} is {\\t 1}, {\\t input1}\nwill be connected to {\\t output2} and {\\t input2} to {\\t output1}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    offset  = I7}    offset  = I7\n\\end{droidini}\n\nNow let's make another example for a CV addressable switch. The CV is read from\n{\\t I7}. At a voltage of 0~V {\\t output1} is connected to {\\t input1},\nat 1~V to {\\t input2}, at 2~V to {\\t input3}, at 3~V to {\\t input4}, at\n4~V to {\\t input1} again, at 5~V to {\\t input2} and so on:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    input4  = I4}    input4  = I4\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    offset = I7 * 10 # 1 V per switch step}    offset = I7 * 10 # 1 V per switch step\n\\end{droidini}\n\nGenerally speaking, if you connect less inputs than outputs, the unconnected\ninputs are regarded as getting a 0~V input. If you connect less outputs then\ninputs, the unconnected outputs send their values into the black horrible void.\n\n\\pagebreak", "title": " Adressable/clockable switch", "outputs": [{"count": 8, "start_at": 1, "name": "output1 ... output8", "default": null, "prefix": "output", "type": "cv", "description": "\\nth1 ... \\nth8 output\n"}], "presets": 0}, "slew": {"category": "cv", "inputs": [{"default": null, "type": "cv", "name": "input", "description": "Wire the CV that you wish to slew limit here.\n"}, {"default": "1", "type": "cv", "name": "slew", "description": "This controls the slew rate. A value of {\\t 0.0} disables slew\nlimiting. The output immediately follows the input without any\ndelay. A value of for example {\\t 2.0} in linear mode means that\n2.0 seconds are needed for a change of 1~V (which is a value of\n0.1 or one octave if used as pitch).\nIn the other two modes the slew time is tuned to sound similar.\nNegative values of this parameter are treated as {\\t 0.0}.\n"}, {"default": "1", "type": "cv", "name": "slewup", "description": "This allows a special handling when the voltage moves {\\it upwards}.\nThe slew limiting for upwards is {\\t slew} multiplied with {\\t slewup}.\nSince {\\t slew} defaults to {\\t 1.0} you can just use {\\t slewup}\nand {\\t slewdown} if you want to control both directions separately.\n"}, {"default": "1", "type": "cv", "name": "slewdown", "description": "Sets the slew rate for downwards movement.\n"}, {"default": "unpatched", "type": "gate", "name": "gate", "description": "If this jack is patched, the slew limiting is only active\nwhile this gate is high. Otherwise it's like setting the {\\t slew}\nparameter to zero.\n"}], "description": "This is a CV controllable slew limiter for CVs. Special about it is that it\nimplements three alternative algorithms. The traditional exponential algorithm\n(as is commonly implemented in analog circuits), a linear algorithm and a\nspecial S-shaped curve.\n\nHere is a simple example for a slew limiting on {\\t I1} $\\longrightarrow$ {\\t O1}\nwhich is controlled with the pot {\\t P1.1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[slew]}[slew]\n\\immediate\\write\\patchexamples{    input       = I1}    input       = I1\n\\immediate\\write\\patchexamples{    slew        = P1.1}    slew        = P1.1\n\\immediate\\write\\patchexamples{    exponential = O1}    exponential = O1\n\\end{droidini}\n\n\\subsubsection*{Exponential shape}\n\nThis is the ``classical'' slew limit shape, which originates from the\n(negative) exponential loading current of a capacitor. It is also the shape of a low\npass filter that is used for slew limiting. The slope is proportional to\nthe distance between the current and the target voltage. Or in other words\nthe voltage changes fast at the beginning and slower at the end:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:1.5,color=blue,samples=100]{5 - 0.08^x * 4};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.5,5)};\n\\legend{Exponential,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\n\\subsubsection*{Linear shape}\n\nThe {\\it linear} algorithm simply limits the voltage change per time\nto a certain change rate, e.g. to 10~V per second. If the input\nvoltage changes faster (for example suddenly jumps up), the output\nvoltage follows that with that maximum rate. At a pot position of\n{\\t 0.5} the maximum slew is 120~V per second.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:1.5,color=green!50!black] coordinates {(-0.5,1) (0.0,1) (1.3,5) (1.5,5)};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.3,5)};\n\\legend{Linear,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{S-Curve shape}\n\nThe S-curve -- when applied to pitches -- sounds different than\nan exponential curve since it more reflects the way e.g. a trombone\nplayer accelerates and deaccelerates his arm in order to move to\nanother pitch. In our algorithm we assume that in the first half\nof the time the arm accelerates at a constant rate (which is controlled\nby the {\\t slew} parameter) and at the second half of the time it\ndeaccelerates (again at that rate, just negative), until it exactly\nreaches the target pitch.\n\nThere is one audible difference to a real trombone player, however.\nThe real musician would start to move his arm {\\it before} the new\nnote begins, in order to be at the target position right in time.\nBut here the movement is initiated by the pitch change it self so\nit is delayed by the slew limiting.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:0.5,color=red,samples=100] {x * x * 8 + 1};\n\\addplot [domain=0.5:1.0,color=red,samples=100]\n{5 - ((0.5-(x-0.5)) * (0.5-(x-0.5)) * 8)};\n\\addplot [domain=1.0:1.5,color=red,samples=100] {5};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.5,5)};\n\\legend{S-curve,,,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\\clearpage", "title": " Slew limiter", "outputs": [{"default": null, "type": "cv", "name": "exponential", "description": "Output for the resulting CV with the exponential (classical) slew\nalgorithm applied\n"}, {"default": null, "type": "cv", "name": "linear", "description": "Output for linear slew limiting\n"}, {"default": null, "type": "cv", "name": "scurve", "description": "Output with the slew limitation according to the S-curve algorithm.\n"}], "presets": 0}, "notebuttons": {"category": "ui", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"count": 12, "start_at": 1, "name": "button1 ... button12", "default": null, "prefix": "button", "type": "trigger", "description": "Wire 12 buttons to these 12 inputs.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "When you use this jack, all button presses are quantized in\ntime to the next clock pulse arriving here. That makes it easier\nto switch the note exactly in time.\n"}], "description": "This simple utility combines 12 buttons, just like radio buttons, into\na selector for a note such as C, $C\\sharp$, D, D$\\sharp$ and so on. It is\nsimilar to {\\t buttongroup}, but much simpler. And it allows 12 buttons. The\noutput is either a number from {\\tt 0} to {\\tt 11} -- or alternatively on a\n$\\frac{1}{12}$~V per semitone base. The later one is ideal for sending that\nto external sequencers or quantizers as they often adopt that scheme.\n\nThe following example uses all eight buttons of the\nfirst controller plus the first column of the second\ncontroller for selecting the twelve notes. It sends the\ncurrently selected note to {\\tt O7} in a 1~V per octave scheme:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notebuttons]}[notebuttons]\n\\immediate\\write\\patchexamples{    button1  = B1.1}    button1  = B1.1\n\\immediate\\write\\patchexamples{    button2  = B1.2}    button2  = B1.2\n\\immediate\\write\\patchexamples{    button3  = B2.1}    button3  = B2.1\n\\immediate\\write\\patchexamples{    button4  = B1.3}    button4  = B1.3\n\\immediate\\write\\patchexamples{    button5  = B1.4}    button5  = B1.4\n\\immediate\\write\\patchexamples{    button6  = B2.3}    button6  = B2.3\n\\immediate\\write\\patchexamples{    button7  = B1.5}    button7  = B1.5\n\\immediate\\write\\patchexamples{    button8  = B1.6}    button8  = B1.6\n\\immediate\\write\\patchexamples{    button9  = B2.5}    button9  = B2.5\n\\immediate\\write\\patchexamples{    button10 = B1.7}    button10 = B1.7\n\\immediate\\write\\patchexamples{    button11 = B1.8}    button11 = B1.8\n\\immediate\\write\\patchexamples{    button12 = B2.7}    button12 = B2.7\n\\immediate\\write\\patchexamples{    led1     = L1.1}    led1     = L1.1\n\\immediate\\write\\patchexamples{    led2     = L1.2}    led2     = L1.2\n\\immediate\\write\\patchexamples{    led3     = L2.1}    led3     = L2.1\n\\immediate\\write\\patchexamples{    led4     = L1.3}    led4     = L1.3\n\\immediate\\write\\patchexamples{    led5     = L1.4}    led5     = L1.4\n\\immediate\\write\\patchexamples{    led6     = L2.3}    led6     = L2.3\n\\immediate\\write\\patchexamples{    led7     = L1.5}    led7     = L1.5\n\\immediate\\write\\patchexamples{    led8     = L1.6}    led8     = L1.6\n\\immediate\\write\\patchexamples{    led9     = L2.5}    led9     = L2.5\n\\immediate\\write\\patchexamples{    led10    = L1.7}    led10    = L1.7\n\\immediate\\write\\patchexamples{    led11    = L1.8}    led11    = L1.8\n\\immediate\\write\\patchexamples{    led12    = L2.7}    led12    = L2.7\n\\immediate\\write\\patchexamples{    semitone = O7}    semitone = O7\n\\end{droidini}\n\n\\clearpage", "title": " Note Selection Buttons", "outputs": [{"count": 12, "start_at": 1, "name": "led1 ... led12", "default": null, "prefix": "led", "type": "gate", "description": "Wire the LEDs in the buttons to these 12 outputs.\n"}, {"default": null, "type": "integer", "name": "output", "description": "Here you get a number from 0 to 11, according to the currently\nselected button.\n"}, {"default": null, "type": "voltperoctave", "name": "semitone", "description": "Here you get the same as {\\t output}, but divided by 120. When\nyou patch this output to a CV output of the \\droid, like {\\t O1},\nit will output the note as a semitone on a 1~V per octave scheme.\n"}], "presets": 0}, "adc": {"category": "logic", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Input signal to convert to binary representation.\n"}, {"default": "0", "type": "cv", "name": "minimum", "description": "The lowest assumed input value. This value and all lower\nvalues will be converted to the bit sequence {\\t 000000000000}.\n"}, {"default": "1", "type": "cv", "name": "maximum", "description": "The highest assumed input value. This value and all higher\nvalues will be converted to the bit sequence {\\t 111111111111}.\n"}], "description": "This circuit converts an input value into a binary representation\nof up to 12 bits. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[adc]}[adc]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    bit1 = O1}    bit1 = O1\n\\immediate\\write\\patchexamples{    bit2 = O2}    bit2 = O2\n\\immediate\\write\\patchexamples{    bit3 = O3}    bit3 = O3\n\\end{droidini}\n\nIn this example three bits are being used. Three bits can represent\na number from 0 to 7. These are mapped to the input range from 0\nto 1 (or 0~V to 10~V) in the following way:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\ninput                  & {\\t bit1} & {\\t bit2} & {\\t bit3} & bit value \\\\ \\hline\n$-\\infty$ ... 0.125    & {\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0} \\\\ \\hline\n0.125     ... 0.250    & {\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1} \\\\ \\hline\n0.250     ... 0.375    & {\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2} \\\\ \\hline\n0.375     ... 0.500    & {\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3} \\\\ \\hline\n0.500     ... 0.625    & {\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4} \\\\ \\hline\n0.625     ... 0.750    & {\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5} \\\\ \\hline\n0.750     ... 0.875    & {\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6} \\\\ \\hline\n0.875     ... $\\infty$ & {\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7} \\\\ \\hline\n\\end{tabular}}\n\nValues lower than 0 are treated as 0. Values higher than 1 are treated\nas one.\n\nIn other words: this circuit will convert an analog input value\ninto three different gate outputs.\n\nThe expected range of the input value is from 0 to 1 per default, but\nyou can change that with the parameters {\\t minimum} and {\\t maximum}.\nFor example you could have just the range of 0.1 to 0.5 mapped to\nthe three bits:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[adc]}[adc]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    minimum = 0.1 # 1V}    minimum = 0.1 # 1V\n\\immediate\\write\\patchexamples{    maximum = 0.5 # 4V}    maximum = 0.5 # 4V\n\\immediate\\write\\patchexamples{    bit1 = O1}    bit1 = O1\n\\immediate\\write\\patchexamples{    bit2 = O2}    bit2 = O2\n\\immediate\\write\\patchexamples{    bit3 = O3}    bit3 = O3\n\\end{droidini}\n\nNow the table looks like this:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\ninput              & {\\t bit1} & {\\t bit2} & {\\t bit3} & bit value \\\\ \\hline\n$-\\infty$ ... 0.15 & {\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0} \\\\ \\hline\n0.15 ... 0.20      & {\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1} \\\\ \\hline\n0.20 ... 0.25      & {\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2} \\\\ \\hline\n0.25 ... 0.30      & {\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3} \\\\ \\hline\n0.30 ... 0.35      & {\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4} \\\\ \\hline\n0.35 ... 0.40      & {\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5} \\\\ \\hline\n0.40 ... 0.45      & {\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6} \\\\ \\hline\n0.45 ... $\\infty$  & {\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7} \\\\ \\hline\n\\end{tabular}}\n\nIf you use more of the {\\t bit}-outputs you get more resolution.\nFor example if you use {\\t bit1} ... {\\t bit8}, the total range\nwill be divided into 256 equal pieces. Since bit~1 is the most significant\nbit, adding more and more bits will not change the way bit~1 is behaving.\n\nThe applications of this circuit are various and often surprising. For example\nusing different LFO wave forms as inputs (other than square) and you will\nget slower and faster gate patterns.\n\nPlease also have a look at the circuit {\\t dac} (see page \\pageref{dac},\nwhich does the exact opposite!\n\n\\clearpage", "title": " AD Converter with 12 bits", "outputs": [{"count": 12, "start_at": 1, "name": "bit1 ... bit12", "default": null, "prefix": "bit", "type": "gate", "description": "The 12 bit outputs. {\\t bit1} is the MSB -- the most significant\nbit. The LSB (least significant bit) is the highest output that\nyou actually patch. If you do not need the full resolution of\n12 bits, simply just use the first couple of outputs.\n"}], "presets": 0}, "crossfader": {"category": "cv", "inputs": [{"count": 8, "start_at": 1, "name": "input1 ... input8", "default": "0", "prefix": "input", "type": "cv", "description": "The input signals that you want to crossfade between. At least\n{\\t input1} and {\\t input2} need to be patched. Otherwise they\nare treated like 0 V signals.\n"}, {"default": "0.5", "type": "fraction", "name": "fade", "description": "This value decides which of the two inputs should be mixed and\nto which degree each one should go into the mix. At {\\t 0.0} the\nmix consists of 100\\% of the first inputs, at {\\t 1.0} of 100\\%\nof the last patched input.\n"}], "description": "This utility circuit creates CV controlled mix of two\nout of up to eight inputs. With two inputs this acts like\na classical cross fader. The following example lets you\nfade between the signals at {\\t I1} and {\\t I2} by\nturning the pot {\\t P1.1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    fade   = P1.1}    fade   = P1.1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nAt fully CCW ({\\t 0.0})\nonly the signal of the first input is being output,\nat fully CW ({\\t 1.0}) only that of the second one.\nIn the center position ({\\t 0.5}) you get the average\nof both inputs, namely $0.5\\times${\\t I1}$\\hspace{1mm}\n+ \\hspace{1mm}0.5\\times${\\t I2}.\n\nUsing more than two inputs is possible. The {\\t fade} input\nthen maps the range 0.0 ... 1.0 to a journey from the first\nto the last input. Let's see the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz           = 0.1}    hz           = 0.1\n\\immediate\\write\\patchexamples{    sawtooth     = _FADE}    sawtooth     = _FADE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1       = I1}    input1       = I1\n\\immediate\\write\\patchexamples{    input2       = I2}    input2       = I2\n\\immediate\\write\\patchexamples{    input3       = I3}    input3       = I3\n\\immediate\\write\\patchexamples{    input4       = I4}    input4       = I4\n\\immediate\\write\\patchexamples{    fade         = _FADE}    fade         = _FADE\n\\immediate\\write\\patchexamples{    output       = O1}    output       = O1\n\\end{droidini}\n\nNow during one LFO cycle of 10 seconds the output {\\t O1} begins with the\nsignal at {\\t I1} and then morphs to that of {\\t I2}. It reaches 100\\%\nof {\\t I2} at a fade value of $\\frac13$. Then it continues to {\\t I3},\nwhich it reaches at $\\frac23$ and finally -- after 10 seconds --\nit ends at {\\t I4}. After that it immediately jumps back to {\\t I1},\nin order to begin the next cycle.\n\nValues beyond 1.0 for {\\t fade} are allowed and allow you to morph from the\nlast input to the first one. In the upper example that would be the range\nfrom {\\t 1.0} to {\\t 1.3333}. So if you scale up the sawtooth to a total\nrange of {\\t 0.0} ... {\\t 1.3333} you will get a smooth cyclic morph\nbetween all four inputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz           = 0.1}    hz           = 0.1\n\\immediate\\write\\patchexamples{    sawtooth     = _FADE}    sawtooth     = _FADE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1       = I1}    input1       = I1\n\\immediate\\write\\patchexamples{    input2       = I2}    input2       = I2\n\\immediate\\write\\patchexamples{    input3       = I3}    input3       = I3\n\\immediate\\write\\patchexamples{    input4       = I4}    input4       = I4\n\\immediate\\write\\patchexamples{    fade         = _FADE * 1.3333}    fade         = _FADE * 1.3333\n\\immediate\\write\\patchexamples{    output       = O1}    output       = O1\n\\end{droidini}", "title": " Morph between 8 inputs", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Output of the mix\n"}], "presets": 0}, "spring": {"category": "modulation", "inputs": [{"default": "1", "type": "cv", "name": "mass", "description": "The mass of the object on the spring. The heavier it is, the farther the spring\nwill move up and down.\n"}, {"default": "1", "type": "cv", "name": "gravity", "description": "The gravity of the simulated planet the spring is mounted at. If you\nset the gravity to zero, the mass will move exactly around the zero\nposition from positive to negative and back. But you need to shove\nit or set a start position other than 0, in order to get it started.\n"}, {"default": "1", "type": "cv", "name": "springforce", "description": "The force of the string per m it is stretched. In an ideal spring\nthe force is proportional to the current elongation.\n"}, {"default": "0", "type": "cv", "name": "flowresistance", "description": "Setting this to a value $> 0$ will dampen the oscillation in a way,\nthat higher velocities will be damped more then slower ones. This means\nthat impact of the friction will get less and less as time goes by and\nthe movement slows down.\n"}, {"default": "0", "type": "cv", "name": "friction", "description": "Setting this to a value $> 0$ will also dampen the oscillation, but in\na way that is independent of the current speed of the mass.\n"}, {"default": "1", "type": "cv", "name": "speed", "description": "This parameter speeds up (or slows down) the perceived time. It works\non a 1V/Oct base. So if you set speed to {\\t 1V} or {\\t 0.1} it will speed\nup the movement by 100\\%.\n"}, {"default": "0", "type": "gate", "name": "shove", "description": "While this gate input is logical 1, an extra force of 1~N is applied to\nthe mass pointing downwards. You can change that force with {\\t shoveforce}.\n"}, {"default": "1", "type": "cv", "name": "shoveforce", "description": "This is the force being applied to the mass while {\\t shove} is active\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Resets the whole system to its start position.\n"}, {"default": "0", "type": "cv", "name": "startvelocity", "description": "Sets the velocity the mass has which \\droid starts of a reset is triggered\n"}, {"default": "0", "type": "cv", "name": "startposition", "description": "Sets the position the spring has which \\droid starts of a reset is triggered\n"}], "description": "This circuits implements a physical simulation of a mass hanging from on an\nideal spring, like in the following drawing. This can create interesting\nCV sources.\n\n\\begin{tikzpicture}\n\\fill[black!20] (0,7) rectangle (8,8);\n\\draw (0,8) -- (0,7) -- (8,7) -- (8,8);\n\\foreach \\x in {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}\n  \\draw(\\x * 0.5,7) -- (\\x * 0.5 +0.5,8);\n\\foreach \\x in {0,0.5,1,1.5,2,2.5,3}\n  \\draw(4, 7-\\x) -- (3, 6.875-\\x) -- (5, 6.625-\\x) -- (4,6.5-\\x);\n\\draw(4,3.5) -- (4,2);\n\\fill[black!80] (4,2) circle (0.8);\n\\draw[thick,->] (1,6.9) -- (1,0.75);\n\\foreach \\x in {6.9, 5.75, 4.5, 3.25, 2}\n    \\draw[thick] (0.9,\\x) -- (1.1,\\x);\n\\draw (0.7, 6.8) node[anchor=east] {0.00};\n\\draw (0.7, 5.75) node[anchor=east] {0.25};\n\\draw (0.7, 4.5) node[anchor=east] {0.50};\n\\draw (0.7, 3.25) node[anchor=east] {0.75};\n\\draw (0.7, 2) node[anchor=east] {1.00};\n\\draw[white] (4,2) node {mass};\n\\draw[thick,<->] (7,2.8) -- (7,1.2);\n\\draw[thick] (6.9,2) -- (7.1,2);\n\\draw (7,1.2) node[anchor=north] {gravity};\n\\draw (7,2.8) node[anchor=south] {springforce};\n\\end{tikzpicture}\n\n\nWithout any further parameters the mass starts at position\n{\\t 0.00} and velocity {\\t 0.00} and is accelerating downwards until the\nforce of the spring equals the gravity. At this point it decelerates until\nthe velocity is zero. Now the mass is being accelerated {\\it upwards} until\nit reaches the top position at {\\t 0.00} again. This results, in essence,\nto a damped sine wave.\n\nThe {\\t position} and {\\t velocity} are available at their respective\noutputs ready to be used for modulation.\n\n\n\\columnbreak\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[spring]}[spring]\n\\immediate\\write\\patchexamples{    position = O1}    position = O1\n\\immediate\\write\\patchexamples{    velocity = O2}    velocity = O2\n\\end{droidini}\n\nNow, this could be done more easily with the LFO circuit (see page\n\\pageref{lfo}).  But it's getting interesting when you look at the other\nparameters and the modulation possibilities. Please look at the\ntable of jacks for details.\n\n\\subsubsection*{Friction}\n\nPer default the motion is without any friction and thus the mass will move\nup and down forever. You can apply two different types of friction.\n{\\t flowresistance} is the type of friction a body has in a liquid or\ngas. Its force is relative to its velocity. Whereas the normal {\\t friction}\nforce is constant.\n\nWhen you use any type of friction, the spring will finally stop swinging.\nYou need to either {\\it shove} it from time to time or reset it to its\nstart with the {\\t reset} trigger input.\n\nThe following example will create a slowly decaying sine wave, which is\nrestarted whenever a trigger is sent to {\\t reset}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[spring]}[spring]\n\\immediate\\write\\patchexamples{    flowresistance = 0.5}    flowresistance = 0.5\n\\immediate\\write\\patchexamples{    reset = I1}    reset = I1\n\\immediate\\write\\patchexamples{    position = O1}    position = O1\n\\immediate\\write\\patchexamples{    velocity = O2}    velocity = O2\n\\end{droidini}\n\n\n\\subsubsection*{Shoving}\n\nYou also can {\\it shove} the mass downwards or upwards. As long as you send a\ngate signal into {\\t shove} the mass will be shoved downwards.  The exact force\ncan be set with {\\t shoveforce} and defaults to being the same as the gravity.\nA negative value will lift the mass upwards.\n\nSetting {\\t shove} to a constant {\\t 1} value will steadily apply {\\t shoveforce},\nwhich can be interesting as that is itself a changing CV (some LFO, feedback\nloop or whatever).\n\n\\subsubsection*{The physical model}\n\nPlease note that the physical model is normalized in a way such that\nevery parameter is 1. For example the mass is $1 kg$ and the gravity\nis $1\\frac{N}{kg}$. The force of the spring is $1\\frac{N}{m}$.\n\nIn order to avoid anomalies or infinities, the velocity of the mass is limited\nto $\\pm 10\\frac{m}{s}$ and the position is limited to the range of $\\pm 10~m$.\n\n\\pagebreak", "title": " Physical spring simulation", "outputs": [{"default": null, "type": "cv", "name": "velocity", "description": "Outputs the current velocity of the mass\n"}, {"default": null, "type": "cv", "name": "position", "description": "Output the current length of the string. If the string goes\nupwards (which is possible with certain modulations), this can\nbe negative.\n"}], "presets": 0}, "explin": {"category": "logic", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Patch an exponential envelope output or a similar signal here. This\nvalue must be positive or otherwise it will be set to {\\t 0.0}.\n"}, {"default": "1", "type": "cv", "name": "startvalue", "description": "The assumed maximum value of the input signal (the start voltage\nfrom where it decays in an exponential way.\n"}, {"default": "0.01", "type": "cv", "name": "endvalue", "description": "The value at which it is assumed to be zero (at which the linear\noutput will be set to zero. This value must be positive. It is forced\nto be $>=$  {\\t 0.001}.\n"}, {"default": "1", "type": "fraction", "name": "mix", "description": "Sets the mix between the ``dry'' and ``wet'' signal: At {\\t 0.0} the\noutput is the same as the input. At {\\t 1.0} the output is the linear\ncurve. At a value in between it is some average. You are even allowed\nto used values $>$ {\\t 1.0}. A value of {\\t 2.0} will overcompensate\nand bend the curve beyond linearity into a curve some modularists would\ncall {\\it logarithmic}.\n"}], "description": "This circuit converts an exponential input curve into a linear\noutput curve. Image you have an analog envelope outputting an\nexponential curve like the following one:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0, 0.5, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\end{axis}\n\\end{tikzpicture}\n\nThe curve starts at 8 V and reaches 0.5 V at about 500 ms later.\n\nThe following droid patch will convert this into a linear curve:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[explin]}[explin]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    output  = O2}    output  = O2\n\\immediate\\write\\patchexamples{    startvalue = 8V}    startvalue = 8V\n\\immediate\\write\\patchexamples{    endvalue = 0.5V}    endvalue = 0.5V\n\\end{droidini}\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0, 0.5, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\addplot [domain=0:500,color=blue] coordinates { (0,8) (500,0) };\n\\legend{Input,Output}\n\\end{axis}\n\\end{tikzpicture}\n\nWith the values {\\t startvalue} and {\\t endvalue} you configure how\nthis translation is scaled. The {\\t startvalue} selects the voltage\nwhere the exponential input curve and the linear output curve should\nbe the same. If the input is an envelope voltage then {\\t startvalue}\nwould be the start or maximum voltage of that envelope.\n\nA falling exponential curve will never reach 0 in theory. So with {\\t endvalue}\nyou set a value (or voltage) in that you consider the curve to be low\nenough to be inaudible. At that voltage the linear output will exactly be\nzero. This voltage can be used to control the slope of the linear output\ncurve. The following example shows how different values of {\\t endvalue}\naffect the output:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0.5, 1, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=blue] coordinates { (0,8) (500,0) };\n\\addplot [domain=0:500,color=green!60!black] coordinates { (0,8) (380,0) };\n\\addplot [domain=0:500,color=red] coordinates { (0,8) (250,0) };\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\legend{0.5V,1V,2V}\n\\end{axis}\n\\end{tikzpicture}", "title": " Exponential to linear converter", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Here comes the resulting linear output\n"}], "presets": 0}, "pot": {"category": "ui", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": "0", "type": "fraction", "name": "pot", "description": "Wire your pot here, e.g. {\\t P1.1}\n"}, {"default": "1", "type": "cv", "name": "outputscale", "description": "The final output is multiplied with this value. It's a convenient\nmethod for scaling up and down the pot range.\n"}, {"default": "0", "type": "cv", "name": "notch", "description": "By setting this parameter to a positive number you create an\nartificial ``notch'' of that size. We suggest using {\\t 0.1} (or\n{\\t 10\\%}.  The maximum allowed value is {\\t 0.5}. Greater values\nwill be reduced to that.  Note: Using this in combination with {\\t\noutputscale} also moves the notching point.  E.g. with {\\t outputscale = 2}\nthe notch will be at {\\t 1.0}.\n"}, {"default": "1", "type": "cv", "name": "slope", "description": "Changes the resolution of the pot in lower or higher ranges.\nSet {\\t slope} to {\\t 2} or more, if you want small values near 0.0\nto be ``zoomed in''. Set slope to {\\t 0.5} or {\\t 0.3} if you want\nto zoom in value nears 1.0.\n"}, {"default": "unpatched", "type": "cv", "name": "ledgauge", "description": "The ``LED gauge'' uses the 16 LEDs of the \\droid master in order\nto indicate the current value of the pot. This is especially useful\nfor ``virtual'' pots -- i.e. those pots that you get when you use\n{\\t select} in order to layer several different functions onto one pot.\nIn that situation the position of the physical pot can be different\nthan that of the virtual one, so the gauge shows you the effective\nvirtual value.\n\nFurthermore, by illuminating the inner four LEDs, the gauge shows\nwhen the pot hits {\\it exactly} 0.5. This can only happen if you\nuse the {\\t notch} parameter. Otherwise its practically impossible\nto hit exactly.\n\nThe LED gauge is automatically activated if you use {\\t select}.\nIf you don't like the LED gauge, you can turn it\noff with {\\t ledgauge = off}. Otherwise {\\t ledgauge} set's the color\nof the indicator in the same way as the {\\t R}-registers do and at the\nsame time {\\it enables} the gauge even if you don't use {\\t select}.\n\nHere are some color examples that you can use for the value of {\\t ledgauge}:\n\n{\\footnotesize \\customcolortable}\n\n\\medskip\n"}, {"default": "unpatched", "type": "fraction", "name": "startvalue", "description": "This parameter only makes sense if you work with the {\\t select}\ninput in order to create overlayed virtual pots. Then the {\\it virtual}\npot value will be set to this value when your \\droid starts. Also\nthe current value will no longer be persisted to the SD card.\nOtherwise it starts at {\\t 0.5} at the very first time and is than\npersisted to the SD card. Please also have a look at the {\\t reset}\ninput.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the virtual pot value to {\\t 0.5} or\n-- if {\\t startvalue} is patched -- to that value. This only\nmakes sense if you use {\\t select} for creating overlayed virtual\npots.\n"}], "description": "This circuit adds plenty of functionality to the controller pots in one\ncircuit. It helps with various tasks. It replaces the former circuits {\\t\nnotchedpot} and {\\t switchedpot} and these are also the main applications\nof {\\t pot}: the simulation a precise center dent (notch) and the sharing\nof one pot for several different functions.\n\n\\subsubsection*{Convert a knob to bipolar output voltage}\n\nLet's start with some simple features. There are a couple of\nuseful outputs, all of which you could do externally by use of\nsome math. The following example converts a pot (which is ranging\nfrom 0 to 1) to a bipolar pot ranging from -1 to +1 (or -10~V to +10~V\nif you send it to an output):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    bipolar  = O1 # Send @10V ... +10V to O1}    bipolar  = O1 # Send -10V ... +10V to O1\n\\end{droidini}\n\nHave a look into the table of jacks below about further useful things\nlike splitting the pot's way in two halfs.\n\n\\subsubsection*{Center notch}\n\n{\\t pot} can simulate a potentiometer with a notch at the center.  It helps\nto exactly select the center position by defining a \"range of tolerance\"\nthat is considered to be the center. This range is called ``notch'' and is\ngiven in a percentage of the available range. I suggest using 10\\% so you\ndon't loose to much pot resolution, but it's still easy enough to hit the\ncenter reliably. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 10%}    notch    = 10%\n\\immediate\\write\\patchexamples{    output   = _ACTIVITY}    output   = _ACTIVITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    activity = _ACTIVITY}    activity = _ACTIVITY\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\\subsubsection*{Slope}\n\nSometimes you want a bit more resolution at the smaller values\nof the pot range. Maybe the pot controls a time from 0.0 to 1.0 seconds.\nAnd in the low range, say about 0.1 seconds, you need finer control.\n\nYou can change the slope of the pot in a way that either small values or\nvalues near 1.0 are ``streched out''. The default is {\\t slope = 1.0}.\nLook at the following diagram for the impact of different slope\nvalues:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $pot\\ movement (\\%)$,\n    ylabel = {$output\\ value$},\n    xmin = 0, xmax = 100, ymin = 0, ymax = 1,\n    ymajorgrids = true,\n    ytick={0, 0.25, 0.5, 0.75, 1},\n    grid style = dashed,\n    legend style={at={(0.25,1.0)}},\n]\n\\addplot [domain=0:100,color=cyan!70!black,samples=100] {((x/100) ^ 0.5)};\n\\addplot [color=red] coordinates { (0, 0) (100, 1) };\n\\addplot [domain=0:100,color=blue,samples=100] {((x/100) ^ 2)};\n\\addplot [domain=0:100,color=green!50!black,samples=100] {((x/100) ^ 3)};\n% \\legend{slope = 0.5, slope = 1.0, slope = 2.0, slope = 3.0}\n\\legend{0.5, 1.0, 2.0, 3.0}\n\\end{axis}\n\\end{tikzpicture}\n\nAs slope value of 0.0 does not make sense, because the pot would\nstick to 0.0 all the time, a minimum value of 0.001 is enforced.\n\nIf you are curious about the algorithm: This operation is just $x^{slope}$.\nSo it's not ``logarithmic'' or ``exponential'' but polynomial.\n\n\\subsubsection*{Sharing pots}\n\nPotentiometers are valuable ressources and sooner or later you will\nrun into a situation where you wish you had more pots. So you come\nup with the idea of using one pot for more than one function and\nswitch between those with a button.\n\nPreviously \\droid offered the circuit {\\t switchedpot} for that task\nbut that had certain limitations and also was not consistent with\nother circuits.\n\nLet's make an example: Our task is to share pot {\\t P1.1} so it\nsets {\\it individual} release values for four different envelopes.\nFirst we need something to switch between these\nfour. We do this with a {\\t buttongroup} (see page \\pageref{buttongroup}):\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\end{droidini}\n\nNow at any given time, exactly one of the four buttons (i.e. their LEDs)\nis active. Now we add four {\\t pot} circuits using the {\\it same pot}.\nThe trick is the {\\t select} input. Each of these four should be selected\njust if one specific button is active. The output of each is being sent\nto one of the envelopes:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.1}    select = L1.1\n\\immediate\\write\\patchexamples{    output = _RELEASE1}    output = _RELEASE1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.2}    select = L1.2\n\\immediate\\write\\patchexamples{    output = _RELEASE2}    output = _RELEASE2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.3}    select = L1.3\n\\immediate\\write\\patchexamples{    output = _RELEASE3}    output = _RELEASE3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.4}    select = L1.4\n\\immediate\\write\\patchexamples{    output = _RELEASE4}    output = _RELEASE4\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nFinally we can add the four envelopes:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I1}    trigger = I1\n\\immediate\\write\\patchexamples{    release = _RELEASE1}    release = _RELEASE1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    release = _RELEASE2}    release = _RELEASE2\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I3}    trigger = I3\n\\immediate\\write\\patchexamples{    release = _RELEASE3}    release = _RELEASE3\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I4}    trigger = I4\n\\immediate\\write\\patchexamples{    release = _RELEASE4}    release = _RELEASE4\n\\immediate\\write\\patchexamples{    output = O4}    output = O4\n\\end{droidini}\n\nNow you can switch between the four envelopes with the buttons\nand use the pot to adjust the release time of the selected envelope.\n\nHints:\n\\begin{itemize}\n\\item Don't mix up {\\t B1.1} and {\\t L1.1}. If you would use {\\t B1.1}\nfor the switching, you would need to {\\it hold} the button down while\nturning the knob. In which case you wouldn't need the {\\t buttongroup}\ncircuit.\n\\item It is supported (and maybe useful) to select {\\it several} of the \"virtual\"\npots at the same time. In such a situation the turning of the real knob will\nadjust all of the selected values at the same time.\n\\item Pots are no motorized faders. So they cannot show the current value\ncorrectly after switching. See below for details.\n\\item In certain cases the {\\t selectat} input might come handy: if you\ndo the switching with {\\it one} number that changes, not a bunch of gate\nsignals. See the jack table below for details.\n\\end{itemize}\n\n\\subsubsection*{Picking up the pots}\n\nPots are no motorized faders and no encoders. So when reusing a pot for more\nthan one function at a time there is always the problem when set to\none pot function the pot ist likely not set to the current value of\nthe function.  As an example let's assume that -- using the upper example --\nyou first press {\\t B1.1} and set decay fully CW {\\t 1.0}. Now you select {\\t\nB1.2}. Because {\\t 0.5} is the start position of every virtual pot that is the\ncurrent value of the second virtual pot. But the physical pot is at {\\t 1.0}.\n\nWe solve this in the following way:\n\n\\begin{itemize}\n\n\\item If you turn the physical pot {\\it right}, the value of the virtual\npot is always increased until both reach {\\t 1.0} at the same time.\n\n\\item If the physical pot is already at {\\t 1.0} when you select a virtual\npot, it cannot be increased further. You first have to turn the pot left a\nbit and then right again.\n\n\\item If you turn the physical pot {\\it left}, then the value of the virtual\npot is always {\\it decreased} until both reach {\\t 0.0} at the same time.\n\n\\item If the physical pot is already at {\\t 0.0} when you select a virtual\npot, it cannot be decreased further. You first have to turn the pot right\nand then left again.\n\n\\end{itemize}\n\nIf you really want even more details -- here we go: Let's assume that the\nvirtual pot is at {\\t 0.4} when you select it. And let's further assume\nthat the physical pot is at position {\\t 0.8}. When you turn it {\\it left},\nthe physical pot has a way of {\\t 0.8} to go until {\\t 0.0} and the virtual\njust {\\t 0.4}. So the virtual pot is moving with half of the speed, for\nboth to reach {\\t 0.0} at the same time. When you turn the pot {\\it right},\nthe virtual pot has {\\t 0.6} to go until maximum, while\nthe physical pot has just {\\t 0.2} left until it reaches its maximum. So\nnow the virtual pot moves three times faster than the physical.\n\nThis algorithm is different than the common ``picking up'' of pots that you\nsee in Eurorack land quite a lot in such situations. I preferred my solution\nbecause it seems to be more convenient -- especially if you\nwant to change a value {\\it a little bit}. Also it allows to have multiple\nvirtual pots to be selected at the same time without having their values\nimmediately snap to the same value.\n\nBy the way: it is also possible to select {\\it none} of the pots. Which is\na convenient way to reset the physical pot to the middle position so that\nyou always have headroom for movement left {\\it and} right, before selecting\none of the virtual pots.\n\n\\subsubsection*{Splitting the pot into two hemisperes}\n\nThe jacks {\\t lefthalf}, {\\t righthalf}, {\\t lefthalfinv} and\n{\\t righthalfinv} allow you to split the pot in the middle into\ntwo ranges and use them for something completely different.\nLet's make an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    lefthalf = O1}    lefthalf = O1\n\\immediate\\write\\patchexamples{    righthalf = O2}    righthalf = O2\n\\end{droidini}\n\nNow let's start with the pot in the center position. Both outputs will be at\n{\\t 0.0}. If you now turn the pot to the left, just {\\t lefthalf} (at {\\t O1})\nis going to rise until it reaches {\\t 1.0} at the left end of the pot range.\n{\\t righthalf} is staying at {\\t 0} all the time.\n\nAt the right half of the pot range, likewise {\\t lefthalf} stays zero and\n{\\t righthalf} will raise from {\\t 0} to {\\t 1}.\n\nThe jacks {\\t lefthalfinv} and {\\t righthalfinv} are similar, but\nare {\\t 1.0} in the neutral position in the center and fall to\n{\\t 0.0} at the edges.", "title": " Helper circuit for pots", "outputs": [{"default": null, "type": "fraction", "name": "output", "description": "Your pot output comes here.\n"}, {"default": null, "type": "cv", "name": "bipolar", "description": "Optional output with a range from -1.0 to 1.0, where the center notch\nis at 0.0 (or from -{\\t outputscale} to +{\\t outputscale} if that is used).\n"}, {"default": null, "type": "cv", "name": "absbipolar", "description": "A variation of {\\t bipolar} that always outputs a positive value,\ni.e. the pot will go 1 ... 0.5 ... 0 ... 0.5 ... 1 (if {\\t outputscale}\nis not used).\n"}, {"default": null, "type": "cv", "name": "lefthalf", "description": "This output allows you to split the pot into two hemispheres. Here\nyou get {\\t outputscale} ... 0.0 while the pot is in the left half. In the middle\nand right of it you always get 0.\n"}, {"default": null, "type": "cv", "name": "righthalf", "description": "This is the same but for the right half. It outputs 0 while\nthe pot is in the left half and 0.0 ... {\\t outputscale} from the middle to the\nfully right position.\n"}, {"default": null, "type": "cv", "name": "lefthalfinv", "description": "This outputs 1.0 - {\\t lefthalf}, i.e. the value range\n0.0 ... 1.0 ... 1.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right (and the scaled by {\\t outputscale}).\n"}, {"default": null, "type": "cv", "name": "righthalfinv", "description": "This outputs 1.0 - {\\t righthalf}, i.e. the value range\n1.0 ... 1.0 ... 0.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right (and the scaled by {\\t outputscale}).\n"}, {"default": null, "type": "trigger", "name": "onchange", "description": "This output emits a trigger whenever the pot is turned in\neither direction.\n"}], "presets": 0}, "math": {"category": "logic", "inputs": [{"count": 2, "start_at": 1, "name": "input1, input2", "default": null, "prefix": "input", "type": "cv", "description": "The two inputs\n"}], "description": "This circuit provides mathematic operations. Some of these use {\\t input1}\n{\\it and} {\\t input2} -- such as {\\t sum} or {\\t product}.  Other ones just use\n{\\t input1} (which can be abbreviated as {\\t input}) -- such as {\\t negation}\nor {\\t reciprocal}.\n\nExample for computing the quotient $\\frac{\\t I1}{\\t I2}$:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input1   = I1}    input1   = I1\n\\immediate\\write\\patchexamples{    input2   = I2}    input2   = I2\n\\immediate\\write\\patchexamples{    quotient = O1}    quotient = O1\n\\end{droidini}\n\nExample for computing the square root of {\\t I1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    root    = O1}    root    = O1\n\\end{droidini}\n\nNote: As long as you do not send a value directly to an output like {\\t O1},\nthe range of the value is not limited by this circuit. You can generate almost arbitrary\nsmall or large positive and negative numbers. When you send a value to\nan output, it will be truncated into the range -1 ... +1 (which corresonds\nto -10~V ... +10~V).", "title": " Math utility circuit", "outputs": [{"default": null, "type": "cv", "name": "sum", "description": "${\\t input1} + {\\t input2}$\n"}, {"default": null, "type": "cv", "name": "difference", "description": "${\\t input1} - {\\t input2}$\n"}, {"default": null, "type": "cv", "name": "product", "description": "${\\t input1} \\times {\\t input2}$\n"}, {"default": null, "type": "cv", "name": "quotient", "description": "${\\t input1}\\ /\\ {\\t input2}$. If {\\t input2} is zero, a very\nlarge number will be returned, while the correct sign is being\nkept. This is mathematically not correct but more useful than any\nother possible result.\n"}, {"default": null, "type": "cv", "name": "modulo", "description": "{\\t input1} modulo {\\t input2}. This needs some explanation: With\nthis operation you can ``fold'' the value from {\\t input1} into the\nrange 0 ... {\\t input2}. For example if {\\t input2} is 1~V, the\noutput will convert 1.234~V to 0.234~V, -2.1~V to 0.9~V and 0.5~V\nto 0.5~V. If {\\t input2} is zero or negative, the output will be zero.\n"}, {"default": null, "type": "cv", "name": "power", "description": "{\\t input1} to the power of {\\t input2}. Please note that the\npower has several cases where it is not defined when either\nthe base or the exponent is zero or less than zero. In order to\nbe as useful for your music making as possible the {\\t math} circuit behaves\nin the following way:\n\n\\begin{itemize}\n\\item If ${\\t input1} < 0$, {\\t input2} is rounded to the nearest integer.\n\\item If ${\\t input1} = 0$ and ${\\t input2} < 0$, a very large number is output.\n\n\\end{itemize}\n"}, {"default": null, "type": "cv", "name": "average", "description": "The average of {\\t input1} and {\\t input2}\n"}, {"default": null, "type": "cv", "name": "maximum", "description": "The maximum of {\\t input1} and {\\t input2}\n"}, {"default": null, "type": "cv", "name": "minimum", "description": "The minimum of {\\t input1} and {\\t input2}\n"}, {"default": null, "type": "cv", "name": "negation", "description": "$- {\\t input1}$\n"}, {"default": null, "type": "cv", "name": "reciprocal", "description": "$1\\ /\\ {\\t input1}$. If {\\t input1} is zero, a very large number\nis being output, while the sign is being kept.\n"}, {"default": null, "type": "cv", "name": "amount", "description": "The absolute value of {\\t input1}\n(i.e. $-  {\\t input1}$ if ${\\t input1} < 0$, else {\\t input1})\n"}, {"default": null, "type": "cv", "name": "sine", "description": "The sine of {\\t input1} in a way, the input range of 0.0 \\dots\\ 1.0\ngoes exactly through one wave cycle. Or more mathematically expressed:\n$sin(2\\pi \\times {\\t input1})$.\n"}, {"default": null, "type": "cv", "name": "cosine", "description": "The cosine of {\\t input1} in a way, the input range of 0.0 \\dots\\ 1.0\ngoes exactly through one wave cycle. Or more mathematically expressed:\n$cos(2\\pi \\times {\\t input1})$.\n"}, {"default": null, "type": "cv", "name": "square", "description": "${\\t input1}^2$\n"}, {"default": null, "type": "cv", "name": "root", "description": "$\\sqrt{\\t input1}$. Please note that you cannot compute the square\nroot of a negative number. In order to output something useful anyway,\nthe result will be $- \\sqrt{- {\\t input1}}$, if ${\\t input1} < 0$.\n"}, {"default": null, "type": "cv", "name": "logarithm", "description": "The natural logarithm of {\\t input1}: $ln\\ _{\\t input1}$. The\nlogarithm is only defined for positive numbers. {\\t mathcircuit}\nbehaves like this:\n\n\\begin{itemize}\n\\item If ${\\t input1} = 0$, a negative very large number is output.\n\\item If ${\\t input2} < 0$, $- ln\\ _{- {\\t input1}}$ is output.\n\\end{itemize}\n"}, {"default": null, "type": "cv", "name": "round", "description": "The integer number nearest to {\\t input1}\n"}, {"default": null, "type": "cv", "name": "floor", "description": "The largest integer number that is not greater than {\\t input1}\n"}, {"default": null, "type": "cv", "name": "ceil", "description": "The smallest integer number that is not less than {\\t input1}\n"}], "presets": 0}, "firefacecontrol": {"category": "midi", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"count": 16, "start_at": 1, "name": "outputlevel1 ... outputlevel16", "default": null, "prefix": "outputlevel", "type": "fraction", "description": ""}, {"default": "1", "type": "integer", "name": "mainoutput", "description": ""}, {"count": 2, "start_at": 1, "name": "phonesoutput1, phonesoutput2", "default": null, "prefix": "phonesoutput", "type": "integer", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix1in1 ... outputmix1in16", "default": null, "prefix": "outputmix1in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix2in1 ... outputmix2in16", "default": null, "prefix": "outputmix2in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix3in1 ... outputmix3in16", "default": null, "prefix": "outputmix3in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix4in1 ... outputmix4in16", "default": null, "prefix": "outputmix4in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix5in1 ... outputmix5in16", "default": null, "prefix": "outputmix5in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmixjin1 ... outputmixjin16", "default": null, "prefix": "outputmixjin", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix7in1 ... outputmix7in16", "default": null, "prefix": "outputmix7in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix8in1 ... outputmix8in16", "default": null, "prefix": "outputmix8in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix9in1 ... outputmix9in16", "default": null, "prefix": "outputmix9in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix10in1 ... outputmix10in16", "default": null, "prefix": "outputmix10in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix11in1 ... outputmix11in16", "default": null, "prefix": "outputmix11in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix12in1 ... outputmix12in16", "default": null, "prefix": "outputmix12in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix13in1 ... outputmix13in16", "default": null, "prefix": "outputmix13in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix14in1 ... outputmix14in16", "default": null, "prefix": "outputmix14in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix15in1 ... outputmix15in16", "default": null, "prefix": "outputmix15in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "outputmix16in1 ... outputmix16in16", "default": null, "prefix": "outputmix16in", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "postfader1 ... postfader16", "default": null, "prefix": "postfader", "type": "gate", "description": ""}, {"count": 16, "start_at": 1, "name": "pan1 ... pan16", "default": null, "prefix": "pan", "type": "fraction", "description": ""}, {"count": 16, "start_at": 1, "name": "unmute1 ... unmute16", "default": null, "prefix": "unmute", "type": "fraction", "description": ""}, {"default": null, "type": "trigger", "name": "update", "description": ""}], "description": "This experimental circuit allows you to control the most\nimport volumes and mixes of an RME Fireface audio interface.\nIt's also a perfect match for the M4 motor fader units.\n\n\nDas Format f\u00fcr die Control-Change-Befehle ist:\nBx yy zz\nx = MIDI channel\nyy = control number\nzz = value\nDie erste Reihe in TotalMix wird adressiert \u00fcber MIDI Kan\u00e4le 1 bis 4, Reihe 2 \u00fcber Kan\u00e4le 5 bis\n8 und Reihe 3 \u00fcber Kan\u00e4le 9 bis 12.\nBenutzt werden 16 Controller-Nummern, und zwar die Nummern 102 bis 117 (= hex 66 bis 75).\nMit diesen 16 Controllern (= Fadern) und jeweils 4 MIDI-Kan\u00e4len pro Reihe lassen sich bis zu\n64 Fader pro Reihe adressieren (wie es bei der HDSPe MADI erforderlich ist)\n\n\n\nMapping der Outputs Beim Fireface UFX + (genauer gesagt TotalMix)\n\nDie Levels der Outputs (dritte Reihe im Totalmix) werden angesprochen \u00fcber\ndie Channel 9, 10, 11 und 12 jeweils \u00fcber die CCs 102 bis 117.  Das gibt\ndann 4 mal 16 Kan\u00e4le, also 64 Fader.\n\nHierbei gibt es eine interne festgelegte physikalische Reihenfolge, welche\n*nicht* derjenigen in TotalMix entspricht. Dort sind n\u00e4mlich die Main-\nund Phoneoutputs ausgeklinkt und erscheinen rechts. Die Stellen, an denen\nsie sich eigentlich einreihen, sind im Totalmix nicht ersichtlich.\n\nDann muss man wissen, dass bei der Zuordnung der CCs zu den Fadern noch\nber\u00fccksichtigt wird, welche Fader man im Totalmix ausgeblendet hat. Diese\nwerden n\u00e4mlich \u00fcbersprungen!\n\nBei Stereogruppierungen ist dann jeweils ein CC zwar belegt, aber sinnlos. Denn\nhier ist dann CC und CC+1 jeweils gleichberechtigt und macht das gleiche.\nAlso darf man nur den ersten der beiden verwenden.\n\nWenn man also im Circuit 16 Outputs steuern kann, sind das nicht unbedingt\n16 Fader sondern genau gesagt 16 Monospuren, deren Fader man bewegen kann.\nWenn alle Stereo sind, w\u00e4ren das also letzlich nur 8 Fader.\nWir *k\u00f6nnten* vielleicht einen Sondermodus machen, wo man das deklarieren\nkann oder so.\n\nBeispiel:\n\nChannel 9\n  102: AN 1\n  103: AN 2\n  104: AN 3\n  105: AN 4\n  106: AN 5\n  107: AN 6\n  108: AN 7\n  109: AN 8\n  110: Phone 1\n  111: (auch Phone 1, sinnlos)\n  112: Phone 2\n  113: (auch Phone 2, sinnlos)\n  114: AES Left\n  115: AES Right\n  116: ADAT 1\n  117: ADAT 2\n\nDie Outputs Main und Phone spielen eine Sonderrolle. Denn Main\nwird f\u00fcr Pre/Post-Fader gebraucht. Und Phone, weil hier Pre/Post\nund auch Mute nicht wirkt.", "title": " Control a RME Fireface interface (experimental)", "outputs": [], "presets": 0}, "euklid": {"category": "sequencing", "inputs": [{"default": "unpatched", "type": "gate", "name": "clock", "description": "Patch a clock signal here. It does not need to be steady --\neven if this is the most usual application. Note: this input is classified\nas a \\gatesymbol gate input, since the length of the gate is being\npreserved when forwarded to {\\t output} and {\\t offbeats}.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the pattern to the start\n"}, {"default": "unpatched", "type": "cv", "name": "outputsignal", "description": "Usually on active steps {\\t euklid} just lets the original\ninput clock get through to the output. If this parameter is\nused, it will be sent to the output on active steps instead.\nThe easiest application is just setting it to {\\t 1}.\nThe output will then become {\\t 1} the whole time while\nthe current step is active. This is useful if you want to\nuse {\\t euklid} as modulation CV rather than as trigger.\n"}, {"default": "16", "type": "integer", "name": "length", "description": "The length of a pattern. This is interpreted as an integer number,\nwhich must be greater than 0. If it is not then {\\t 1} is assumed.\nIf you CV control the length, use multiplication. The maximum accepted\nlength is 64.\n"}, {"default": "5", "type": "integer", "name": "beats", "description": "The number of active beats that should be distributed amongst\nthe {\\t length} steps. If that number is greater than {\\t length},\nit is capped to that number.\n"}, {"default": "0", "type": "integer", "name": "offset", "description": "rotates or shifts the pattern by that number of steps. This number\ncan be positive or negative.\n"}], "description": "This circuit creates trigger patterns according to the\nwell-known {\\it Euclidean rhythms}. The pattern is described\nby three numbers:\n\n\\begin{itemize}\n\\item The number of steps in the pattern\n\\item The number of beats in the pattern\n\\item An offset for shifting the beats forward\n\\end{itemize}\n\nThe number of beats are distributed as evenly as possible in\nthe pattern -- but of course are all placed precisely on clock\nbeats. Here are a few examples of various patterns:\n\n\\bgroup\n\\renewcommand{\\arraystretch}{1.4}\n\\def\\beat{\\mbox{\\hspace{-0.6mm}\\quaver}}\n\\def\\begineuklid{\\vspace{-3mm}\\begin{tabular}{|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|}\\hline}\n\\def\\endeuklid{\\\\ \\hline \\end{tabular}\\vspace{2mm}}\n\nlength: 16, beats: 4, offset: 0\n\n\\begineuklid \\beat &  &  &  & \\beat &  &  &  & \\beat &  &  &  & \\beat &  &  & \\endeuklid\n\nlength: 16, beats: 5, offset: 0\n\n\\begineuklid \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\endeuklid\n\nlength: 16, beats: 5, offset: 1\n\n\\begineuklid  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  & \\endeuklid\n\nlength: 16, beats: 11, offset: 0\n\n\\begineuklid \\beat & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat & \\endeuklid\n\nlength: 13, beats: 5, offset: 0\n\n\\begineuklid \\beat &  & \\beat &  &  & \\beat &  & \\beat &  &  & \\beat &  & \\endeuklid\n\nlength: 13, beats: 5, offset: 1\n\n\\begineuklid  & \\beat &  & \\beat &  &  & \\beat &  & \\beat &  &  & \\beat & \\endeuklid\n\nlength: 4, beats: 2, offset: 1\n\n\\begineuklid  & \\beat &  & \\beat\\endeuklid\n\n\\egroup\n\nHere is an example without CV control:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = 5}    beats   = 5\n\\immediate\\write\\patchexamples{    offset  = 0}    offset  = 0\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nNow let's change that in order to make the beats controllable by the pot\n{\\t P1.1}. Please note how the pot range is being changed from the default 0~\\dots~1\nto the necessary 1~\\dots~16 by using a factor of 15 and an offset of 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = P1.1 * 15 + 1}    beats   = P1.1 * 15 + 1\n\\immediate\\write\\patchexamples{    offset  = 0}    offset  = 0\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nBy the way: Since the default for {\\t length} is {\\t 16} and for {\\t offset}\n{\\t 0} you can drop those two lines if you like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    beats   = P1.1 * 15 + 1}    beats   = P1.1 * 15 + 1\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\n\\subsubsection*{Offbeats}\n\nThe output {\\t offbeats} does the exact opposite of {\\t outputs}:\nit triggers at those clock beats where {\\t output} does not. So\nat any given clock tick exactly either {\\t output} or {\\t offbeats}\ntriggers.\n\n\\subsubsection*{Gate length}\n\nThe length of the output gate is the same as that of the input gate.\nAlso the exact voltage from the input is copied to the output while\nthe current step is active.\n\n\\clearpage", "title": " Euclidean rhythm generator", "outputs": [{"default": null, "type": "gate", "name": "output", "description": "Output of the {\\bf beatss} in the current pattner.\nThe gate length is directly taken from\nthe input clock -- just as the voltage.\n"}, {"default": null, "type": "gate", "name": "offbeats", "description": "Here those impulses will be output where there is {\\it no}\nbeat in the pattern.\n"}], "presets": 0}, "notchedpot": {"category": "ui", "inputs": [{"default": null, "type": "fraction", "name": "pot", "description": "Wire your pot here, e.g. {\\t P1.1}\n"}, {"default": "0.1", "type": "cv", "name": "notch", "description": "Optionally set the notch size, if you do not like the default of {\\t 0.1}.\nThe maximum allowed value is {\\t 0.5}. Greater values will be reduced to that.\n"}], "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit {\\t pot}\n(see page \\pageref{pot}). {\\t pot} can do all {\\t notchedpot} can do and much\nmore. So {\\t notchedpot} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis little circuit simulates a potentiometer with a notch at the center.\nIt helps you exactly selecting the center position by defining a range\nthat is considered to be the center. This range is called ``notch'' and\ndefaults to 10\\% of the available range. You can set the size of the notch\nvia the {\\t notch} input. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notchedpot]}[notchedpot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 15%}    notch    = 15%\n\\immediate\\write\\patchexamples{    output   = _ACTIVITY}    output   = _ACTIVITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    activity = _ACTIVITY}    activity = _ACTIVITY\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nFor a second use case there is the output {\\t bipolar}. That converts\na normal pot into one with range from -1.0 to 1.0. This example also\nshows how to disable the notch, if you do not need it here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notchedpot]}[notchedpot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 0}    notch    = 0\n\\immediate\\write\\patchexamples{    bipolar  = O1 # Send @10V ... +10V to O1}    bipolar  = O1 # Send -10V ... +10V to O1\n\\end{droidini}", "title": " Helper circuit for pots (OBSOLETE)", "outputs": [{"default": null, "type": "fraction", "name": "output", "description": "Your pot output comes here. It still goes from {\\t 0.0} to {\\t 1.0}.\n"}, {"default": null, "type": "cv", "name": "bipolar", "description": "Optional output with a range from -1.0 to 1.0, where the center notch\nis at 0.0.\n"}, {"default": null, "type": "cv", "name": "absbipolar", "description": "A variation of {\\t bipolar} that always outputs a positive value,\ni.e. the pot will go 1 ... 0.5 ... 0 ... 0.5 ... 1\n"}, {"default": null, "type": "cv", "name": "lefthalf", "description": "This output allows you to split the pot into two hemispheres. Here\nyou get 1.0 ... 0.0 while the pot is in the left half. In the middle\nand right of it you always get 0.\n"}, {"default": null, "type": "cv", "name": "righthalf", "description": "This is the same but for the right half. It outputs 0 while\nthe pot is in the left half and 0.0 ... 1.0 from the middle to the\nfully right position.\n"}, {"default": null, "type": "cv", "name": "lefthalfinv", "description": "This outputs 1.0 - {\\t lefthalf}, i.e. the value range\n0.0 ... 1.0 ... 1.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right.\n"}, {"default": null, "type": "cv", "name": "righthalfinv", "description": "This outputs 1.0 - {\\t righthalf}, i.e. the value range\n1.0 ... 1.0 ... 0.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right.\n"}], "presets": 0}, "dac": {"category": "logic", "inputs": [{"count": 12, "start_at": 1, "name": "bit1 ... bit12", "default": "unpatched", "prefix": "bit", "type": "gate", "description": "The 12 bit input bits. {\\t bit1} is the MSB -- the most significant\nbit. The LSB (least significant bit) is the highest input that\nyou actually patch.\n"}, {"default": "0", "type": "cv", "name": "minimum", "description": "This sets the lower bound of the output range, i.e. the\nvalue that the bit sequence {\\t 000000000000} will produce.\n"}, {"default": "1", "type": "cv", "name": "maximum", "description": "This sets the upper bound of the output value, i.e. the\nvalue that the bit sequence {\\t 111111111111} will produce.\n"}], "description": "This circuit converts a binary representation of up to 12 bits into an output\nvalue in a given range. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[dac]}[dac]\n\\immediate\\write\\patchexamples{    bit1 = I1}    bit1 = I1\n\\immediate\\write\\patchexamples{    bit2 = I2}    bit2 = I2\n\\immediate\\write\\patchexamples{    bit3 = I3}    bit3 = I3\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nIn this example three bits are being used. Three bits can represent\na number from 0 to 7. These are mapped to the input range from 0\nto 1 (or 0~V to 10~V) in the following way:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\n{\\t bit1} & {\\t bit2} & {\\t bit3} & bit value & output \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0}    & 0.000 \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1}    & 0.143 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2}    & 0.286 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3}    & 0.429 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4}    & 0.571 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5}    & 0.714 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6}    & 0.857 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7}    & 1.000 \\\\ \\hline\n\\end{tabular}}\n\nIn other words: this circuit will convert three different gate inputs\ninto one analog output value. {\\t bit1} has the most influence, {\\t but3}\nthe least.\n\nThe normal output range is 0 to 1 (i.e. 10~V) per default, but you can change\nthat with the parameters {\\t minimum} and {\\t maximum}.  For example you\ncould have the three bits mapped to just the range of 0.1 to 0.5:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[dac]}[dac]\n\\immediate\\write\\patchexamples{    bit1 = I1}    bit1 = I1\n\\immediate\\write\\patchexamples{    bit2 = I2}    bit2 = I2\n\\immediate\\write\\patchexamples{    bit3 = I3}    bit3 = I3\n\\immediate\\write\\patchexamples{    minimum = 0.1 # 1V}    minimum = 0.1 # 1V\n\\immediate\\write\\patchexamples{    maximum = 0.5 # 4V}    maximum = 0.5 # 4V\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow the table looks like this:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\n{\\t bit1} & {\\t bit2} & {\\t bit3} & bit value & output \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0}    & 0.100 \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1}    & 0.157 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2}    & 0.214 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3}    & 0.271 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4}    & 0.329 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5}    & 0.386 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6}    & 0.443 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7}    & 0.500 \\\\ \\hline\n\\end{tabular}}\n\nIf you use more of the {\\t bit}-outputs you get more resolution.\nFor example if you use {\\t bit1} ... {\\t bit8}, the total range\nwill be divided into 256 possible output values. The maximum is\n12 bits. Since bit~1 is the most significant bit, adding more\nand more bits will not change the influence of the already\nused bits.\n\nPlease also have a look at the circuit {\\t adc} (see page \\pageref{adc},\nwhich does the exact opposite!\n\n\\clearpage", "title": " DA Converter with 12 bits", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Output signal.\n"}], "presets": 0}, "fourstatebutton": {"category": "ui", "inputs": [{"default": null, "type": "trigger", "name": "button", "description": "The button.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A positive trigger here will reset the button to the first state.\n"}, {"count": 4, "start_at": 1, "name": "value1 ... value4", "default": null, "prefix": "value", "type": "cv", "description": "The values that {\\t output} should get when the four\nvarious states are active.\n"}, {"default": null, "type": "integer", "name": "startvalue", "description": "By setting this to {\\t 0}, {\\t 1}, {\\t 2} or {\\t 3} you\nset the initial state of the button when the \\droid is powered up to\nstate 1, 2, 3 or 4. It also disabled the automatic saving of the button's\nstate in the \\droid's internal flash memory.\n"}], "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit {\\t\nbutton} (see page \\pageref{button}). {\\t button} can do all {\\t fourstatebutton}\ncan do and much more. So {\\t fourstatebutton} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis circuit converts one of the push buttons of your controllers into\na button that switches through up to four different states. This is very\nsimilar to {\\t togglebutton} but that supports just two states.\n\nThe LED will be off in state 1, 100\\% bright in state 4 and somewhere\nin between in the other two states.\n\nThe use case is to have a way to manually switch through three or four\noptions. The following example implements an octave switch for a VCO. The\nbutton steps you through the sequence 0 $\\rightarrow$ 1 $\\rightarrow$\n2 $\\rightarrow$ 3 $\\rightarrow$ 0 octaves. The pitch is being read from {\\t I1}\nand output again at {\\t O1} -- possibly shifted by up to 3 octaves (3~V).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fourstatebutton]}[fourstatebutton]\n\\immediate\\write\\patchexamples{    button  = B1.1}    button  = B1.1\n\\immediate\\write\\patchexamples{    led     = L1.1}    led     = L1.1\n\\immediate\\write\\patchexamples{    value1  = I1 + 0V}    value1  = I1 + 0V\n\\immediate\\write\\patchexamples{    value2  = I1 + 1V}    value2  = I1 + 1V\n\\immediate\\write\\patchexamples{    value3  = I1 + 2V}    value3  = I1 + 2V\n\\immediate\\write\\patchexamples{    value4  = I1 + 3V}    value4  = I1 + 3V\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nOf course the values need not be fixed values. The next examples shows\nyou a \\droid patch where the button is used to cycle through four\ndifferent wave forms of an LFO and send that to output {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 2}    hz       = 2\n\\immediate\\write\\patchexamples{    square   = _W1}    square   = _W1\n\\immediate\\write\\patchexamples{    triangle = _W2}    triangle = _W2\n\\immediate\\write\\patchexamples{    sawtooth = _W3}    sawtooth = _W3\n\\immediate\\write\\patchexamples{    sine     = _W4}    sine     = _W4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[fourstatebutton]}[fourstatebutton]\n\\immediate\\write\\patchexamples{    button   = B1.1}    button   = B1.1\n\\immediate\\write\\patchexamples{    led      = L1.1}    led      = L1.1\n\\immediate\\write\\patchexamples{    value1   = _W1}    value1   = _W1\n\\immediate\\write\\patchexamples{    value2   = _W2}    value2   = _W2\n\\immediate\\write\\patchexamples{    value3   = _W3}    value3   = _W3\n\\immediate\\write\\patchexamples{    value4   = _W4}    value4   = _W4\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}", "title": " Button switching through 4 states (OBSOLETE)", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Depending on the current state of the button here the\nvalue of {\\t input1}, {\\t input2}, {\\t input3} or {\\t input4}\nwill be copied.\n"}, {"default": null, "type": "fraction", "name": "led", "description": "The LED in the button\n"}], "presets": 0}, "bernoulli": {"category": "clock", "inputs": [{"default": "0", "type": "gate", "name": "input", "description": "Send gate or trigger signals here.\n"}, {"default": "0.5", "type": "bipolar", "name": "distribution", "description": "This controls the probability of a gate to be forwarded to\n{\\t output1}. A value of {\\t 0.5} means 50\\%.\n"}], "description": "This circuit implements a ``bernoulli gate''. For each gate or\ntrigger received at {\\t input} there is made a random decision\nof whether to forward that gate to {\\t output1} or {\\t output2}.\nThe probability for each of the outputs can be shifted with the\nparameter {\\t distribution}. It determines the probability of\na gate signal to go to {\\t output1}.\n\nExample:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[bernoulli]}[bernoulli]\n\\immediate\\write\\patchexamples{    input        = G1}    input        = G1\n\\immediate\\write\\patchexamples{    distribution = P1.1}    distribution = P1.1\n\\immediate\\write\\patchexamples{    output1      = G2}    output1      = G2\n\\immediate\\write\\patchexamples{    output2      = G4}    output2      = G4\n\\end{droidini}\n\nNote: each time a positive trigger edge is seen at {\\t input}\na new random decision is made for which output to use.\nFrom now on that chosen output gets an exact copy of the input\nsignal -- even if it is not a simple trigger signal but something\nmore complex like an envelope. The other output will send 0~V.", "title": " Random gate distributor", "outputs": [{"default": null, "type": "gate", "name": "output1", "description": "Gates from input are forwarded here if the random decision was\nin favour of output 1.\n"}, {"default": null, "type": "gate", "name": "output2", "description": "Gates from input are forwarded here if the random decision was\nin favour of output 2.\n"}], "presets": 0}, "transient": {"category": "modulation", "inputs": [{"default": "0", "type": "cv", "name": "start", "description": "Start value of the transient\n"}, {"default": "1", "type": "cv", "name": "end", "description": "Target value of the transient\n"}, {"default": "1", "type": "cv", "name": "duration", "description": "Duration: if the {\\t clock} input is used, it is in clock ticks.\nOtherwise it is in seconds. A negative duration will be treated as\nzero. And a zero duration will make the output always be at {\\t\nend} level.\n"}, {"default": "0", "type": "gate", "name": "loop", "description": "If this is set to {\\t 1}, the transient will start over\nagain as soon as it reaches the end.\n"}, {"default": "0", "type": "gate", "name": "pingpong", "description": "If this set to {\\t 1}, the transient will start moving\nbackwards towards the start when it has reached end. It will swing\nback and forth, in fact looping infinitely.\n"}, {"default": "0", "type": "gate", "name": "freeze", "description": "while this is set to {\\t 1}, the transient it frozen at its\ncurrent position.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here will immediately set the transient back to\nits start value.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "If you patch a clock here, the duration will be set in terms\nof clock ticks, not of seconds. This needs to be a steady clock\nin order to get predictable results.\n"}], "description": "This circuit creates transients. It outputs a voltage that starts at a start\nvalue and goes linearly to an end value. The duration of that transition is\neither set in seconds or specified as a number of clock ticks. This circuit\nis built in a way that very long transients are possible, even several days,\nweeks, months, years or whatever you like.\n\nHere is a simple example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 1V}    start = 1V\n\\immediate\\write\\patchexamples{    end = 3V}    end = 3V\n\\immediate\\write\\patchexamples{    duration = 600}    duration = 600\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nHere the duration is meant to be 600 seconds (10 minutes). So at the beginning {\\t O1} will\nbe at 1~V. Then it rises slowly until after ten minutes\nit reaches 3~V. There it stays forever.\n\nThere are two ways of restarting it again. Either you send a trigger\nto {\\t reset} or you set {\\t loop} to {\\t 1}. When {\\t loop} is\nactive, the transient will start over at {\\t start} immediately when\nit reaches {\\t end}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 1V}    start = 1V\n\\immediate\\write\\patchexamples{    end = 3V}    end = 3V\n\\immediate\\write\\patchexamples{    duration = 600}    duration = 600\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    reset = G1}    reset = G1\n\\immediate\\write\\patchexamples{    loop = 1}    loop = 1\n\\end{droidini}\n\nAs an alternative to seconds you can specify the length in terms of clock\nticks. This needs a steady clock signal patched into the {\\t clock} input.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 0.2}    start = 0.2\n\\immediate\\write\\patchexamples{    end = 0.7}    end = 0.7\n\\immediate\\write\\patchexamples{    duration = 32}    duration = 32\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nHere the duration of one transient is exactly 32 clock ticks. This makes\nit simpler to exactly align a transient with a musical structure of a song\nor the like.\n\n\\subsubsection*{Changes while in the air}\n\nAs {\\t start}, {\\t end} and {\\t duration} are CV inputs, they might change\nwhile the transient is running. This is how {\\t transient} behaves in such\nsituations:\n\nThe {\\t start} value is just taken into account whenever the transient starts.\nthis is:\n\n\\begin{itemize}\n\\item When the \\droid starts\n\\item When there is a trigger at {\\t reset}\n\\item When the transient reaches the end and {\\t loop} is on.\n\\end{itemize}\n\nWhenever that happens, the current output level is set to {\\t start}. Also\nthe output {\\t phase} is set to 0. Phase is a kind of internal clock that\nmeasures which part of the transient has been run through already.\n\nAt any given time {\\t transient} assumes that the {\\it phase} times the\nduration equals the time left. And the distance to go in the remaining time\nis the current distance from the current output level to the end. These two\nvalues directly translate into a slope.  This slope now determines how fast\nthe output level is moving and into which direction.\n\nFrom this follows:\n\n\\begin{itemize}\n\\item When you make the duration longer in-flight, the speed of change will get slower.\n\\item When you change {\\t start} in-flight, nothing happens.\n\\item When you change {\\t end} in-flight to a value that is ``farer'' away from the\ncurrent level, the speed of change increases.\n\\item If you change {\\t end} to be the current level of the transient,\nit seems to stop, but in fact the slope is just zero and it\nstill lasts until the duration is over.\n\\item The output level is always smooth. No sudden steps.\nWith one exception: When the transient resets to its start value.\n\\end{itemize}\n\nIn pingpong mode (see the table of inputs for details) this changes accordingly. While\nthe transient is on its way back, consider {\\t start} and {\\t end} exchanged.\n\n\\clearpage", "title": " Transient generator", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "Here comes the current value of the transient.\n"}, {"default": null, "type": "cv", "name": "phase", "description": "This output reflects the current phase of the transient. It behaves\nas if {\\t start} would be 0 and {\\t end} would be 1.\n"}, {"default": null, "type": "gate", "name": "endoftransient", "description": "When loop and pingpong is off, this output goes to {\\t 1} when\nthe transient has reached the end -- and stays there.\nIn loop mode just a short trigger is sent.\nIn pingpong mode that trigger is not sent when the transient has\nreach the {\\t end}-value, but when it is back at start\n(i.e. after one full cycle).\n"}], "presets": 0}, "buttongroup": {"category": "ui", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": "1", "type": "integer", "name": "minactive", "description": "Minimum number of active buttons. If you set this to {\\t 2}, then\nit is guaranteed that always at least 2 buttons are active. If you\nset this to {\\t 0}, then it is possible to switch off all buttons.\nThe {\\t output} will be set to {\\t 0.0} in that case.\n"}, {"default": "1", "type": "integer", "name": "maxactive", "description": "Maximum number of active buttons. It is an error to set this to\n{\\t 0}, since this would make this circuit useless.\n"}, {"count": 32, "start_at": 1, "name": "button1 ... button32", "default": null, "prefix": "button", "type": "trigger", "description": "\\nth1 ... \\nth8 button of the group. Any positive trigger seen here will\ntoggle this button. And another button might go on or off in\norder to make sure that the number of active buttons is withing the\nallowed range.\n"}, {"count": 32, "start_at": 1, "name": "value1 ... value32", "default": "unpatched", "prefix": "value", "type": "cv", "description": "Value that will be sent to the output if the \\nth1 ...\n\\nth{32} button is active. These inputs default to {\\t 0} for\n{\\t value1}, {\\t 1} for {\\t value2} and so on and {\\t 31} for {\\t value32}.\n"}], "description": "This utility circuit combines a number of push buttons into a group that\nbehave as a unit. One classical operation is to form a group of ``radio\nbuttons''. This means that at any time just one of these buttons is on and\nall others are off.\n\nThe following example uses four buttons for selecting one of the voltages 0~V,\n1V, 2V and -1V. This voltage is then being sent to the output jack. This could\nbe used as an octave switch or the like.  The four buttons {\\t B2.1} ... {\\t B2.4}\nare grouped in a way that just one button is on and the others are off. The\nfour selectable voltages are assigned to one button each. The value of the\ncurrently active button is being sent to the output. The outputs {\\t output1}\n... {\\t output4} will be set to 1 if their corresponding button is active and\nare used for controlling the LEDs within the buttons.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1   = B2.1}    button1   = B2.1\n\\immediate\\write\\patchexamples{    button2   = B2.2}    button2   = B2.2\n\\immediate\\write\\patchexamples{    button3   = B2.3}    button3   = B2.3\n\\immediate\\write\\patchexamples{    button4   = B2.4}    button4   = B2.4\n\\immediate\\write\\patchexamples{    led1      = L2.1 # LED in button 2.1}    led1      = L2.1 # LED in button 2.1\n\\immediate\\write\\patchexamples{    led2      = L2.2}    led2      = L2.2\n\\immediate\\write\\patchexamples{    led3      = L2.3}    led3      = L2.3\n\\immediate\\write\\patchexamples{    led4      = L2.4}    led4      = L2.4\n\\immediate\\write\\patchexamples{    value1    = 0V}    value1    = 0V\n\\immediate\\write\\patchexamples{    value2    = 1V}    value2    = 1V\n\\immediate\\write\\patchexamples{    value3    = 2V}    value3    = 2V\n\\immediate\\write\\patchexamples{    value4    = @1V}    value4    = -1V\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\nIf you set {\\t maxactive} to a number greater than one, more than one button\ncan be active at the same time. If this is the case then the sum of the\nvalues of all active buttons will be sent to the output. Here is an example,\nwhere three buttons are being used for selecting a number between 0 and 7 by\nselecting any combination of the buttons ``1'', ``2'', and ``4''.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1   = B2.1}    button1   = B2.1\n\\immediate\\write\\patchexamples{    button2   = B2.2}    button2   = B2.2\n\\immediate\\write\\patchexamples{    button3   = B2.3}    button3   = B2.3\n\\immediate\\write\\patchexamples{    led1      = L2.1 # LED in button 2.1}    led1      = L2.1 # LED in button 2.1\n\\immediate\\write\\patchexamples{    led2      = L2.2}    led2      = L2.2\n\\immediate\\write\\patchexamples{    led3      = L2.3}    led3      = L2.3\n\\immediate\\write\\patchexamples{    value1    = 1}    value1    = 1\n\\immediate\\write\\patchexamples{    value2    = 2}    value2    = 2\n\\immediate\\write\\patchexamples{    value3    = 4}    value3    = 4\n\\immediate\\write\\patchexamples{    minactive = 0 # allow all buttons to be off}    minactive = 0 # allow all buttons to be off\n\\immediate\\write\\patchexamples{    maxactive = 3 # allow all buttons to be on}    maxactive = 3 # allow all buttons to be on\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\n\\subsubsection*{Overlaying buttons}\n\nWhen you make more complex \\droid patches, it's likely that you might run\nout of buttons. In such a situation you can {\\it overlay} buttons with multiple\nfunctions and use other buttons to switch between these layers.\n\nConsider the following example: We have one P2B8 controller. The buttons\n1 and 2 should switch between the layers {\\it root note} and {\\it scale}.\nWe do this with a simple button group (you could also use a {\\t button}\ncircuit and save one button, but for simplicity we allow us two here):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nThe remaining six buttons select either one of six possible root notes or\none of six possible scales (adhering to the scheme of the {\\t minifonion}\ncircuit, see page \\pageref{minifonion}). Please note how we have added a\n{\\t select} input at each of both circuits to make sure that at any given\ntime exactly one of the two groups is selected:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    select = L1.1 # be active only when L1.1 is active}    select = L1.1 # be active only when L1.1 is active\n\\immediate\\write\\patchexamples{    button1 = B1.3}    button1 = B1.3\n\\immediate\\write\\patchexamples{    button2 = B1.4}    button2 = B1.4\n\\immediate\\write\\patchexamples{    button3 = B1.5}    button3 = B1.5\n\\immediate\\write\\patchexamples{    button4 = B1.6}    button4 = B1.6\n\\immediate\\write\\patchexamples{    button5 = B1.7}    button5 = B1.7\n\\immediate\\write\\patchexamples{    button6 = B1.8}    button6 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.3}    led1 = L1.3\n\\immediate\\write\\patchexamples{    led2 = L1.4}    led2 = L1.4\n\\immediate\\write\\patchexamples{    led3 = L1.5}    led3 = L1.5\n\\immediate\\write\\patchexamples{    led4 = L1.6}    led4 = L1.6\n\\immediate\\write\\patchexamples{    led5 = L1.7}    led5 = L1.7\n\\immediate\\write\\patchexamples{    led6 = L1.8}    led6 = L1.8\n\\immediate\\write\\patchexamples{    value1 = 0  # C}    value1 = 0  # C\n\\immediate\\write\\patchexamples{    value2 = 2  # D}    value2 = 2  # D\n\\immediate\\write\\patchexamples{    value3 = 5  # F}    value3 = 5  # F\n\\immediate\\write\\patchexamples{    value4 = 7  # G}    value4 = 7  # G\n\\immediate\\write\\patchexamples{    value5 = 9  # A}    value5 = 9  # A\n\\immediate\\write\\patchexamples{    value6 = 10 # Bb}    value6 = 10 # Bb\n\\immediate\\write\\patchexamples{    output = _ROOT}    output = _ROOT\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    select = L1.2 # be active only when L1.2 is active}    select = L1.2 # be active only when L1.2 is active\n\\immediate\\write\\patchexamples{    button1 = B1.3}    button1 = B1.3\n\\immediate\\write\\patchexamples{    button2 = B1.4}    button2 = B1.4\n\\immediate\\write\\patchexamples{    button3 = B1.5}    button3 = B1.5\n\\immediate\\write\\patchexamples{    button4 = B1.6}    button4 = B1.6\n\\immediate\\write\\patchexamples{    button5 = B1.7}    button5 = B1.7\n\\immediate\\write\\patchexamples{    button6 = B1.8}    button6 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.3}    led1 = L1.3\n\\immediate\\write\\patchexamples{    led2 = L1.4}    led2 = L1.4\n\\immediate\\write\\patchexamples{    led3 = L1.5}    led3 = L1.5\n\\immediate\\write\\patchexamples{    led4 = L1.6}    led4 = L1.6\n\\immediate\\write\\patchexamples{    led5 = L1.7}    led5 = L1.7\n\\immediate\\write\\patchexamples{    led6 = L1.8}    led6 = L1.8\n\\immediate\\write\\patchexamples{    value1 = 1  # major}    value1 = 1  # major\n\\immediate\\write\\patchexamples{    value2 = 6  # dorian minor}    value2 = 6  # dorian minor\n\\immediate\\write\\patchexamples{    value3 = 7  # natural minor}    value3 = 7  # natural minor\n\\immediate\\write\\patchexamples{    value4 = 9  # phrygian minor}    value4 = 9  # phrygian minor\n\\immediate\\write\\patchexamples{    value5 = 10 # diminished scale}    value5 = 10 # diminished scale\n\\immediate\\write\\patchexamples{    value6 = 2  # mixolydian}    value6 = 2  # mixolydian\n\\immediate\\write\\patchexamples{    output = _DEGREE}    output = _DEGREE\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nHere you can patch {\\t \\_ROOT} and {\\t \\_SCALE} to some {\\t minifonion},\n{\\t arpeggio} or other circuit that works with scales.\n\nNow, with the top buttons you can switch between root and scale selection\nand with the remaining six buttons select either the root or the scale.\n\n\n\\clearpage", "title": " Connected buttons", "outputs": [{"count": 32, "start_at": 1, "name": "led1 ... led32", "default": null, "prefix": "led", "type": "gate", "description": "This output will be {on} / 1.0, whenever the \\nth1 ...\n\\nth8 button is active\nand {off} / 0.0 otherwise. Wire this to the LED in the button.\n"}, {"default": null, "type": "cv", "name": "output", "description": "The sum of the values of all active buttons will be sent here.\nif no button is active then {0.0} is being output.\n"}, {"default": null, "type": "trigger", "name": "buttonpress", "description": "Emits a trigger if any button is being pressed\n"}, {"default": null, "type": "trigger", "name": "longpress", "description": "Emits a trigger, when any button is pressed for at least 1.5\nseconds. If this jack is used, {\\t buttonpress} will emit\na signal if the button in question is released before the 1.5\nseconds, not immediately. That way you trigger {\\it either}\nat {\\t buttonpress} or at {\\t longpress}, not at both.\n"}], "presets": 0}, "timing": {"category": "clock", "inputs": [{"default": null, "type": "trigger", "name": "clock", "description": "Patch a steady clock here for this circuit to be of any use\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the internal step counter and restart at\nstep 1.\n"}, {"count": 8, "start_at": 1, "name": "timing1 ... timing8", "default": "unpatched", "prefix": "timing", "type": "cv", "description": "Specifies a {\\it relative} timing for each step...\n"}], "description": "This circuit converts a steady input clock into an output clock\nwith flexible timing modifications. The most common use is a \"swing\"\nfeeling where every second note is delayed. But this circuit\nis much more flexible.\n\nThe length of a timing pattern can be up to eight steps.\nThat means that you can set a different relative time shift\nfor each clock pulse in a sequence of up to eight.\n\nLet's start with a simple swing pattern, which is just\na sequence of two. We assume an external input clock\nat G1 and output the resulting modified clock to G2:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = 0.3}    timing2 = 0.3\n\\end{droidini}\n\nIn this example every second clock pulse is delayed by 30\\% of\none clock tick's duration -- which gives a standard swing\npattern.\n\nCreating a {\\it reverse} swing, where every second pulse\nis {\\it early} is as easy as using a negative number for {\\t timing2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = @0.3}    timing2 = -0.3\n\\end{droidini}\n\nCreating a sequence with an odd number of steps can create rather weird\ngroove patterns. Look at the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = 0.2}    timing2 = 0.2\n\\immediate\\write\\patchexamples{    timing3 = 0.1}    timing3 = 0.1\n\\end{droidini}\n\nNow every second note {\\it of three} is delayed by 20\\% and every third\nnote by 10\\%.\n\nOf course, you can use {\\t timing} in order to create a simple clock\nshift by creating a pattern with just one timing, as well. The following example\nwill shift the input clock {\\it forwards}, so that it always comes a\nbit earlier. This can be used for compensating a slight delay of a master\nclock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = @0.03}    timing1 = -0.03\n\\end{droidini}\n\nNotes:\n\\begin{itemize}\n\\item This circuit needs a steady and stable input clock.\n\\item In order to get a synchronized start together with the rest\nof your patch, it is advisable also to make use of the {\\t reset}\ninput.\n\\end{itemize}", "title": " Shuffle/swing and complex timing generator", "outputs": [{"default": null, "type": "trigger", "name": "output", "description": "Here comes the modified output clock\n"}], "presets": 0}, "midithrough": {"category": "midi", "inputs": [{"default": "0", "type": "gate", "name": "fromusb", "description": "Set this to {\\t 0} if you want to receive data from the\nTRS/DIN jack and {\\t 1} if you want to receive via USB.\n"}, {"default": "0", "type": "gate", "name": "tousb", "description": "Set this to {\\t 0} if you want to send data to the\nTRS/DIN jack and {\\t 1} if you want to send via USB.\n"}], "description": "Use this circuit for forwarding MIDI data from an input to an output. Here is\nan example:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midithrough]}[midithrough]\n\\immediate\\write\\patchexamples{    fromusb = 1 # TRUE, hence USB port for input}    fromusb = 1 # TRUE, hence USB port for input\n\\immediate\\write\\patchexamples{    tousb = 0 # FALSE, hence TRS jack for output}    tousb = 0 # FALSE, hence TRS jack for output\n\\end{droidini}\n\nThis will forward MIDI events from the USB port to the TRS output. Note:\nAll \\circuit{midiin} and \\circuit{midiout} circuits still work, so the\noutput stream on the TRS jack will both contain the original events from\nMIDI-USB and the events you create with your {\\t midiout} circuits.\n\nNotes:\n\\begin{itemize}\n\\item As of now, Sysex messages are not forwarded. Sorry for that. If that's\nbecoming important we might add this feature.\n\\item If you forward from USB to TRS make sure that you do not send more\nthan 3125 bytes per second. TRS cannot output faster. It's limited by the\nMIDI standard. If you send MIDI data faster, some events will get lost.\n\\end{itemize}", "title": " MIDI routing through X7", "outputs": [], "presets": 0}, "copy": {"category": "logic", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "Connect the signal you want to copy here.\n"}, {"default": "unpatched", "type": "cv", "name": "minimum", "description": "This sets a lower limit to the input signal. If it falls below it\nwill be set to this value.\n"}, {"default": "unpatched", "type": "cv", "name": "maximum", "description": "This sets a upper limit to the input signal. If it is above it\nwill be set to this value.\n"}], "description": "This circuit is a simple utility that copies a signal from an input to an\noutput. Since every input generally can be attenuated and offset this can\nbe used for scaling and offsetting a signal on its path.\n\nThe following example outputs the sine wave of the same LFO to {\\t O1}\nand {\\t O2}, where {\\t O2} is being inverted. This is also an example\nof using an output as an input.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 0.5 * P1.1}    hz = 0.5 * P1.1\n\\immediate\\write\\patchexamples{    sine = O1}    sine = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input = O1}    input = O1\n\\immediate\\write\\patchexamples{    inverted = O2}    inverted = O2\n\\end{droidini}", "title": " Copy a signal", "outputs": [{"default": null, "type": "cv", "name": "output", "description": "The resulting signal will be sent here.\n"}, {"default": null, "type": "cv", "name": "inverted", "description": "An inverted version of the signal will be sent here\n(after {\\t min} and {\\t max} has been applied). Inverted means,\nthat it is mirrored within the range of 0 ... 1. For example\nthe inversion of 0.2 is 0.8, the inversion of 0.5 is 0.5 and\nthe inversion of 0.0 is 1.0. If you need a {\\it negated}\nversion, simply multiply the input by -1.0.\n\nIf the signal is negative, the inverted signal will also be negative\nand is now mirrored within the range -1 ... 0. So the inversion\nof -0.8 is -0.2 and so on.\n"}], "presets": 0}, "midifileplayer": {"category": "midi", "inputs": [{"default": "unpatched", "type": "integer", "name": "channel", "description": "Only execute / play commands from a certain MIDI channel.\nThere are 16 MIDI channels. It ranges from {\\t 1}\nto {\\t 16}.\n"}, {"default": "off", "type": "gate", "name": "tuningmode", "description": "If set to {\\t 1}, all pitch outputs will go to the CV\nselected for {\\t tuningpitch} (which defaults to 2~V),\nand all\ngate outputs will play gates at 120 BPM. This helps getting\nall attached voices tuned when working with many voices.\n"}, {"default": "0.2", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "Transposes all output pitches by this value by adding\nthe value. So in order to transpose one octave\ndown, set this input to {\\t -1V} or {\\t -0.1}. Changes in the\ntransposition are immediately reflected, even for currently\nalready active notes.\n"}, {"default": "0", "type": "gate", "name": "holdvelocity", "description": "If this is set to {\\t 1}, the velocity output for a voice\nwill not be affected by note off events. It's just altered\nat the beginning of new notes.\nThe velocity is kept after the note ends.\nThis way during the release phase of an envelope triggered\nby the gate, the original velocity still lasts on. In most cases\nthe note off velocity is set to 0, which would\nimmediately cut off the release phase when the velocity is patched\ninto a VCA.\n"}, {"default": "$\\frac{1}{6}$V", "type": "voltperoctave", "name": "pitchbendrange", "description": "Sets the value to the desired maximum that {\\t pitchbend}\nshould output, and likewise it's negative counterpart at its minimum\nvalue. At the middle position it always outputs 0. This defaults\nto $\\frac{2}{12}$~V, which corresponds to one whole tone. Note:\nsetting this to a negative value is allowed and will invert\npitch bend.\n"}, {"default": "1", "type": "gate", "name": "bendpitch", "description": "When set to {\\t 1} (which is the default), the pitch bend\nwill directly be applied to all output pitches. Alternatively\nyou can set it to {\\t 0} and use the output {\\t pitchbend},\nfor using it elsewhere.\n"}, {"default": "0", "type": "gate", "name": "roundrobin", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t output1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophone. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n"}, {"default": "0", "type": "integer", "name": "voiceallocation", "description": "When the MIDI stream, at any given time, needs to play more notes\nthan you have voices assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|c|l|}\\hline\n{\\t 0} & The oldest note will be cancelled (default) \\\\ \\hline\n{\\t 1} & The new note will not be played and simply be omitted \\\\ \\hline\n{\\t 2} & The lowest note will be cancelled \\\\ \\hline\n{\\t 3} & The highest note will be cancelled \\\\ \\hline\n\\end{tabular}\n\\vspace{2mm}\n"}, {"default": "0", "type": "cv", "name": "notegap", "description": "When your MIDI devices plays a note so ``long'' that it lasts\nexactly until the next note begins -- or if due to a lack of\nused pitch outputs one currently played note has to be replaced\nwith a new one, the {\\t gate} output will have no time to go\nlow for a sufficient time between the two notes. In effect it\nwon't trigger any envelope for the new note but will do a ``legato''.\n\nIf you don't like this, you can use {\\t notegap}. This input specifies\na number of {\\bf milliseconds} that the gate will be forced down\nbefore the new note begins. This has the drawback of introducing some\nlatency, of course! So I suggest that you start with {\\t notegap =\n1} and then check out if your envelope is fast enough to trigger.\nIf not, increase the value.\n\nIf you are using \\droid's own {\\t contour} circuit or trigger something\nelse internally in your patch, you can use {\\t notegap = 0.1}. That is\nsufficient and introduces barely any latency.\nJust a value of {\\t 0.0} keeps the default of the legato mode.\n\nNote: the {\\t notegap} parameter does not affect the {\\t trigger}\noutputs.\n"}, {"count": 4, "start_at": 1, "name": "ccnumber1 ... ccnumber4", "default": "0", "prefix": "ccnumber", "type": "integer", "description": "You can {\\it listen} to up to four CCs (control changes). For example\nif you are interested in the current value of CC\\#17, set\n{\\t ccnumber1 = 17} and use the output {\\t cc1} for getting the value\nof CC 17.\n"}, {"default": "0", "type": "integer", "name": "lowestnote", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n"}, {"default": "127", "type": "integer", "name": "highestnote", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. The ``Notegates'' are not being affected by this bound.\n"}, {"count": 16, "start_at": 1, "name": "note1 ... note16", "default": "unpatched", "prefix": "note", "type": "integer", "description": "Selects up to 16 individual notes for which you can get a\ndedicated gate signal. Per default these values are set to\n{\\t 0} for {\\t note1} (meaning C-2), {\\t 1} for {\\t note2}\n(meaning C$\\sharp$-2) and so on. For each of these notes\nyou get a corresponding gate output (see {\\t notegate1}, {\\t notegate2}, etc.).\nThese gates are high as long as the selected notes are being hold.\nOne application is to use just one {\\t midifileplayer} or {\\t midiin}\ncircuit for sequencing up to 16 drum voices. Another application is\nto use a MIDI keyboard or controller as a button expander -- just\nlike a P2B8 or B32.\n"}, {"default": "1", "type": "integer", "name": "file", "description": "Number of the MIDI file to play. {\\t 7} will select {\\t midi7.mid}.\n"}, {"default": "1", "type": "integer", "name": "track", "description": "Number of the track in the file to play, starting at 1. Empty\ntracks do not count. Any number smaller than 1 will be interpreted\nas one. If the number is too big, the last track in the file\nis played.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "Patch an external clock here and the MIDI file will be played\naccording to that clock. In order to be modular-friendly, this\nis {\\it not} a MIDI clock but one counting the sixteenth, which\nis typically the step resolution of analog sequencers. This clock\nis then internally multiplied in order to create the necessary\nresolution. Note: The input {\\t speed} has no effect when using\nan external clock.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here sets the play back position to the start.\n"}, {"default": "1", "type": "gate", "name": "loop", "description": "When loop mode is active (set to {\\t 1}), the track will start\nover again immediately when it has reached its end. This is the\ndefault. Otherwise playback stops at the end of the track.\n"}, {"default": "unpatched", "type": "integer", "name": "end", "description": "If you set this value, it defines the playing end of the track. This\nis set in quarters as counted from the start. Setting the end beyond the\nend of the track will insert some pause.\n"}, {"default": "1", "type": "cv", "name": "speed", "description": "Change the relative speed of the playback with this setting. At {\\t 1}\nthe speed is unchanged. {\\t 1.5} makes the speed 50\\% faster,\n{\\t 0.5} plays at half speed. At {\\t 0} the playing is completely\nfrozen. Note: {\\t speed} is being ignored when using the input\n{\\t clock}.\n"}], "description": "\\subsubsection*{Introduction}\n\nThis circuit can read MIDI files from your Micro SD card and\n``play'' them by creating according CVs for gate, pitch, velocity,\npitch bend and other outputs, which you can then route to synth voices\nin your modular -- or do other crazy stuff with that information.\n\nMIDI files are organized in tracks. Each circuit of this type can play\njust {\\it one track} at a time. If you want to play more tracks, use\nmore {\\t midifileplayer} circuits in parallel.\n\nJust as MIDI streams, MIDI files contain {\\it channel} information for\neach note and each controller event. These channels are currently completely\nignored. If you think you can convince me that this is bad and that you\nhave a useful interpretation of the channels within the scope of the\nMIDI file player, please let me know.\n\nSome limitations of the current implementation are:\n\n\\begin{itemize}\n\\item Just one track can be played at a time.\n\\item The maximum length of a track is 6000 bytes. Longer tracks cannot be\nloaded. Sorry. But this is quite long and is enough for approximately 1500 note events. Note: The size of the total file can be as large as you\nlike.\n\\item The channel information is ignored.\n\\item Some meta events such as program change, all notes off, etc. are not yet recognized. Many of them just make sense in MIDI streams, not in files, anyway.\n\\end{itemize}\n\nFeatures of the current implementation:\n\\begin{itemize}\n\\item Up to eight voices in parallel with flexible voice allocation algorithms\n\\item Support for velocity, pitch bend, mod wheel, and global volume\n\\item You can output the original MIDI clock from the file.\n\\item You can adjust the tempo continuously.\n\\item You can use external clocking (ignoring the tempo of the file).\n\\end{itemize}\n\n\\subsubsection*{Getting started}\n\nHere is the simplest possible example: Copy your MIDI file to the SD card\nand name it {\\t midi1.mid}. And here is the patch that plays the first\ntrack with a single voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\end{droidini}\n\nNow patch {\\t O1} to the 1V/Oct of a synth voice and {\\t O2} to its\ngate. This voice should then play the notes from the first track\nof the file.\n\nThe playback starts immediately when the DROID starts. Per default\nthe track is looped. You can restart the playback with the {\\t reset}\ninput. And the other way round: you get a trigger at {\\t endoftrack}\nwhen the playback of the track has finished.\n\n\\subsubsection*{Selecting file and track}\n\nYou can have more than one MIDI file on your SD card. The MIDI files on\nthe card must be named {\\t midi1.mid}, {\\t midi2.mid}, and so on. Gaps\nare allowed. You can have up to 9999 MIDI files that way. The last\none would have the name {\\t midi9999.mid}. Don't use leading zeroes!\nThe file {\\t midi0001.mid} cannot be played!\n\nYou can then select one of these files with the {\\t file} parameter,\nso e.g. {\\t file = 17} would play {\\t midi17.mid}. If you omit that, {\\t\nmidi1.mid} will be played. If no such file is present on the card, nothing\nwill be played.\n\nA MIDI file can contain several tracks. The {\\t track} parameter specifies\nthe number of the track in the file you want to play. Hereby only the non-empty\ntracks will be counted. This is important since many MIDI files have tracks\nthat just contain meta information and no note events.\n\nIf you omit the track number, the first non-empty track will be played.\nIf your track number is out of range, the last track in the file will be\nselected.\n\nThe parameters {\\t file} and {\\t track} are -- of course -- CV controllable.\nSo you can switch between files and tracks by means of buttons,\nswitches, external CV, you name it. Whenever the file or track changes,\n\\droid loads the selected track from the SD card into its memory. This is\nalso the case when the \\droid starts. Also a track change restarts playback.\n\nNote: loading a track from the SD card might take a couple of milliseconds.\nDuring that time \\droid won't run as usual. All inputs will be ignored\nand all outputs freeze. So switching at a high rate might lead to unexpected\nresults. If you need to have a playback started in perfect timing, use\nthe {\\t reset} input as an exact trigger. If you do not want to use a\ntrigger but rather a play/stop gate, you can use the {\\t speed} input for\nthat. Setting the speed to {\\t 0} stops playback and {\\t 1} starts it\nimmediately.\n\n\\subsubsection*{Polyphonic tracks}\n\nMIDI streams and files consist of {\\it note on} and {\\it note off} events.\nSo there is no length parameter in a note. It just contains the note number\n(in semitones) and a velocity. If the track contains situations where\na new note starts while another one is still on, the track is polyphonic, as\nyou need more than one synth voice to play correctly.\n\nThe MIDI file player allows you to define up to {\\it eight} voices\nfor playing notes. Each voice consists of a {\\t pitch}$X$ and a\n{\\t gate}$X$ output (and an optional {\\t velocity}$X$ output).\nBy patching these outputs the player knows how many voices are available.\n\nIf the number of simultaneous notes exceeds the number of attached voices,\nsome notes have to be cut off or completely omitted. You can flexibly change\nthe behaviour in such a situation. See the description of the parameter\n{\\t dropnotes} For details.\n\nHere is an example for playing with up to three voices:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    file = 2}    file = 2\n\\immediate\\write\\patchexamples{    track = 1}    track = 1\n\\immediate\\write\\patchexamples{    pitch1 = O1}    pitch1 = O1\n\\immediate\\write\\patchexamples{    pitch2 = O2}    pitch2 = O2\n\\immediate\\write\\patchexamples{    pitch3 = O3}    pitch3 = O3\n\\immediate\\write\\patchexamples{    gate1 = G1}    gate1 = G1\n\\immediate\\write\\patchexamples{    gate2 = G2}    gate2 = G2\n\\immediate\\write\\patchexamples{    gate3 = G3}    gate3 = G3\n\\end{droidini}\n\n\n\\subsubsection*{Speed and Clocking}\n\nA MIDI file contains absolute timing information of when to exactly play\nwhich note. For that purpose every note event in the file has a relative\n{\\it time stamp}, measured in {\\it ticks}. The player honors this information\nand plays the tracks exactly in their original speed... unless... you change\nit of course.\n\nTo do so you have two options. The first one is the {\\t speed} parameter.\nAt {\\t 1.0} you get the original playing speed. {\\t 0.5} will play at\nhalf the speed and {\\t 2.0} at the double speed. This can be mapped\nto a pot, of course (here I chose a range from 0 to 2):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    speed = P1.1 * 2}    speed = P1.1 * 2\n\\end{droidini}\n\nTurning the pot totally CCW will completely freeze the playback.\n\nIf you need the internal clock of the MIDI player in order to\nsynchronize with the rest of your patch, you can get two\nclocks running at different resolutions at the\ntwo outputs {\\t clockout} and {\\t midiclock}. See their descriptions\nbelow for details.\n\nThe second option is clocking the player externally. In that case the tempo\ninformation from the MIDI file is ignored. External clocking allows you to\nsynchronize the MIDI playback with the rest of your patch, which may contain\nadditional sequencers and stuff.  Patch your external clock into the {\\t clock}\ninput. Each clock will then play a \\nth{16} note's time equivalent of content:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\end{droidini}\n\nNote: this does {\\it not} mean that the notes are quantized to \\nth{16}\nnotes. You still have the complete resolution.\n\n\\subsubsection*{Other controls and parameters}\n\nMIDI files may contain information about pitch bend, a global volume (CC 7),\nthe mod wheel (CC 1) and velocity (per note). These are all available as CV\noutputs.  See the table of outputs for details. Most other CCs are currently\nnot available since they are very rarely used in MIDI files. Future versions\nof the MIDI file player might give access to these.\n\n\n\\subsubsection*{Error handling}\n\nWhen working with files, errors can happen. The MIDI file\nmight be missing, corrupted, whatever. In order to make life easier\nfor you, the MIDI file player can show you an error status at the\noutput {\\t error}. Write the error to an {\\t R} register that is free,\nthat will make one of the LEDs lit up and show an error color.\n\nThe following patch shows the errors at the LED of input 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    error = R1}    error = R1\n\\end{droidini}\n\nPlease see the table of outputs below for the various\nerrors and their color codes.\n\n\n\\clearpage", "title": " MIDI file player", "outputs": [{"count": 8, "start_at": 1, "name": "pitch1 ... pitch8", "default": null, "prefix": "pitch", "type": "voltperoctave", "description": "Pitch outputs. Since MIDI tracks can be polyphonic -- i.e. play\nseveral notes at the same time -- you can assign up to eight outputs\nhere. The notes will be distributed to the defined outputs\naccording to the settings {\\t roundrobin} and {\\t voiceallocation}.\n"}, {"count": 8, "start_at": 1, "name": "velocity1 ... velocity8", "default": null, "prefix": "velocity", "type": "fraction", "description": "For each voice there is an optional velocity output, which\ntranslates the MIDI velocity into values from 0 to 1.\n"}, {"count": 8, "start_at": 1, "name": "pressure1 ... pressure8", "default": null, "prefix": "pressure", "type": "fraction", "description": "MIDI provides two different messages for sending \"after-touch\"\ninformation, i.e. information about how strong a key is pressed\ndown after the initial hit. Some keyboards just have one pressure\nsensor in total and send the current maximum pressure information\nof all keys in one message (``channel pressure''). Others have\none pressure sensor per key and send ``polyphonic key pressure''\nmessages. This circuit maps both to a {\\t pressure} output\nper note that is being played. So if your keyboard (or sequencer\nor DAW or whatever) sends polyphonic key pressure events and\nyou use multiple {\\t pitch}{\\it X} outputs, wire the individual\n{\\t pressure}{\\it X} outputs to wherever you like. Otherwise\nyou can simply use {\\t pressure1} for all notes (which can\nbe abbreviated with {\\t pressure}), since it is the same for\nall note outputs anyway. {\\t pressure} outputs a value from\n0 to 1.\n"}, {"count": 8, "start_at": 1, "name": "gate1 ... gate8", "default": null, "prefix": "gate", "type": "gate", "description": "Gate outputs for the up to eight simultaneous note outputs.\n"}, {"count": 8, "start_at": 1, "name": "trigger1 ... trigger8", "default": null, "prefix": "trigger", "type": "trigger", "description": "Trigger outputs for the up to eight simultaneous note outputs. The\ndifference to the gate outputs is, that these just send a short\ntrigger of 5~ms at the start of the note. This can be interesting\nin situations where the notes have no {\\it gaps} in between so\nthat gate will never go low.\n"}, {"count": 4, "start_at": 1, "name": "cc1 ... cc4", "default": null, "prefix": "cc", "type": "fraction", "description": "Outputs the current value of the four CC number that are defined\nwith the inputs {\\t ccnumber1} ... {\\t ccnumber4}. CCs have a\nrange from 0 to 127, but this is converted in the range 0.0 .. 1.0\nhere, in order to make it easier to use that as a CV. If you need\nthe raw number, multiply the output with 127. Note: as long as no CC\nmessage with the selected number happened, this output will be set\nto 0.\n"}, {"count": 16, "start_at": 1, "name": "notegate1 ... notegate16", "default": null, "prefix": "notegate", "type": "gate", "description": "Outputs a high gate whenever the corresponding note (which is\nselected by {\\t note1} through {\\t note16}) is currently being played.\n"}, {"default": null, "type": "cv", "name": "pitchbend", "description": "Outputs the current pitch bend value as a bipolar voltage.\nThe range can be set with {\\t pitchbendrange}.\n"}, {"default": null, "type": "trigger", "name": "programchange", "description": "Sends a trigger whenever a {\\it MIDI program change} message\narrives. Just before sending the trigger sets {\\t program} to\nthe new program number (something from 0 to 127). Note: This\ntrigger is also being output when the program change messages\nsends the same program number as previously, i.e. if there\nis no actual {\\it change}.\n"}, {"default": null, "type": "integer", "name": "program", "description": "The number of the last program change. This starts at {\\t 0}.\n"}, {"default": null, "type": "integer", "name": "bank", "description": "Outputs the number of the currently selected bank -- from\n0 to 16384. MIDI defines the MSB of the bank to be changed\nwith CC\\#0 and the LSB with CC\\#32. That means if you just\nuse CC\\#0, you will only be able to select the banks 0, 128,\n256, and so on. As long as no bank select CC has been received,\n{\\t bank} will output 0.\n"}, {"default": null, "type": "fraction", "name": "modwheel", "description": "Output the current state of the mod wheel level -- within\nthe range from {\\t 0.0} to {\\t 1.0}. The mod wheel is changed\nby MIDI control change 1.\n"}, {"default": null, "type": "fraction", "name": "volume", "description": "Outputs the current global volume as set by MIDI control change 7.\n"}, {"default": null, "type": "gate", "name": "portamento", "description": "This output gives you access to the current state of\nthe ``portamento pedal'' (MIDI CC 65). You can use it to\nenable an external slew limiter for creating portamento\neffects (see page \\pageref{slew}).\n"}, {"default": null, "type": "gate", "name": "soft", "description": "This output gives you access to the current state of\nthe ``soft pedal'' (MIDI CC 67). It is {\\t 1} while the pedal\nis hold and {\\t 0} otherwise.\n"}, {"default": null, "type": "trigger", "name": "clockout", "description": "Outputs a steady clock of 1 tick per \\nth{16} note.\n"}, {"default": null, "type": "trigger", "name": "midiclock", "description": "Outputs a steady MIDI clock, i.e. 24 ticks per quarter note\nof the tune. This is 6 times faster than {\\t clock}.\n"}, {"default": null, "type": "trigger", "name": "endoftrack", "description": "Outputs a trigger when the end of the track is reached.\n"}, {"default": null, "type": "cv", "name": "error", "description": "This output will be set to a value other than zero in case\nof an error while loading and parsing the MIDI file. This is\nintended for wiring it to one of the {\\t R} registers. Here\ndifferent errors will be displayed as different colors. Here\nis the list of all possible values of {\\t error}:\n\n\\begin{tabular}{|c|c|l|}\\hline\nvalue     & color   & what happened? \\\\ \\hline\n{\\t 0}    & black   & Everything is fine. \\\\ \\hline\n{\\t -1}   & white   & The SD card or MIDI file is missing. \\\\ \\hline\n{\\t 1}    & magenta & The file is corrupted, garbled or no MIDI file. \\\\ \\hline\n{\\t 0.75} & orange  & The file does not contain any non-empty track. \\\\ \\hline\n{\\t 0.25} & cyan    & the track is too long (max 6000 bytes are allowed). \\\\ \\hline\n\\end{tabular}\n\\vspace{2mm}\n"}], "presets": 0}, "cvlooper": {"category": "cv", "inputs": [{"default": "0", "type": "cv", "name": "cvin", "description": "Input CV that should be looped.\n"}, {"default": "1", "type": "gate", "name": "gatein", "description": "Optional input gate. If you do not patch something here, the gate is\nassumed to be always high.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "Input clock. The clock is mandatory and is the base for the definition of\nthe loop length. Also the loop switch is quantized in time to the nearest\nclock.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here resets the playback head immediately to the start of the loop,\nif you are in playback mode.\n"}, {"default": "16", "type": "integer", "name": "length", "description": "Length of the loop in clock ticks. Example: You get a length of 16 ticks\nby patching the number {\\t 16} to {\\t length}. If you want to set the length by means\nof an external CV that would require 160 Volts. So you need to multiply your\ninput by some useful number in that case.\n"}, {"default": "1", "type": "cv", "name": "tapespeed", "description": "Relative tape speed, where {\\t 1.0} is the normal speed.\nSo a value of {\\t 0.5}\nslows down the speed thus increasing the effective tape length from 8 to\n16 seconds while reducing the sampling rate from 1 ms to 2 ms per sample.\nChanging the tape speed on the fly probably leads to interesting results.\n"}, {"default": "unpatched", "type": "gate", "name": "loopswitch", "description": "Mandatory parameter: While the loop switch is {\\t off} the CV looper\nsimply sends all input CV and gate to their respective outputs. At the same time CV\nand gate are also recorded to the tape. When the loop switch is {\\t on},\nthe CV and gate are being read from the tape, instead. The input\nCV and gate are now ignored.\n"}, {"default": "off", "type": "gate", "name": "pause", "description": "This is a binary input. If you send a high signal here, the looper\npauses. This is only works in playback mode. The current CV value\nis hold the entire time. This is {\\it not} the same as bypass, since\nin bypass mode the original CV will routed through.\n"}, {"default": "off", "type": "gate", "name": "overlay", "description": "Overlaying changes the behaviour while looping is active. If {\\t overlay} is\nset to {\\t on}, while the input gate is active the gate and CV will be\nsent directly from the inputs rather than read from the tape.\n"}, {"default": "off", "type": "gate", "name": "overdub", "description": "Overdubbing also changes the behaviour during the looping: If\nit is active then while the input gate is high the input gate\nand CV will be written\nto the tape -- thus changing the loop on the fly.\n"}, {"default": "off", "type": "gate", "name": "bypass", "description": "Setting {bypass} to {on} copies the input CV and gate from their\ninputs to their outputs {\\it while keeping the loop's content\nuntouched}. This disabled the looping for the while, but you\ncan get back to it later. Note: this is different from turning\noff the loop switch, because then your tape's content\nwould be overwritten.\n"}], "description": "This circuit is a very easy to use CV looper. It records an incoming CV (and\noptionally a gate as well) on a virtual tape loop with a resolution of one\nsample per ms.  The length of this tape is eight seconds. If you need a longer\nloop time, you can reduce the tape speed. At a speed of {\\t 0.5} you have a\nmaximum loop time of 16 seconds and a resolution of one sample per 2~ms (which\nis still pretty decent for most applications).\n\nThis looper is meant to be playable in a live situation as easily as possible.\nFor that purpose it does not implement the typical {\\it loop start $\\to$ loop\nstop} scheme -- which requires the musician to know beforehand that she will\nstart a loop. Instead the looper is {\\it always} recording. The loop length is\nspecified in {\\it clock ticks}. And as soon as the looping is activated, the\nprevious $x$ clock ticks of CV information will be repeated over and over.\n\nHere is an example for a simple looper for one CV without a gate:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    led        = L1.1}    led        = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    cvin       = I1}    cvin       = I1\n\\immediate\\write\\patchexamples{    clock      = I8    # steady clock}    clock      = I8    # steady clock\n\\immediate\\write\\patchexamples{    cvout      = O1}    cvout      = O1\n\\immediate\\write\\patchexamples{    length     = 16    # 16 clock ticks}    length     = 16    # 16 clock ticks\n\\immediate\\write\\patchexamples{    loopswitch = L1.1}    loopswitch = L1.1\n\\end{droidini}\n\nThe button {\\t B1.1} is converted into a toggle button for activating the\nlooping.  The CV is read from {\\t I1} and comes out at {\\t O1}. As long as the\nloop switch is {\\t off} the looper is in bypass mode and simply copies {\\t I1}\nto {\\t O1}. At the sime time it is always recording to its internal endless tape.\nWhen the loop switch is switched {\\t on}, the last 16 clock ticks of CV information is\nlooped to {\\t O1} and {\\t I1} is ignored.\n\nPlease note: for your convenience the exact time when the loop switch is switched\n{\\t on} is {\\it quantized to the nearest clock tick} -- may it be in the future\nor past. This makes playing exactly in time much easier.\n\nThe second example adds a gate signal -- such as output by a ribbon controller. The\ngate is running through {\\t I2}$\\to${\\t O2}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    led        = L1.1}    led        = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    cvin       = I1}    cvin       = I1\n\\immediate\\write\\patchexamples{    gatein     = I2}    gatein     = I2\n\\immediate\\write\\patchexamples{    clock      = I8    # steady clock}    clock      = I8    # steady clock\n\\immediate\\write\\patchexamples{    cvout      = O1}    cvout      = O1\n\\immediate\\write\\patchexamples{    gateout    = O2}    gateout    = O2\n\\immediate\\write\\patchexamples{    length     = 16    # 16 clock ticks}    length     = 16    # 16 clock ticks\n\\immediate\\write\\patchexamples{    loopswitch = L1.1}    loopswitch = L1.1\n\\end{droidini}\n\nUsing a gate changes the behaviour of the CV looper.  The state of {\\t gatein}\n(not the exact voltage) is being looped as well.  The CV is recorded to the\ntape {\\it only while the gate is high}.\n\nUsing a gate makes two additional features possible:\n\n\\begin{enumerate}\n\n\\item When {\\t overlay} is {\\t on} and the input gate is active, the input CV\nwill override that on the tape and instead the source signal from {\\t cvin}\nis bypassed to the output. The tape's content stays untouched. This allows\nyou to overlay the loop CV with your own from time to time.\n\n\\item On the other hand, when {\\t overdub} is {\\t on} and the input gate is active, the input\nCV will be written to the tape and {\\it replaces the recorded CV} at those\nplaces. And it also will be routed to the output at the same time.\n\n\\end{enumerate}\n\nToggle buttons would fit nicely for these two functions.\n\nPlease note: you always need a clock! The CV looper is useless without one.  If\nyou do not want to use an external clock, you can make use of the LFO circuit\nfor creating an internal clock.\n\nWhat if you want to loop more than one CV? Just create\nmore {\\t cvlooper} circuits -- one for each CV. And control them from the\nsame set of buttons.\n\n\\subsubsection*{Changing the tape or clock speed}\n\nIt is possible to change the tape speed on the fly in order to slow down or\nspeed up the recorded loop's content. It is important -- however -- to always\nchange the tape speed and clock speed {\\it at the same time and in the same\nmanner}. Otherwise you will get stuttering effects. So if you double the {\\t\ntapespeed} you also need to double the frequency of the clock.\n\n\\subsubsection*{Changing the length}\n\nChanging {\\t length} parameter on the fly is supported and just\nworks. Remember: it does not set the length of the tape loop but just the\nlength of that part that is played back. The recording is always done with\nthe maximum length. So if you {\\it increase} the length while playing back\nyou will get access to the older parts of the CV history that way. Just don't\nmake the length longer than the actual tape (see below).\n\n\\subsubsection*{Limitations}\n\nMemory (RAM) is a valuable resource. The CV looper limits itself to 8000\nsamples in order not to waste too much memory and leave space for other circuits\nas well (the Droid master has about 100.000 bytes of memory and 8000 samples\nneed 16.000 bytes). But if you want to make longer loops, you can reduce\nthe tape speed and thus use less samples per second.\n\nA second limitation is that the total loop length can be 128 clock ticks at\nmost. If you need more ticks, you can divide the input clock down, using\n{\\t clocktool}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock        = G1}    clock        = G1\n\\immediate\\write\\patchexamples{    divide       = 2}    divide       = 2\n\\immediate\\write\\patchexamples{    output       = _LOOP_CLOCK}    output       = _LOOP_CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    clock        = _LOOP_CLOCK}    clock        = _LOOP_CLOCK\n\\immediate\\write\\patchexamples{    cvin         = I5}    cvin         = I5\n\\immediate\\write\\patchexamples{    tapespeed    = 0.2 # max loop five x longer}    tapespeed    = 0.2 # max loop five x longer\n\\immediate\\write\\patchexamples{    cvout        = O5}    cvout        = O5\n\\immediate\\write\\patchexamples{    length       = 128 # = 256 original ticks}    length       = 128 # = 256 original ticks\n\\immediate\\write\\patchexamples{    loopswitch   = _SOME_BUTTON}    loopswitch   = _SOME_BUTTON\n\\end{droidini}\n\n\n\\clearpage", "title": " Clocked CV looper", "outputs": [{"default": null, "type": "cv", "name": "cvout", "description": "Output of the bypassed or looped CV\n"}, {"default": null, "type": "gate", "name": "gateout", "description": "Output of the bypassed or looped gate\n"}], "presets": 0}, "button": {"category": "ui", "inputs": [{"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": null, "type": "trigger", "name": "button", "description": "The actual push button. Usually you want to wire this to {\\t B1.1},\n{\\t B1.2} and so on: to one of the push buttons of your\ncontrollers. Each time that input goes from low to high,\nthe state of the push button will toggle.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A trigger here will reset the button\nto its start value (which is off, unless you\nhave changed {\\t startvalue}).\n"}, {"default": "1", "type": "cv", "name": "onvalue", "description": "Value sent to {\\t output} when the push button is on. You can also\nuse a dynamic signal here. This is an alternative name for the\njack {\\t value1}.\n"}, {"default": "0", "type": "cv", "name": "offvalue", "description": "Value sent to {\\t output} when the push button is off. This\nis an alternative name for the jack {\\t value2}.\n"}, {"count": 4, "start_at": 1, "name": "value1 ... value4", "default": null, "prefix": "value", "type": "cv", "description": "The up to four values to output at {\\t output} when the button\nis on the according state. {\\t value1} is the same as {\\t offvalue}\nand {\\t value2} is the same as {\\t onvalue}. The default values\nof these four jacks are {\\t 0}, {\\t 1}, {\\t 2} and {\\t 3}, so\nin many cases you don't need to specify them.\n"}, {"default": "off", "type": "gate", "name": "doubleclickmode", "description": "This input can enable a {\\it double click mode} when set to {\\t 1}.\nIn that mode the button only toggles it's constant state if you double\npress it in a short time. Otherwise it behaves like a momentary button,\nthat inverts the persisted state (which you toggle with the double click).\nNote: The double clock mode is only makes sense if the number of\nstates is 2.\n"}, {"default": "2", "type": "integer", "name": "states", "description": "Number of states this button can have. The default value is {\\t 2},\nwhich creates a toggle button which changes between on and off at each\npress. A value of {\\t 1} creates a momentary button. Note: If you just\nneed a plain momentary button, you can directly use {\\t B1.1}, {\\t B1.2}\nand so on. You don't need an extra circuit. But if you want things like\noverloading (with {\\t select}) or the {\\t longpress} output, this does\nmake sense. The maximum number of states is 4. When the button has\n3 or 4 states, every press will switch to the next state and then\nback to the first state again.\n"}, {"default": "unpatched", "type": "gate", "name": "startvalue", "description": "State of the push button when you switch on your system. Setting this\nto {\\t on} or {\\t off} will force the button into that state and ignore\nthe setting that is saved on the SD card. If you have three\nstates, the start value needs to be {\\t 0}, {\\t 1} or {\\t 2}. With\nfour states, it can also be {\\t 3}. Using this\njack disables the persistence of the state! In switched mode this will\nbe used for the other button layers as well.\n"}], "description": "This is a utility circuit for efficiently working with the buttons\nof your controllers. It can implement toggle buttons (that do on/off)\nor even have three or four states. It can detect long presses and\ndouble clicks and also helps you to overload one button with several\nswitchable functions. Note: If you just need a plain momentary button\nwithout any of these or other nifty features, you can use the\nregister {\\t B1.1}, {\\t B1.2}, etc. directly and do not need this circuit.\n\nNote: don't forget to declare your controllers at the top\nof your patch with lines like {\\t [p2b8]} or {\\t [b32]}. In the\nbelow examples I've omitted these declarations for sake of simplicity.\n\n\n\\subsubsection*{Toggle buttons}\n\nThe most common use of {\\t button} is to implement a toggle button.\nThat's a button that changes from on to off and back at each press\nof the button. The current state of the button will persist on your\nSD card so you don't loose your state if you switch off your rack.\n\nTypically you will wire the {\\t button} jack to one of your controller's\nbuttons like {\\t B1.1} and {\\t led} to the LED in that button ({\\t L1.1}). LED\nwill then always visualise the current state of the button. As a side effect\nthe LED register {\\t L1.1} will store the button state as a value {\\t 0}\nor {\\t 1} and hence can be used by some other circuit as an input.\n\nHere is a typical example. The button is being used for enabling\nthe loop in a CV looper:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop        = L1.4}    loop        = L1.4\n\\end{droidini}\n\nIf you do not want the state of the button to be persisted on the SD card,\nuse {\\t startvalue} for setting a start value. This make sense for the CV\nlooper since the loop is apparently empty anyway when your \\droid starts. By\nthe way: {\\t off} is a synonym for {\\t 0}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.4}    button     = B1.4\n\\immediate\\write\\patchexamples{    led        = L1.4}    led        = L1.4\n\\immediate\\write\\patchexamples{    startvalue = off}    startvalue = off\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop       = L1.4}    loop       = L1.4\n\\end{droidini}\n\n\nUsually the button switches between the two values {\\t 0} and {\\t\n1}. Sometimes, however, you need different values. For this purpose there\nare the two inputs {\\t offvalue} and {\\t onvalue}. They set two alternative\nvalues for the \"off\" and \"on\" states. And the jack {\\t output} outputs the\nselected value ({\\t led} still goes to 0 and 1). Here is an example for a\ntoggle button that switches a clock divider between {\\t 2} and {\\t 4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{    offvalue    = 2}    offvalue    = 2\n\\immediate\\write\\patchexamples{    onvalue     = 4}    onvalue     = 4\n\\immediate\\write\\patchexamples{    output      = _CLOCK_DIV}    output      = _CLOCK_DIV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    input       = G1 # external clock}    input       = G1 # external clock\n\\immediate\\write\\patchexamples{    output      = G2}    output      = G2\n\\immediate\\write\\patchexamples{    divide      = _CLOCK_DIV}    divide      = _CLOCK_DIV\n\\end{droidini}\n\nOf course {\\t offvalue} and {\\t onvalue} are CV controllable. How can make\nthis sense? Well -- as they can take variable inputs you can use a button\nfor directly switching between two different input CV signals. The following\nexample will use a button to switch between two different wave forms of an\nLFO (see page \\pageref{lfo}). The button {\\t B3.1} switches between sawtooth\nand sine and sends the result to {\\t O1}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    offvalue    = _SAWTOOTH}    offvalue    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    onvalue     = _SINE}    onvalue     = _SINE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\n\n\\subsubsection*{Buttons with three or four states}\n\nSometime you might want more than just two values. {\\t button} supports\nswitching between up to four values. Use the {\\t states} input and set\nit to {\\t 3} or {\\t 4}. In the following examples {\\t output} will go\nthrough the values {\\t 0}, {\\t 1}, {\\t 2} and {\\t 3}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    states = 4}    states = 4\n\\immediate\\write\\patchexamples{    output = _SOMETHING}    output = _SOMETHING\n\\end{droidini}\n\nIf you don't like the default values, use the jacks {\\t value1} through {\\t\nvalue4} for setting the four values. In fact {\\t offvalue} is the same as\n{\\t value1} and {\\t onvalue} as {\\t value2}. If you specify {\\t value3}\nor {\\t value3}, {\\t states} is automatically set accordingly and you\ncan simply omit it .The following example switches\nbetween {\\it four} different wave forms of an LFO:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{    square      = _SQUARE}    square      = _SQUARE\n\\immediate\\write\\patchexamples{    triangle    = _TRIANGLE}    triangle    = _TRIANGLE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    value1      = _SAWTOOTH}    value1      = _SAWTOOTH\n\\immediate\\write\\patchexamples{    value2      = _SINE}    value2      = _SINE\n\\immediate\\write\\patchexamples{    value3      = _SQUARE}    value3      = _SQUARE\n\\immediate\\write\\patchexamples{    value4      = _TRIANGLE}    value4      = _TRIANGLE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nIf you have three or four states, the LED will use different brightness\nlevels for indicating the current state.\n\n\n\\subsubsection*{Momentary buttons}\n\nIf you just need a momentary button (one that just lights up\nwhile you hold it down), strictly spoken you don't need a {\\t button}\ncircuit. You can directly use the {\\t B} register, like in this example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    nextpattern = B1.1}    nextpattern = B1.1\n\\end{droidini}\n\nSometimes, however, you may want to make use of some of the features\nof the {\\t button} circuit without creating a toggle button.\nThis is easily done by setting {\\t states = 1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    states = 1}    states = 1\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    nextpattern = L1.1}    nextpattern = L1.1\n\\end{droidini}\n\nNow you are ready for adding some fun stuff like overlaying one button\nwith multiple functions (see below) or using the {\\t longpress} output.\n\n\\subsubsection*{Sharing buttons}\n\nYou can never have too many buttons! It's more likely that you have too\nfew. So you want to overlay one or more buttons with multiple functions.\n\nThey key to this is the {\\t select} input of the {\\t button} circuit.\nIf you patch this, the circuit will only interact with the actual\nbutton and LED if {\\t select} is active (e.g. set to {\\t 1}). Otherwise\nit will continue to output its current value to {\\t output} and leave\nthe control of the button and the LED to some other circuit.\n\nThe following example uses the button {\\t B1.1}, (which is not overloaded!) for\nswitching between two \"layers\" or \"banks\" of buttons. And in each bank\nthe button has a different meaning. Note how I use the {\\t negated} output\nof the button. That is {\\t 0} if the normal output is {\\t 1} and vice\nversa.\n\nIn order to keep things short, the bank just consists of the single button\n{\\t B1.2}. Of course in practice this wouldn't make sense since you wouldn't\nactually save a button, but you get the idea...\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    output = _BANK1}    output = _BANK1\n\\immediate\\write\\patchexamples{    negated = _BANK2}    negated = _BANK2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    select = _BANK1}    select = _BANK1\n\\immediate\\write\\patchexamples{    button = B3.1}    button = B3.1\n\\immediate\\write\\patchexamples{    led = L3.1}    led = L3.1\n\\immediate\\write\\patchexamples{    output = _VIRTUAL_BUTTON_1}    output = _VIRTUAL_BUTTON_1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    select = _BANK2}    select = _BANK2\n\\immediate\\write\\patchexamples{    button = B3.1}    button = B3.1\n\\immediate\\write\\patchexamples{    led = L3.1}    led = L3.1\n\\immediate\\write\\patchexamples{    output = _VIRTUAL_BUTTON_2}    output = _VIRTUAL_BUTTON_2\n\\end{droidini}\n\nNote: If you need more than two banks, consider switching with a {\\t buttongroup}\n(see page \\pageref{buttongroup}).\n\n\\clearpage", "title": " Do all sorts of useful things with buttons", "outputs": [{"default": null, "type": "cv", "name": "led", "description": "When the button state is {\\t on}, a value of {\\t 1.0} will be sent to that\noutput -- regardless of the values in {\\t onvalue}\nand {\\t offvalue}. If the number of states is 3 or 4 the output get's intermediate\nvalues so the attached LED will be dimmed into different brightness\nlevels. Usually you wire that output to a LED register, e.g.\nto {\\t L1.1}, {\\t L1.2} and so on.\n"}, {"default": null, "type": "cv", "name": "output", "description": "This jack will output the current button states. This is usually\n{\\t 0} for off and {\\t 1} for on. If {\\t states} is 3 or 4, the\nvalues {\\t 2} or {\\t 3} are output for the additional states.\nYou can modify all four values with the inputs {\\t offvalue}/{\\t value1},\n{\\t onvalue}/{\\t value2}, {\\t value3} and {\\t value4}. Note:\nif you haven't changed any of these inputs and {\\t states} is\nunchanged or 1 or 2, the {\\t led} output will output the same\nvalues.\n"}, {"default": null, "type": "cv", "name": "inverted", "description": "The same as {\\t output}, but sends {\\t onvalue} when the\nbutton is off and {\\t offvalue} when the button is on.\nIf {\\t states} is 3 or 4, the order of the four output values will\nbe mirrored (probably a feature that is rarely of any use).\n"}, {"default": null, "type": "gate", "name": "negated", "description": "Similar to {\\t inverted}, but always sends {\\t 1} when the button\nis off and {\\t 0} when the button is on -- independent of the values\nof {\\t onvalue} and {\\t offvalue}. When {\\t states} is 3 or 4,\nthis output will be {\\t 1} if the button is off and {\\t 0} in\nthe other three states.\n"}, {"default": null, "type": "trigger", "name": "longpress", "description": "Emits a trigger, when any button is pressed for at least 1.5\nseconds. If this jack is used, the effect of a short button press\nis delayed until the button is {\\it released}. This will avoid double\nactions for long presses.\n"}], "presets": 0}, "queue": {"category": "cv", "inputs": [{"default": "0", "type": "cv", "name": "input", "description": "This CV will be pushed into the first cell of the shift register\nwhenever a clock occurs.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "Each clock signal at this jack will move the CV content\nfrom every cell of the shift register to the next cell. The CV\nin the last cell will be dropped.\n"}, {"count": 8, "start_at": 1, "name": "outputpos1 ... outputpos8", "default": "unpatched", "prefix": "outputpos", "type": "integer", "description": "Specifies the position of each of the eight outputs -- i.e. which\ncell of the shift register it should output. Allowed are values\nfrom 1 up to 64. These jacks defaults to {\\t 1}, {\\t 2}, ... {\\t 8}, so\nif you do not wire them the eight outputs reflect the first eight\npositions of the shift register.\n"}], "description": "This circuit implements a shift register (a queue) with 64 cells. Each cell\ncontains one CV value. At each clock impulse the CVs each move one cell\nforwards. The last CV is dropped. And the current input value is copied\nto the first cell.\n\nThere are eight outputs, which you can place at any of the 64 cells you\nlike. If you do not specify any placement, the outputs are placed at the first\neight cells -- und thus the information in the remaining 56 cells is not being\nused.\n\nThe following example reads CVs from the input {\\t I1}. {\\t O4} always shows\nthe CV value that was seen at the input four cycles previously:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[queue]}[queue]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    clock = I2}    clock = I2\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\n\nThe next example places three outputs at the positions {\\t 3}, {\\t 24} and {\\t 64}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[queue]}[queue]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    clock = I2}    clock = I2\n\\immediate\\write\\patchexamples{    outputpos1 = 3}    outputpos1 = 3\n\\immediate\\write\\patchexamples{    outputpos2 = 24}    outputpos2 = 24\n\\immediate\\write\\patchexamples{    outputpos3 = 64}    outputpos3 = 64\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\end{droidini}\n\nPlease note:\n\n\\begin{itemize}\n\\item Since the DROID is very precise in processing CV voltages you can use\n  the {\\t queue} in order to delay melodies from sequencers etc.\n\\item As always also the inputs {\\t outputpos1} ... {\\t outputpos8} may be\n  CV controlled and change in time.\n\\end{itemize}", "title": " Clocked CV shift register", "outputs": [{"count": 8, "start_at": 1, "name": "output1 ... output8", "default": null, "prefix": "output", "type": "cv", "description": "Eight outputs for eight different positions of the register. If\nyou do not wire {\\t outputpos1} ... {\\t outputpos8}, these outputs\nshow the content of the \\nth{1}, \\nth{2}, ... \\nth{8} cell.\n"}], "presets": 0}, "arpeggio": {"category": "sequencing", "inputs": [{"default": "0", "type": "integer", "name": "root", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n"}, {"default": "0", "type": "integer", "name": "degree", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n"}, {"default": "unpatched", "type": "gate", "name": "select1", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n"}, {"default": "unpatched", "type": "gate", "name": "select3", "description": "Gate input for selecting the \\nth{3}.\n"}, {"default": "unpatched", "type": "gate", "name": "select5", "description": "Gate input for selecting the \\nth{5}.\n"}, {"default": "unpatched", "type": "gate", "name": "select7", "description": "Gate input for selecting the \\nth{7}.\n"}, {"default": "unpatched", "type": "gate", "name": "select9", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n"}, {"default": "unpatched", "type": "gate", "name": "select11", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n"}, {"default": "unpatched", "type": "gate", "name": "select13", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n"}, {"default": "off", "type": "gate", "name": "selectfill1", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n"}, {"default": "off", "type": "gate", "name": "selectfill2", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill3", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n"}, {"default": "off", "type": "gate", "name": "selectfill4", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill5", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "tuningmode", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n"}, {"default": "0", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n"}, {"default": "0", "type": "voltperoctave", "name": "pitch", "description": "Sets the base pitch of the arpeggio. The first note of the\npattern will be the nearest selected note just above that pitch.\n"}, {"default": "0.2", "type": "voltperoctave", "name": "range", "description": "Selects the range between the lowest and highest note of the\narpeggio. A range of 0 means that there is just one single note\npossible and the arpeggio will stick to that note. A value of\n1~V (or 0.1) means that the arpeggio will run over one octave.\nThe maximum allowed range is 0.8 (8 octaves). Higher values will be\ncapped to that.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "This input is vital: each trigger here make the arpeggio\nmove forward by one step and adapt the pitch output. Without\na clock the arpeggio will do nothing but stick to the same\nnote all the time.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Resets the arpeggio to the first step of the current pattern.\n"}, {"default": "0", "type": "integer", "name": "pattern", "description": "Selects one of a list of arpeggio pattern. The following\npatterns are available:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|l|} \\hline\n{\\t 0} & $\\rightarrow$ & step forward through the allowed notes \\\\ \\hline\n{\\t 1} & $\\rightarrow$ $\\rightarrow$ $\\leftarrow$ & two steps forward, one step backward \\\\ \\hline\n{\\t 2} & $\\Rightarrow$ $\\leftarrow$ & double step forward, one step backward \\\\ \\hline\n{\\t 3} & $\\Rightarrow$ $\\Leftarrow$  $\\rightarrow$ & double step forward, double step backward, single step forward \\\\ \\hline\n{\\t 4} & $\\Rightarrow$ $\\rightarrow$ $\\Leftarrow$ $\\rightarrow$ & double step forward, single step forward, double step backward, single step forward \\\\ \\hline\n{\\t 5} & $\\leftrightarrow$ & random single step forward or backward \\\\ \\hline\n{\\t 6} & $\\Updownarrow$ & random jump to any allowed (other) note \\\\ \\hline\n\\end{tabular}}\n\\vspace{2mm}\n"}, {"default": "0", "type": "gate", "name": "direction", "description": "Sets the general direction in which the pattern moves.\n{\\t 0} means upwards and {\\t 1} means downwards.\n"}, {"default": "0", "type": "gate", "name": "pingpong", "description": "If set to {\\t 1}, the pattern will reverse its direction\nonce it has reached the end of the range. Otherwise it restarts\nfrom the beginning. So enabling {\\t pingpong} is a bit like a triangle\nwave, whereas otherwise it's more like a sawtooth.\n"}, {"default": "0", "type": "gate", "name": "butterfly", "description": "If set to {\\t 1}, every second note in the range of selected\nnotes will be mirrored. So for example you have selected the notes\n1 - 10, the new order will be 1, 10, 2, 9, 3, 8, 4, 7, 5, 6\n"}, {"default": "0", "type": "integer", "name": "drop", "description": "Selects a scheme of skipping some of the allowed scale notes.\nFour different values are allowed:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|l|} \\hline\n{\\t 0} & Do not skip any notes\n& \\normalsize \\ding{202} \\ding{203} \\ding{204} \\ding{205} \\ding{206} \\ding{207} \\\\ \\hline\n{\\t 1} & Skip every second selected note\n& \\normalsize \\ding{202} \\ding{193} \\ding{204} \\ding{195} \\ding{206} \\ding{197} \\\\ \\hline\n{\\t 2} & Skip every third selected note\n& \\normalsize \\ding{202} \\ding{203} \\ding{194} \\ding{205} \\ding{206} \\ding{197} \\\\ \\hline\n{\\t 3} & Skip the \\nth2 and \\nth3 note of each group of three\n& \\normalsize \\ding{202} \\ding{193} \\ding{194} \\ding{205} \\ding{196} \\ding{197} \\\\ \\hline\n\\end{tabular}}\n\\vspace{2mm}\n"}, {"default": "0", "type": "gate", "name": "octaves", "description": "When this is set to {\\t 1} or {\\t 2}, each note will be followed\nby the same note one octave up (for {\\t 1}) or down (for {\\t 2})\nrespectively. These additional octave notes are in addition to the\nselected range.\n"}, {"default": "0", "type": "integer", "name": "startnote", "description": "When {\\t startnote} is set to non-zero, it will force the pattern\nto begin with a certain scale note regardless of the current note\nselection. {\\t 1} will select the first note of the scale (root),\n{\\t 2} the second and so on until {\\t 7}, which selects the \\nth7\nas start note.\n"}], "description": "\\subsubsection*{Introduction}\n\nThis circuit creates melodic patterns based on simple rules and many\ninteresting configuration settings, which can lead to very simple\nbut also most complex patterns. In order to better understand,\nhow the arpeggiator works, let's compare four different ways for\nconstructing melodies:\n\n{\\footnotesize\n\\begin{tabular}{p{27mm}|p{44mm}}\nSequencer & manually composed melodies \\\\ \\hline\nRandom generator & completely chaotic sequences \\\\ \\hline\nTuring machine,\n\\newline Algoquencer\n& pseudo-random melodies, which repeat themselves \\\\ \\hline\nArpeggiator & melodies constructed from rules \\\\\n\\end{tabular}}\n\nThe rules for the arpeggiator can be as simple as {\\it on each clock tick\nplay the next note in the C minor scale.} Additional parametes are for\nexample the pitch range, i.e. the start and the end note.\n\nThe arpeggiator shares root, scale and interval selection with {\\t chord} (see\npage \\pageref{chord}) and {\\t minifonion} (see page \\pageref{minifonion}).\nIf you own a Sinfonion: the arpeggiator in the DROID is working a bit\ndifferently and is more about general principles than about preprogrammed\npatterns.  That makes it more flexible and powerful.\n\n\\subsection*{The simplest possible example}\n\nAs always, we start with the simplest possible example. And it is simple,\nindeed, since each of the many parameters has a useful default value. The only\ninput the arpeggiator  {\\it always} needs is a clock input.  The word clock\nis probably a bit misleading since it doesn't {\\it need} to be a steady clock\nsignal. It can be any rhythmic pattern you like.  Each clock tick advances the\nmelody to the next note and a new pitch CV will be presented at {\\t output},\nwhich is, of course, in the typical 1V/oct scheme.\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nPatch {\\t I1} to an external clock and {\\t O1} to the 1V/oct of some\nsynth voice. The easiest way is to use the same clock also for triggering\nthe voice's envelope.\n\nNow you will hear a C major scale (lydian) being played step by step in a\nrange from 0~V to 2~V. This makes 15 notes, since the scale consists of the seven\nnotes C, D, E, F\\sharp, G, A and B and is repeated over two octaves, but the\nC is here three times: at the beginning, in the middle and at the end:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=18]\n\\repeat volta 2 {c'8 d' e' fis' g' a' b' c'' d'' e'' fis'' g'' a'' b'' c'''}\n\\end{lilypond}\n\nWhen it reaches the end it immediately starts over again. So the second ``bar''\nis really just 7 eights here!\n\n\n\\subsubsection*{Root, scale and interval selection}\n\nYou probably don't like lydian C major. Changing that is easy with the\ninputs {\\t root} and {\\t degree}. Please have a look at the {\\t minifonion}\ncircuit (see page \\pageref{minifonion}) for an explanation of these\nparameters. Let's go for a D minor (natural) scale as an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    root = 2}    root = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\end{droidini}\n\nNow we get:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  d'8\n  e' f' g' a' bes' c'' d'' e'' f'' g'' a'' bes'' c''' d'''}\n\\end{lilypond}\n\n\\subsubsection*{Patterns}\n\nThis ``go through the scale'' mode is just one of several possible patterns.\nThe pattern is selected with the {\\t pattern} input. And the default value\nof {\\t 0} produces the result we just have seen. Let's look at pattern\n{\\t 1}. This goes two steps forward and one step backward in the scale:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    root = 2}    root = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\immediate\\write\\patchexamples{    pattern = 1}    pattern = 1\n\\end{droidini}\n\nSince pattern 1 repeats its structure every three notes it's\nbest to display it in a metric that is divisible by three:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ \\time 6/8\n  d'8 ^\\markup {pattern 1}\n  e' f'\n  e' f' g'\n  f' g' a'\n  g' a' bes'\n  a' bes' c''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 2} is similar, but makes one double step forward instead\nof two single steps:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ d'8 ^\\markup {pattern 2}\n  f' e' g'\n  f' a' g' bes'\n  a' c'' bes' d''\n  c'' e'' d'' f''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 3} goes a double step forward, a double step backward and a\nsingle step forward:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ \\time 6/8\n  d'8 ^\\markup {pattern 3}\n  f' d' e' g' e' f' a' f' g' bes' g' a' c'' a' \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 4} is even more sophisticated. It goes a double step forward,\na single step forward, a double step {\\it backward} and again a single\nstep forward:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{\n  d'8 ^\\markup {pattern 4}\n  f' g' e'\n  f' a' bes' g'\n  a' c'' d'' bes'\n  c'' e'' f'' d''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 5} is a bit different since for each note it flips a coin\nfor deciding whether to go one step up or down.\n\nAnd Pattern {\\t 6} simply randomly chooses one of the possible notes. So\nstrictly spoken this has nothing to do with ``arpeggiation'', but it's\nfun, so what?\n\nNote: it's entirely impossibl that future versions of the arpeggiator\nintroduce new patterns. So better do not yet rely on these numbers to be\nfixed forever.\n\n\\subsubsection*{The range}\n\nPer default the pattern is played in a range of two octaves. But\nthat can be set easily with two parameters. {\\t pitch} defines the\nlowest possible pitch of a note. The arpeggiator will chose the\nstart note such that it is in the scale and just at or above this\npitch.\n\nAnd {\\t range} defines the voltage range the pattern is being played\nupwards until it starts again. So if {\\t range} is 2~V, you get a range\nof two octaves. A range of 0 will deform the pattern into one single\nnote.\n\nFor interactive playing, mapping {\\t pitch} and {\\t range} to pots\nis fun:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pitch = P1.1}    pitch = P1.1\n\\immediate\\write\\patchexamples{    range = P1.2}    range = P1.2\n\\end{droidini}\n\n\\subsubsection*{Changing the playing direction}\n\nSo far all pattern where going more or less upwards. From lower\nnotes to higher notes. This can be changed by setting {\\t direction}\nto {\\t 1}. Now the arpeggiator starts with the highest allowed note\nand reverses the pattern for going downwards. Why not map this\nsetting to a nice toggle button?\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    output = _DIRECTION}    output = _DIRECTION\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pitch = P1.1}    pitch = P1.1\n\\immediate\\write\\patchexamples{    range = P1.2}    range = P1.2\n\\immediate\\write\\patchexamples{    direction = _DIRECTION}    direction = _DIRECTION\n\\end{droidini}\n\nAnother setting that influences the direction is the {\\t pingpong}\nparameter. This is a binary (gate) input, too. If it is set to {\\t 1}\nthe direction of the pattern changes into the opposite once the end\nof the range has been reached. Check this example...\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pingpong = 1}    pingpong = 1\n\\immediate\\write\\patchexamples{    pitch = 0}    pitch = 0\n\\immediate\\write\\patchexamples{    range = 7/12V}    range = 7/12V\n\\end{droidini}\n\n... will create the following melody:\n\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 d' e' fis'\n  g' fis' e' d'\n}\n\\end{lilypond}\n\nWhy is that? Well -- $\\frac{7}{12}$~V is the same as 7 semitones,\nwhich is in turn one fifth. Since no root and degree are defined\nwe are back at C major lydian. The pattern is 0 (default) -- hence\nthe simple note-by-note scale. And {\\t pingpong = 1} makes the pattern\ngoing down again after having reached the upper limit.\n\n\\subsubsection*{Octaves up and down}\n\nThe nice thing about all these parameter is that you can combine\nthem all. They interact with each other and most combinations do\nuseful things (well, when using the ``random'' pattern, the direction\nand pingpong are without effect, of course). And there is one more\nfun setting: {\\t octaves}. This can be {\\t 0} (default) or {\\t 1} or\n{\\t 2}.\n\nWhen octaves is {\\t 1}, each note is directly followed by the same\nnote one octave above. That octave note is ignoring the {\\t range}-parameter.\nIt is always in addition to the selected range. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    range = 1V}    range = 1V\n\\immediate\\write\\patchexamples{    octaves = 1}    octaves = 1\n\\end{droidini}\n\nAnd here is the pattern this creates:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 ^\\markup {octaves = 1} c'' d' d'' e' e'' fis' fis''\n  g' g'' a' a'' b' b'' c'' c'''\n}\n\\end{lilypond}\n\nSet {\\t octaves = 2} and you get the same but the octaves go {\\it down}\ninstead:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 ^\\markup {octaves = 2} c d' d e' e fis' fis\n  g' g a' a b' b c'' c'\n}\n\\end{lilypond}\n\n\n\\subsubsection*{Dropping}\n\nThe {\\t drop} input lets you select different schemes of leaving out\nnotes from the original line of scale notes. For example {\\t drop = 1}\nwill leave out every second note. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    drop = 1}    drop = 1\n\\end{droidini}\n\nThis will create the following melody:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 e' g' b'\n  d'' f'' a'' c'''\n}\n\\end{lilypond}\n\nIf you have a closer look, you will see that in the upper octave other\nnotes are being played than in the lower octave. This can sound very\ninteresting!\n\nDropping can, of course, be combined with other patterns as well.\nLet's see the line for pattern 1:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  \\time 6/8\n  c'8 e' g'\n  e' g' b'\n  g' b' d''\n  b' d'' f''\n  d'' f'' a''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nThere are more dropping-schemes. Please have a look into the table\nof input parameters at the bottom.\n\n\\subsubsection*{Note selection}\n\nThe most important thing comes last. For didactical reasons! What {\\it really}\nmakes this arpeggiator so musically versatile is its interval selection.\nThis is the same as for the {\\t minifonion} (see page \\pageref{minifonion})\nand the chord generator (page \\pageref{chord}).\n\nThe point is that you are not restricted to the seven notes of a scale.\nFor this there are seven inputs {\\t select1}, {\\t select3}, ...\n{\\t select13} that select the notes of the current scale and\nanother five inputs {\\t selectfill1} ... {\\t selectfill5} that\nselect the notes not in the current scale.\nThese 12 inputs are binary inputs that expect either {\\t 0} or\none {\\t 1}. Each of them selects one of the seven intervals of the\nscale for being part of the chord. Here is a table of all these\ninputs and the notes they would select in a C major or C minor scale:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|c|c|c|}\\hline\nInput & interval & step & C$^{maj}$ & C$^{min}$ \\\\\n{\\t select1}  & root               & {\\tt I}   & C & C \\\\\n{\\t select3}  & \\nth{3}            & {\\tt III} & E & E\\flat \\\\\n{\\t select5}  & \\nth{5}            & {\\tt V}   & G & G \\\\\n{\\t select7}  & \\nth{7}            & {\\tt VII} & B & B\\flat \\\\\n{\\t select9}  & \\nth{9} = \\nth{2}  & {\\tt II}  & D & D \\\\\n{\\t select11} & \\nth{11} = \\nth{4} & {\\tt IV}  & F & F \\\\\n{\\t select13} & \\nth{13} = \\nth{6} & {\\tt VI}  & A & A\\flat \\\\\n\\hline\n\\end{tabular}}\n\nLet's make a simple example: The arpeggio of a C major {\\it triad}\nover two octaves going up and down again:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    select1 = 1}    select1 = 1\n\\immediate\\write\\patchexamples{    select3 = 1}    select3 = 1\n\\immediate\\write\\patchexamples{    select5 = 1}    select5 = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pingpong = 1}    pingpong = 1\n\\end{droidini}\n\nAnd here is the result:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  \\time 6/8\n  c'8 e' g'\n  c'' e'' g''\n  c''' g'' e''\n  c'' g' e'\n}\n\\end{lilypond}\n\n\nOne typical way to select these notes is with seven toggle buttons.\nMuch like the Sinfonion. Assign the output\nof each of the seven buttons to one of these functions:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led = L1.2}    led = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led = L1.3}    led = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led = L1.4}    led = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.5}    button = B1.5\n\\immediate\\write\\patchexamples{    led = L1.5}    led = L1.5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.6}    button = B1.6\n\\immediate\\write\\patchexamples{    led = L1.6}    led = L1.6\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.7}    button = B1.7\n\\immediate\\write\\patchexamples{    led = L1.7}    led = L1.7\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    select1 = L1.1}    select1 = L1.1\n\\immediate\\write\\patchexamples{    select3 = L1.2}    select3 = L1.2\n\\immediate\\write\\patchexamples{    select5 = L1.3}    select5 = L1.3\n\\immediate\\write\\patchexamples{    select7 = L1.4}    select7 = L1.4\n\\immediate\\write\\patchexamples{    select9 = L1.5}    select9 = L1.5\n\\immediate\\write\\patchexamples{    select11 = L1.6}    select11 = L1.6\n\\immediate\\write\\patchexamples{    select13 = L1.7}    select13 = L1.7\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow you can switch on and off scale notes for being part of\nthe patterns. Have fun!", "title": " Arpeggiator -- pattern based melody generator", "outputs": [{"default": null, "type": "voltperoctave", "name": "output", "description": "This is what it's all about: here comes the pitch CV for the\ncurrent arpeggio note.\n"}], "presets": 0}, "polytool": {"category": "sequencing", "inputs": [{"count": 16, "start_at": 1, "name": "pitchinput1 ... pitchinput16", "default": null, "prefix": "pitchinput", "type": "any", "description": "The pitches of up to 16 input voices.\n"}, {"count": 16, "start_at": 1, "name": "gateinput1 ... gateinput16", "default": null, "prefix": "gateinput", "type": "gate", "description": "The gates of up to 16 input voices.\n"}, {"default": "0", "type": "gate", "name": "roundrobin", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t pitchoutput1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophone. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n"}, {"default": "0", "type": "integer", "name": "voiceallocation", "description": "When from the pitch inputs, at any given time, more voice are active\nthan you have outputs assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|c|l|}\\hline\n{\\t 0} & The oldest note will be cancelled (default) \\\\ \\hline\n{\\t 1} & The new note will not be played and simply be omitted \\\\ \\hline\n{\\t 2} & The lowest note will be cancelled \\\\ \\hline\n{\\t 3} & The highest note will be cancelled \\\\ \\hline\n\\end{tabular}\n\\vspace{2mm}\n"}], "description": "", "title": " Change number of voices in polyphonic setups", "outputs": [{"count": 16, "start_at": 1, "name": "pitchoutput1 ... pitchoutput16", "default": null, "prefix": "pitchoutput", "type": "any", "description": "The pitches of up to 16 output voices.\n"}, {"count": 16, "start_at": 1, "name": "gateoutput1 ... gateoutput16", "default": null, "prefix": "gateoutput", "type": "gate", "description": "The gates of up to 16 output voices.\n"}], "presets": 0}, "midiin": {"category": "midi", "inputs": [{"default": "unpatched", "type": "integer", "name": "channel", "description": "Only execute / play commands from a certain MIDI channel.\nThere are 16 MIDI channels. It ranges from {\\t 1}\nto {\\t 16}.\n"}, {"default": "off", "type": "gate", "name": "tuningmode", "description": "If set to {\\t 1}, all pitch outputs will go to the CV\nselected for {\\t tuningpitch} (which defaults to 2~V),\nand all\ngate outputs will play gates at 120 BPM. This helps getting\nall attached voices tuned when working with many voices.\n"}, {"default": "0.2", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "Transposes all output pitches by this value by adding\nthe value. So in order to transpose one octave\ndown, set this input to {\\t -1V} or {\\t -0.1}. Changes in the\ntransposition are immediately reflected, even for currently\nalready active notes.\n"}, {"default": "0", "type": "gate", "name": "holdvelocity", "description": "If this is set to {\\t 1}, the velocity output for a voice\nwill not be affected by note off events. It's just altered\nat the beginning of new notes.\nThe velocity is kept after the note ends.\nThis way during the release phase of an envelope triggered\nby the gate, the original velocity still lasts on. In most cases\nthe note off velocity is set to 0, which would\nimmediately cut off the release phase when the velocity is patched\ninto a VCA.\n"}, {"default": "$\\frac{1}{6}$V", "type": "voltperoctave", "name": "pitchbendrange", "description": "Sets the value to the desired maximum that {\\t pitchbend}\nshould output, and likewise it's negative counterpart at its minimum\nvalue. At the middle position it always outputs 0. This defaults\nto $\\frac{2}{12}$~V, which corresponds to one whole tone. Note:\nsetting this to a negative value is allowed and will invert\npitch bend.\n"}, {"default": "1", "type": "gate", "name": "bendpitch", "description": "When set to {\\t 1} (which is the default), the pitch bend\nwill directly be applied to all output pitches. Alternatively\nyou can set it to {\\t 0} and use the output {\\t pitchbend},\nfor using it elsewhere.\n"}, {"default": "0", "type": "gate", "name": "roundrobin", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t output1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophone. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n"}, {"default": "0", "type": "integer", "name": "voiceallocation", "description": "When the MIDI stream, at any given time, needs to play more notes\nthan you have voices assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|c|l|}\\hline\n{\\t 0} & The oldest note will be cancelled (default) \\\\ \\hline\n{\\t 1} & The new note will not be played and simply be omitted \\\\ \\hline\n{\\t 2} & The lowest note will be cancelled \\\\ \\hline\n{\\t 3} & The highest note will be cancelled \\\\ \\hline\n\\end{tabular}\n\\vspace{2mm}\n"}, {"default": "0", "type": "cv", "name": "notegap", "description": "When your MIDI devices plays a note so ``long'' that it lasts\nexactly until the next note begins -- or if due to a lack of\nused pitch outputs one currently played note has to be replaced\nwith a new one, the {\\t gate} output will have no time to go\nlow for a sufficient time between the two notes. In effect it\nwon't trigger any envelope for the new note but will do a ``legato''.\n\nIf you don't like this, you can use {\\t notegap}. This input specifies\na number of {\\bf milliseconds} that the gate will be forced down\nbefore the new note begins. This has the drawback of introducing some\nlatency, of course! So I suggest that you start with {\\t notegap =\n1} and then check out if your envelope is fast enough to trigger.\nIf not, increase the value.\n\nIf you are using \\droid's own {\\t contour} circuit or trigger something\nelse internally in your patch, you can use {\\t notegap = 0.1}. That is\nsufficient and introduces barely any latency.\nJust a value of {\\t 0.0} keeps the default of the legato mode.\n\nNote: the {\\t notegap} parameter does not affect the {\\t trigger}\noutputs.\n"}, {"count": 4, "start_at": 1, "name": "ccnumber1 ... ccnumber4", "default": "0", "prefix": "ccnumber", "type": "integer", "description": "You can {\\it listen} to up to four CCs (control changes). For example\nif you are interested in the current value of CC\\#17, set\n{\\t ccnumber1 = 17} and use the output {\\t cc1} for getting the value\nof CC 17.\n"}, {"default": "0", "type": "integer", "name": "lowestnote", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n"}, {"default": "127", "type": "integer", "name": "highestnote", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. The ``Notegates'' are not being affected by this bound.\n"}, {"count": 16, "start_at": 1, "name": "note1 ... note16", "default": "unpatched", "prefix": "note", "type": "integer", "description": "Selects up to 16 individual notes for which you can get a\ndedicated gate signal. Per default these values are set to\n{\\t 0} for {\\t note1} (meaning C-2), {\\t 1} for {\\t note2}\n(meaning C$\\sharp$-2) and so on. For each of these notes\nyou get a corresponding gate output (see {\\t notegate1}, {\\t notegate2}, etc.).\nThese gates are high as long as the selected notes are being hold.\nOne application is to use just one {\\t midifileplayer} or {\\t midiin}\ncircuit for sequencing up to 16 drum voices. Another application is\nto use a MIDI keyboard or controller as a button expander -- just\nlike a P2B8 or B32.\n"}, {"default": "0", "type": "gate", "name": "usb", "description": "Selects the physical port to receive MIDI data.  The default\nis {\\t usb = 0}, which selects the TRS (3.5mm stereo jack) port of\nthe X7. Set {\\t usb = 1} for receiving data from the USB-C port.\n"}, {"default": "unpatched", "type": "integer", "name": "channel", "description": "Select the MIDI channel to listen on. Default is to listen\non {\\it all} channels -- and basically ignore the channel number.\nThere are 16 channels, numbered from 1 to 16.\n"}, {"default": null, "type": "trigger", "name": "systemreset", "description": "A trigger here resets the whole MIDI state of this circuit.\nIt does the same as a MIDI RESET message: It stops all\nplaying note, resets the controllers, the states of the\npedals and so on.\n"}], "description": "This circuit converts incoming MIDI data into CV, gate and trigger signals.\nIt needs the {\\bf X7} expander in order to work (see page \\pageref{x7} for\ngeneral information about the X7).\n\nThere are various useful applications of this circuit, some of which are:\n\\begin{itemize}\n\\item Attaching an external keyboard to your modular.\n\\item Using an external hardware sequencer for playing melodies and beats in your modular.\n\\item Use an external MIDI controller to influence your \\droid patch.\n\\item Use your phone or tablet as a MIDI controller to influence your patch (via USB).\n\\item Connect two DROIDs (both with X7) and exchange real time data.\n\\end{itemize}\n\nThe X7 MIDI implementation is very comprehensive and gives you convenient\naccess to most of the MIDI features. Please refer to the table of\ninputs and outputs for details. Here are just some very basic examples:\n\n\\subsubsection*{Basic operation}\n\nThe basic operation is quite simple. Per default {\\t midiin} listens on the\n3.5~mm TRS jack of the X7. The following example controls one synth voice\nby converting MIDI note on / note off messages into CV / gate signals:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\end{droidini}\n\nIt's really as simple as that! Connect your MIDI keyboard or sequencer\nwith the X7 MIDI input, wire {\\t O1} to the 1V/Oct input of a synth voice\nand {\\t O2} to its gate input and enjoy your music!\n\nWhen you add {\\tt usb = 1} you can get a MIDI stream via the USB-C port\non the X7 instead of the TRS jack.\n\n\\subsubsection*{Polyphonic patches}\n\nDo you have more than one synth voice to control? Then you can play\nseveral notes at the same time by using up to {\\it eight} {\\t pitch} and {\\t gate} outputs.\nHere is an example with three voices, which uses a G8 expander\nfor the gates:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    pitch1 = O1}    pitch1 = O1\n\\immediate\\write\\patchexamples{    pitch2 = O2}    pitch2 = O2\n\\immediate\\write\\patchexamples{    pitch3 = O3}    pitch3 = O3\n\\immediate\\write\\patchexamples{    gate1 = G1}    gate1 = G1\n\\immediate\\write\\patchexamples{    gate2 = G2}    gate2 = G2\n\\immediate\\write\\patchexamples{    gate3 = G3}    gate3 = G3\n\\end{droidini}\n\nHere the parameters {\\t roundrobin} and {\\t voiceallocation} are interesting.\n{\\t roundrobin} influences which of the three outputs should be used for the\nnext note, in situations where more than one is free.  {\\t voiceallocation},\nin contrast, controls what should happen if the MIDI stream wants to play\nmore simultaneous notes than you have setup in {\\t midiin}.  The default\nis to cancel the oldest currently playing note, but you can change that\nbehaviour in various ways.\n\n\\subsubsection*{Sequencing drums and triggers}\n\nWhen you use a MIDI sequencer for triggering drums, often each drum voice\n(bass drum, snare drum, etc.) is triggered by a certain note, for example\nC-2 for the bass drum, C$\\sharp$-2 for the snare drum and so on. In this\ncase it is more convenient to use the {\\t notegate} outputs. Check the\nfollowing example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    note2 = 25}    note2 = 25\n\\immediate\\write\\patchexamples{    notegate1 = O1}    notegate1 = O1\n\\immediate\\write\\patchexamples{    notegate2 = O2}    notegate2 = O2\n\\end{droidini}\n\nNow whenever note 24 is played by the sequencer, {\\t notegate1} will trigger.\nThe note numbers range from 0 to 127, with 0 being the lowest note and 127 the\nhighest. The MIDI standard specifies that note 0 is usually C-2 (two octaves\nbelow C0). So note {\\t 24} would be C0 and note {\\t 25} C$\\sharp$0.\n\nAnother application of note gates is to use keys on a MIDI keyboard or touch\npads of a MIDI controller as buttons in your \\droid patch! In fact the {\\t\nbutton} circuit can be wired to such note gates. It's just that you don't\nhave a corresponding LED.  But you can use the \\droid's own LEDs for that.\n\nThe following example uses the note 24 in order to toggle a (virtual) button\nand use the first input LED of the master as LED for the button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    notegate1 = _NOTE24}    notegate1 = _NOTE24\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = _NOTE24}    button = _NOTE24\n\\immediate\\write\\patchexamples{    led = R1}    led = R1\n\\immediate\\write\\patchexamples{    output = _SOMETHING # ...}    output = _SOMETHING # ...\n\\end{droidini}\n\nPlease note: {\\t midiout} has similar {\\t note1} ... {\\t note8} inputs.\nBut there the pitches are specified in 1V/Oct. So don't mix them up!\n\n\n\\subsubsection*{Start, Stop and Clock}\n\nMIDI sequencers usually send a steady MIDI clock at 24 PPQ, which means\n24 pulses per quarter note, which in turn means 6 pulses per \\nth{16} note,\nwhich is the typical clock speed for modular systems. But also 48~PPQ and\n96~PPQ are possible.\n\nYou get easy access to the clock by various clock outputs running at\ndifferent speeds. The jack labelled just {\\tt clock} outputs the \\nth{16}\nnote clock. The following example just sends that clock to the O1 output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    clock = O1}    clock = O1\n\\end{droidini}\n\nHereby it is assumed that the MIDI clock is running at 24~PPQ. If its running\nfaster, simply use one of the other clock outputs, which divides down the\nclock. Or use \\circuit{clocktool} for dividing yourself.\n\nAlso the START and STOP messages of MIDI sequencers are accessible, either\nas two separate triggers, or as a running state. For example you can use\nthe {\\t start} output as a reset signal for some \\droid circuit:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    start = _RESET}    start = _RESET\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = _RESET}    reset = _RESET\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\\subsubsection*{Getting CCs}\n\nMIDI does not only transport note events but also {\\it controllers}. Most\nof these are continuous values, much like CVs. {\\t midiin} gives you access\nto the current value of a couple of standard controllers like {\\t volume}\nand {\\t modwheel} with dedicated outputs. And in addition up to four custom\nCCs can be output. All such controllers are converted into values from 0\nto 1 (or 0~V to 10~V if you output them directly):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    volume = O1}    volume = O1\n\\immediate\\write\\patchexamples{    modwheel = O2}    modwheel = O2\n\\immediate\\write\\patchexamples{    ccnumber1 = 10 # get update from CC#10}    ccnumber1 = 10 # get update from CC#10\n\\immediate\\write\\patchexamples{    cc1 = O3 # send current CC value to O3}    cc1 = O3 # send current CC value to O3\n\\end{droidini}\n\n\\subsubsection*{Using multiple midiins}\n\nYou are not restricted to one {\\t midiin} circuit but can use up to {\\bf 32}\nof these in your patch. There are different reasons why multiple ones can\nbe useful, e.g.:\n\n\\begin{itemize}\n\\item You want to control different voices from different MIDI channels\n\\item You want to fetch more than four CCs.\n\\end{itemize}\n\nAll {\\t midiin} circuits will get their own copy of the MIDI data stream\nand can do their own things with it. You might want to use {\\t channel =\n...} in order to just get only the events of a specific MIDI channel.\n\n\\subsubsection*{Pedals}\n\nThe MIDI standard defines five different types of food pedals. The state\nof these -- up or down -- is transmitted by means of five different control\nchanges (CCs). {\\t midiin} automatically interpretes them corresponding to\ntheir intended meaning as follows:\n\n\\begin{itemize}\n\\item {\\it Damper pedal} (CC 64): While down, notes still linger on, even if\n  they end. Internally, the ``note off'' event of all notes will be delayed\n  until the pedal is up. This pedal is sometimes also called ``sustain pedal'',\n  since it makes notes sustain.\n\n\\item {\\it Portamento pedal} (CC 65): Sets the {\\t portamento} output\n  to {\\t 1} while down. You can use that output for enabling a slew\n  limiter with the circuit \\circuit{slew}.\n\n\\item {\\it Sostenuto pedal} (CC 66): Sostenuto is the smarter version\n  of sustain. Such a pedal is found as the middle of three pedals on grand\n  pianos. When it {\\it goes} down, all notes that are {\\it currently played}\n  are sustained as long as the pedal is held. But {\\it new} notes, that start\n  during that period, at {\\it not} sustained. That's the difference. The {\\t\n  midiin} circuit automatically makes CC 66 behave in exactly that way. That,\n  of course, just makes sense in a polyphonic patch, where you have enough\n  voice that can play the sustained notes.\n\n\\item {\\it Soft pedal} (CC 67): Sets the {\\t soft} output to {\\t 1} while held.\n\n\\item {\\it Legato pedal} (CC 68):\n  While down, ties consequtive notes together by keeping {\\t gate} at {\\t 1} between\n  notes.\n\n\n\\end{itemize}\n\n\n\n\\clearpage", "title": " MIDI to CV converter", "outputs": [{"count": 8, "start_at": 1, "name": "pitch1 ... pitch8", "default": null, "prefix": "pitch", "type": "voltperoctave", "description": "Pitch outputs. Since MIDI tracks can be polyphonic -- i.e. play\nseveral notes at the same time -- you can assign up to eight outputs\nhere. The notes will be distributed to the defined outputs\naccording to the settings {\\t roundrobin} and {\\t voiceallocation}.\n"}, {"count": 8, "start_at": 1, "name": "velocity1 ... velocity8", "default": null, "prefix": "velocity", "type": "fraction", "description": "For each voice there is an optional velocity output, which\ntranslates the MIDI velocity into values from 0 to 1.\n"}, {"count": 8, "start_at": 1, "name": "pressure1 ... pressure8", "default": null, "prefix": "pressure", "type": "fraction", "description": "MIDI provides two different messages for sending \"after-touch\"\ninformation, i.e. information about how strong a key is pressed\ndown after the initial hit. Some keyboards just have one pressure\nsensor in total and send the current maximum pressure information\nof all keys in one message (``channel pressure''). Others have\none pressure sensor per key and send ``polyphonic key pressure''\nmessages. This circuit maps both to a {\\t pressure} output\nper note that is being played. So if your keyboard (or sequencer\nor DAW or whatever) sends polyphonic key pressure events and\nyou use multiple {\\t pitch}{\\it X} outputs, wire the individual\n{\\t pressure}{\\it X} outputs to wherever you like. Otherwise\nyou can simply use {\\t pressure1} for all notes (which can\nbe abbreviated with {\\t pressure}), since it is the same for\nall note outputs anyway. {\\t pressure} outputs a value from\n0 to 1.\n"}, {"count": 8, "start_at": 1, "name": "gate1 ... gate8", "default": null, "prefix": "gate", "type": "gate", "description": "Gate outputs for the up to eight simultaneous note outputs.\n"}, {"count": 8, "start_at": 1, "name": "trigger1 ... trigger8", "default": null, "prefix": "trigger", "type": "trigger", "description": "Trigger outputs for the up to eight simultaneous note outputs. The\ndifference to the gate outputs is, that these just send a short\ntrigger of 5~ms at the start of the note. This can be interesting\nin situations where the notes have no {\\it gaps} in between so\nthat gate will never go low.\n"}, {"count": 4, "start_at": 1, "name": "cc1 ... cc4", "default": null, "prefix": "cc", "type": "fraction", "description": "Outputs the current value of the four CC number that are defined\nwith the inputs {\\t ccnumber1} ... {\\t ccnumber4}. CCs have a\nrange from 0 to 127, but this is converted in the range 0.0 .. 1.0\nhere, in order to make it easier to use that as a CV. If you need\nthe raw number, multiply the output with 127. Note: as long as no CC\nmessage with the selected number happened, this output will be set\nto 0.\n"}, {"count": 16, "start_at": 1, "name": "notegate1 ... notegate16", "default": null, "prefix": "notegate", "type": "gate", "description": "Outputs a high gate whenever the corresponding note (which is\nselected by {\\t note1} through {\\t note16}) is currently being played.\n"}, {"default": null, "type": "cv", "name": "pitchbend", "description": "Outputs the current pitch bend value as a bipolar voltage.\nThe range can be set with {\\t pitchbendrange}.\n"}, {"default": null, "type": "trigger", "name": "programchange", "description": "Sends a trigger whenever a {\\it MIDI program change} message\narrives. Just before sending the trigger sets {\\t program} to\nthe new program number (something from 0 to 127). Note: This\ntrigger is also being output when the program change messages\nsends the same program number as previously, i.e. if there\nis no actual {\\it change}.\n"}, {"default": null, "type": "integer", "name": "program", "description": "The number of the last program change. This starts at {\\t 0}.\n"}, {"default": null, "type": "integer", "name": "bank", "description": "Outputs the number of the currently selected bank -- from\n0 to 16384. MIDI defines the MSB of the bank to be changed\nwith CC\\#0 and the LSB with CC\\#32. That means if you just\nuse CC\\#0, you will only be able to select the banks 0, 128,\n256, and so on. As long as no bank select CC has been received,\n{\\t bank} will output 0.\n"}, {"default": null, "type": "fraction", "name": "modwheel", "description": "Output the current state of the mod wheel level -- within\nthe range from {\\t 0.0} to {\\t 1.0}. The mod wheel is changed\nby MIDI control change 1.\n"}, {"default": null, "type": "fraction", "name": "volume", "description": "Outputs the current global volume as set by MIDI control change 7.\n"}, {"default": null, "type": "gate", "name": "portamento", "description": "This output gives you access to the current state of\nthe ``portamento pedal'' (MIDI CC 65). You can use it to\nenable an external slew limiter for creating portamento\neffects (see page \\pageref{slew}).\n"}, {"default": null, "type": "gate", "name": "soft", "description": "This output gives you access to the current state of\nthe ``soft pedal'' (MIDI CC 67). It is {\\t 1} while the pedal\nis hold and {\\t 0} otherwise.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "If the MIDI sender sends a MIDI clock, you get a \\nth{16}\nnote clock output here. This is the same as the {\\t clock16} jack\nand just a convenient abbreviation.\n"}, {"default": null, "type": "trigger", "name": "clock8", "description": "Gets an \\nth8 clock here (like {\\t clock} divided by 2)\n"}, {"default": null, "type": "trigger", "name": "clock8t", "description": "Gets a \\nth8 triplets clock here. This is faster than\n{\\t clock8} but slower than {\\t clock}.\n"}, {"default": null, "type": "trigger", "name": "clock16", "description": "The same as {\\t clock}: a clock running at \\nth{16} notes.\n"}, {"default": null, "type": "trigger", "name": "clock4", "description": "A clock at the speed of quarter notes.\n"}, {"default": null, "type": "trigger", "name": "midiclock", "description": "Here you get the original MIDI clock. This is 6 times\nfaster than {\\t clock} and 24 times faster than {\\t clock4}. This\nis because the MIDI clock is specified to run at 24 PPQ, i.e.\n24 pulses per quarter note.\n"}, {"default": null, "type": "trigger", "name": "start", "description": "This jack sends a trigger when a MIDI START message arrives.\n"}, {"default": null, "type": "trigger", "name": "continue", "description": "This jack sends a trigger when a MIDI CONTINUE message arrives.\n"}, {"default": null, "type": "trigger", "name": "stop", "description": "This jack sends a trigger when a MIDI STOP message arrives.\n"}, {"default": null, "type": "gate", "name": "running", "description": "This jack remembers the current running state according to\nprevious START and STOP messages.\n"}, {"default": null, "type": "gate", "name": "active", "description": "If the sending device supports {\\t active sensing}, this output\nis high as long as a device is connected. Otherwise its high if\nat least one MIDI message has been received.\n"}], "presets": 0}, "minifonion": {"category": "pitch", "inputs": [{"default": "0", "type": "integer", "name": "root", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n"}, {"default": "0", "type": "integer", "name": "degree", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n"}, {"default": "unpatched", "type": "gate", "name": "select1", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n"}, {"default": "unpatched", "type": "gate", "name": "select3", "description": "Gate input for selecting the \\nth{3}.\n"}, {"default": "unpatched", "type": "gate", "name": "select5", "description": "Gate input for selecting the \\nth{5}.\n"}, {"default": "unpatched", "type": "gate", "name": "select7", "description": "Gate input for selecting the \\nth{7}.\n"}, {"default": "unpatched", "type": "gate", "name": "select9", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n"}, {"default": "unpatched", "type": "gate", "name": "select11", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n"}, {"default": "unpatched", "type": "gate", "name": "select13", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n"}, {"default": "off", "type": "gate", "name": "selectfill1", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n"}, {"default": "off", "type": "gate", "name": "selectfill2", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill3", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n"}, {"default": "off", "type": "gate", "name": "selectfill4", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "selectfill5", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n"}, {"default": "off", "type": "gate", "name": "tuningmode", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n"}, {"default": "0", "type": "voltperoctave", "name": "tuningpitch", "description": "This pitch CV will be output while the tuning mode\nis active.\n"}, {"default": "0", "type": "voltperoctave", "name": "transpose", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n"}, {"default": "0", "type": "voltperoctave", "name": "input", "description": "Patch the unquantized input voltage here\n"}, {"default": null, "type": "trigger", "name": "trigger", "description": "This jack is optional. If you patch it, the Minifonion will\nwork in triggered mode. Here the output pitch is always frozen until the\nnext trigger happens.\n"}, {"default": "off", "type": "gate", "name": "bypass", "description": "If you set this gate input to {\\t 1} then quantization is bypassed\nand the input voltage is directly copied to the output.\n"}, {"default": "0", "type": "integer", "name": "noteshift", "description": "Shifts the output note {\\bf after} the quantization by this\nnumber of {\\it scale} notes up or down (if negative). So the output\nnote still is part of the scale but may be a note that is none\nof the selected ones. {\\t noteshift} is applied when quantization\ntakes places, so it also is sensible to the {\\t trigger} input.\n"}, {"default": "0", "type": "integer", "name": "selectnoteshift", "description": "Shifts the output note {\\bf after} the quantization by this\nnumber of {\\it selected} scale notes up or down (if negative).\nIf you use {\\t noteshift} at the same time, {\\it first} {\\t\nselectnoteshift} is applied, then {\\t noteshift}.\n{\\t selectnoteshift} is applied when quantization\ntakes places, so it also is sensible to the {\\t trigger} input.\n"}], "description": "This circuit is a very musical quantizer that gently moves any input CV\n(pitch information on a 1V/oct base) into selected notes of a musical scale.\nTypically the input CV is coming from a random source, LFO, melody generator\nor sequencer.\n\nIn fact the Minifonion is very similar to each of the the three quantizer\nchannels in the Audiophile Circuit League {\\it Sinfonion} -- just without\nthe user interface and more flexible. It has Sinfonion compatible CVs for\nthe root note and the scale selection so it can easily be combined with it\nas long as you control the Sinfonion via CV and stick to the first mode. But\nof course you do not need a Sinfonion in order to use this circuit!\n\nIf you want to mimick a Sinfonion with the \\droid you might also be interested\nin the circuits \\circuit{arpeggio} and \\circuit{chords}.\n\nHere is the simplest possible application -- a quantization of some (random)\ninput pitch at {\\t I1} to the seven notes of a C lydian major scale.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\end{droidini}\n\nNow let's change the root note to D (2 semitones above C) and\nthe scale to natural minor, so that we now quantize to a\nD minor scale:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    root   = 2}    root   = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\end{droidini}\n\nAnd here is the table of all 12 scales of the Minifonion. These\nare exactly the same scales as those in the first mode (called {\\it Chords})\nof the Sinfonion:\n\n\\begin{center}\n\\begin{tabular}{|r|l|l|} \\hline\n{\\t degree} & \\footnotesize Abbr. & Scale \\\\ \\hline\n\\t  0 & lyd & Lydian major scale (it has a $\\sharp 4$) \\\\ \\hline\n\\t  1 & maj & Normal major scale (ionian)     \\\\ \\hline\n\\t  2 & X$^7$ & Mixolydian (dominant seven chords) \\\\ \\hline\n\\t  3 & sus & mixolydian with \\nth3/\\nth4 swapped \\\\ \\hline\n\\t  4 & alt & Altered scale \\\\ \\hline\n\\t  5 & hm$^5$ & Harmonic minor scale from the \\nth5 \\\\ \\hline\n\\t  6 & dor & Dorian minor (minor with $\\sharp 13$) \\\\ \\hline\n\\t  7 & min & Natural minor (aeolian) \\\\ \\hline\n\\t  8 & hm & Harmonic minor ($\\flat 6$ but $\\sharp 7$) \\\\ \\hline\n\\t  9 & phr & Phrygian minor scale (with $\\flat 9$) \\\\ \\hline\n\\t 10 & dim & Diminished scale (whole/half tone) \\\\ \\hline\n\\t 11 & aug & Augmented scale (just whole tones) \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\nIf you are a Sinfonion user, please note that the inputs {\\t root} and {\\t\ndegree} of the Minifonion are {\\it not} based on semitones like the Sinfonion,\nbut simply expect whole numbers like {\\t 0}, {\\t 1}, {\\t 2} and so on (which\ncorresponds to the CVs 0V, 10V, 20V, etc.). So if you want those CV inputs\nto be compatible, you have to multiply the values with the factor of 120\nbefore sending them to the Minifonion:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    root   = I2 * 120 # base on semitones}    root   = I2 * 120 # base on semitones\n\\immediate\\write\\patchexamples{    degree = I3 * 120 # base on semitones}    degree = I3 * 120 # base on semitones\n\\end{droidini}\n\n\\clearpage", "title": " Musical quantizer", "outputs": [{"default": null, "type": "voltperoctave", "name": "output", "description": "Here comes your quantized output voltage\n"}, {"default": null, "type": "trigger", "name": "notechange", "description": "Whenever the quantization changes to a new note a trigger\nwith the duration 10~ms is output here. No trigger is\noutput in bypass mode.\n"}], "presets": 0}, "togglebutton": {"category": "ui", "inputs": [{"default": null, "type": "trigger", "name": "button", "description": "The actual push button. Usually you want to wire this to {\\t B1.1},\n{\\t B1.2} and so on: to one of the push buttons of your\ncontrollers. Each time that\ninput goes from low to high the state of the push button will toggle.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "A positive trigger edge here will reset the\nbutton into the state ``not pressed'' -- regardless of\nits current state\n"}, {"default": "1", "type": "cv", "name": "onvalue", "description": "Value sent to {\\t output} when the push button is on. Setting this to a\ndifferent value than the default value saves you attenuating its value\nlater on when you use it as a CV.\n"}, {"default": "0", "type": "cv", "name": "offvalue", "description": "Value sent to {\\t output} when the push button is off.\n"}, {"default": "off", "type": "gate", "name": "doubleclickmode", "description": "This input can enable a {\\it double click mode} when set to {\\t 1}.\nIn that mode the button only toggles it's constant state if you double\npress it in a short time. Otherwise it behaves like a momentary button,\nthat inverts the persisted state (which you toggle with the double click).\n"}, {"default": null, "type": "gate", "name": "startvalue", "description": "State of the push button when you switch on your system. Setting this\nto {\\t on} or {\\t off} will force the button into that state. Using this\njack disables the persistence of the state! In switched mode this will\nbe used for the other button layers as well.\n"}], "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit {\\t\nbutton} (see page \\pageref{button}). {\\t button} can do all {\\t togglebutton}\ncan do and much more. So {\\t togglebutton} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis small utility circuit converts a normal push button into a\ntoggle button that is either {on} or {off}. It toggles its state\nevery time the button is being pressed. It even can persist the current\nstate of the button in the \\droid's internal flash memory, so at the\nnext time you start your modular the button will have the same state\nas just before you switched it off.\n\nTypically you will wire {\\t button} to one of your controllers' buttons like\n{\\t B1.1} and {\\t led} to the LED in that button ({\\t L1.1}). LED will\nthen always visualise the current state of the button.  As a side effect\nthe LED register {\\t L1.1} will store the button state as a value {\\t 0}\nor {\\t 1} and hence can be used by some other \\droid as an input.\n\nHere is a typical example. The button is being used for enabling\nthe loop in the CV looper:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop        = L1.4}    loop        = L1.4\n\\end{droidini}\n\nIf you do not want the state of the button to be persisted in\nthe \\droid's flash memory then use {\\t startvalue} for setting\na start value. This make sense for the CV looper since the loop\nis apparently empty anyway if you start your \\droid. By the way:\n{\\t off} is a synonym for {\\t 0}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button     = B1.4}    button     = B1.4\n\\immediate\\write\\patchexamples{    led        = L1.4}    led        = L1.4\n\\immediate\\write\\patchexamples{    startvalue = off}    startvalue = off\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop       = L1.4}    loop       = L1.4\n\\end{droidini}\n\nSince a multiplication with {\\t 0} or {\\t 1} can switch off or on\na signal you can use the LED register directly for enabling a signal.\nThe next example uses a button for switching between 0 V and the\noutput of an LFO:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    level       = L1.4 # 0 or 1}    level       = L1.4 # 0 or 1\n\\immediate\\write\\patchexamples{    sine        = O1}    sine        = O1\n\\end{droidini}\n\nUsually the toggle button switches between the two values {\\t 0}\nand {\\t 1}. Sometimes you need different values. Therefore there\nare the two inputs {\\t offvalue} and {\\t onvalue} for two alternative\nvalues for these two states and the output {\\t output1} where you\ncan fetch that value (since {\\t led} will continue to send {\\t 0}\nor {\\t 1} in order for the LED to work properly). Here is an example\nfor a toggle button that switches a clock divider between {\\t 2} and\n{\\t 4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{    offvalue    = 2}    offvalue    = 2\n\\immediate\\write\\patchexamples{    onvalue     = 4}    onvalue     = 4\n\\immediate\\write\\patchexamples{    output      = _CLOCK_DIV}    output      = _CLOCK_DIV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    input       = G1 # external clock}    input       = G1 # external clock\n\\immediate\\write\\patchexamples{    output      = G2}    output      = G2\n\\immediate\\write\\patchexamples{    divide      = _CLOCK_DIV}    divide      = _CLOCK_DIV\n\\end{droidini}\n\nOf course {\\t offvalue} and {\\t onvalue} are CV controllable. How can\nmake this sense? Well -- as they can take variable inputs you can use\na togglebutton for directly switching between two different input CV signals.\nThe following example will send two different wave forms of an LFO to\n{\\t O1}. The button {\\t B3.1} switches between sawtooth and sine:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    offvalue    = _SAWTOOTH}    offvalue    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    onvalue     = _SINE}    onvalue     = _SINE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nHint: if you need to have not only two but three or four different states\nfor your button then have a look at the circuit {\\t button}.\n\n\\subsubsection*{Buttons with up to four layers}\n\nThe toggle button can overloaded with up to four functions. For switching\nbetween these layers you need a CV. This example assigned three different\nlayers to one button. Each layer has its own state.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button    = B1.4}    button    = B1.4\n\\immediate\\write\\patchexamples{    led       = L1.4}    led       = L1.4\n\\immediate\\write\\patchexamples{    output1   = _ENABLE_LOOP}    output1   = _ENABLE_LOOP\n\\immediate\\write\\patchexamples{    output2   = _FANCY_STUFF}    output2   = _FANCY_STUFF\n\\immediate\\write\\patchexamples{    output3   = _FOO_BAR}    output3   = _FOO_BAR\n\\immediate\\write\\patchexamples{    switch    = I1 * 2}    switch    = I1 * 2\n\\end{droidini}\n\nNow if {\\t I1} is near zero volts, then the button behaves like in the\nprevious example. But when you set it to 5 V (resulting in a number of\n{\\t 0.5} which is multiplied by {\\t 2} and thus evaluates to {\\t 1}),\nthen a second copy of the button is activated with its own state. The LED\nnow shows the state of that second button which {\\t output} will outputs\nthe value of the first button.", "title": " Create on/off buttons (OBSOLETE)", "outputs": [{"default": null, "type": "gate", "name": "led", "description": "When the button's state is on a value of {\\t 1.0} will be sent to that\noutput -- regardless of the values in {\\t onvalue}\nand {\\t offvalue}. Usually you will wire this jack to the\nLED within the button, e.g. to {\\t L1.1}, {\\t L1.2}\nand so on\n"}, {"default": null, "type": "cv", "name": "output", "description": "This jack will output either {\\t onvalue} or {\\t offvalue}\ndepending on the\nstate of the \\nth1 ... \\nth4 button.\nIf you have not wired those inputs then this is\nthe same as the {\\t led} output.\n"}, {"default": null, "type": "cv", "name": "inverted", "description": "The same as {\\t output1}, but sends {\\t onvalue} when the\nbutton is off and {\\t offvalue} when the button is on.\nNote: there is no inverted version of {\\t output2} ... {\\t output4}.\n"}, {"default": null, "type": "gate", "name": "negated", "description": "Similar to {\\t inverted}, but always sends {\\t 1} when the button\nis off and {\\t 0} when the button is on -- independent of the values\nof {\\t onvalue} and {\\t offvalue}.\n"}], "presets": 0}, "triggerdelay": {"category": "clock", "inputs": [{"default": "0", "type": "gate", "name": "input", "description": "Patch triggers or gates to be delayed here.\n"}, {"default": "1", "type": "cv", "name": "delay", "description": "Amount of time the trigger is being delayed. When {\\t clock} is\nnot patched, this is in {\\it seconds}. So in order to delay by 100~ms\nyou need a delay of {\\t 0.1}, for example.\n"}, {"default": "unpatched", "type": "cv", "name": "gatelength", "description": "Unless you patch this jack the length of the output gates is\nexactly the length of the input gates. By use of this parameter you\noverride that length and set a fixed length in {\\it seconds} -- or\nif {\\t clock} is being used -- in clock cycles.\n"}, {"default": "1", "type": "integer", "name": "repeats", "description": "Number of times the delayed trigger is being repeated. Each\nfurther repetition is with the same delay.\n"}, {"default": "0", "type": "gate", "name": "mute", "description": "A high gate signal suppresses any further output gates. The current\ngate is finished normally, however.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "When you patch this input, the trigger delay runs in clocked\nmode. In this mode {\\t delay} is relative to one clock cycle. I.e. a delay\nif {\\t 0.5} will delay the trigger by half a clock cycle. The same holds\nfor {\\t gatelength}. That is measured in clock cycles, too.\n"}], "description": "This circuit implements a CV controllable delay for a trigger or gate signal.\nIt listens for triggers at {\\t input} and sends the same triggers {\\it later}\nto the {\\t output}. It does {\\it not} look at the voltage level of the inputs.\nThe output triggers are always sent with 10~V ({\\t I1 ... I8}) or 5~V (on the\nG8 expander).\n\nAs a difference to an analog trigger delay this circuit is capable of keeping\nmemory of up to 16 triggers. This means it is able to process further\nincoming triggers while previous triggers are still in the delay. This allows you\nto delay complex rhythmic patterns, e.g. in order to reuse the output of one\ntrack of a trigger sequencer shifted in time for another instrument.\n\nFurthermore, it is able to retain the gate length of the original input signal and output\nthe delayed gate with exactly the same length.\n\nHere is the simplest possible example, which delays an incoming gates / triggers\nby exactly one second:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\end{droidini}\n\nYou can set the delay in seconds via the {\\t delay} jack. And if you patch\n{\\t gatelength}, the original gate length is being ignored and overridden\nby this value (also in seconds):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    delay      = 0.1 # 0.1 seconds}    delay      = 0.1 # 0.1 seconds\n\\immediate\\write\\patchexamples{    gatelength = 0.05 # 50 ms}    gatelength = 0.05 # 50 ms\n\\end{droidini}\n\n\\subsubsection*{Clocked mode}\n\n{\\t triggerdelay} supports a clocked mode, in which all timing\nis relative to an input clock. You enable clocked mode by simply patching\na steady clock into {\\t clock}. Now {\\t delay} and {\\t gatelength} are\nrelative to {\\it one clock cycle}.\n\nThe following example delays all input triggers by one clock cycle\n(which is the default):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    clock      = G3}    clock      = G3\n\\end{droidini}\n\nIf you specify {\\t delay} and/or {\\t gatelength} they are now measured\nin clock cycles:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    clock      = G3}    clock      = G3\n\\immediate\\write\\patchexamples{    delay      = 16 # clock cycles}    delay      = 16 # clock cycles\n\\immediate\\write\\patchexamples{    gatelength = 0.5 # half a clock cycle}    gatelength = 0.5 # half a clock cycle\n\\end{droidini}", "title": " Trigger Delay with multi tap and optional clocking", "outputs": [{"default": null, "type": "gate", "name": "output", "description": "Outputs the delayed triggers/gates, while keeping the gate length --\nunless you have changed that\n"}, {"default": null, "type": "gate", "name": "overflow", "description": "Whenever there are more input triggers than this circuit can keep\nmemory of, this output outputs a gate of 0.5~sec length. You can\nwire this to an LED in order to know when this happens.\n"}], "presets": 0}, "motorfader": {"category": "ui", "inputs": [{"default": "0", "type": "integer", "name": "preset", "description": "This is the preset number to save or to load.\n"}, {"default": null, "type": "trigger", "name": "loadpreset", "description": "A trigger here loads a preset.\n"}, {"default": null, "type": "trigger", "name": "savepreset", "description": "A trigger here saves a preset.\n"}, {"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": "1", "type": "integer", "name": "fader", "description": ""}, {"default": "1", "type": "integer", "name": "block", "description": ""}, {"default": null, "type": "cv", "name": "startvalue", "description": ""}, {"default": "0", "type": "integer", "name": "notches", "description": ""}, {"default": null, "type": "cv", "name": "brightness", "description": ""}, {"default": null, "type": "cv", "name": "color", "description": ""}, {"default": "0", "type": "gate", "name": "sharewithnext", "description": ""}], "description": "", "title": " Create virtual fader in M4 controller", "outputs": [{"default": null, "type": "cv", "name": "output", "description": ""}], "presets": 8}, "logic": {"category": "logic", "inputs": [{"count": 8, "start_at": 1, "name": "input1 ... input8", "default": "unpatched", "prefix": "input", "type": "gate", "description": "\\nth1 ... \\nth8 input. Note: this input is declared as a \\gatesymbol gate input, but\nin fact you can use it as a CV input in combination with various or random values set\nfor the {\\t threshold}.\n"}, {"default": "0.1", "type": "cv", "name": "threshold", "description": "Input values at, or above this threshold value, are considered high or {\\t on}.\nThe default is {\\t 0.1} which corresponds to an input voltage of 1~V. You can get\ninteresting results when both the inputs are variable CVs (like from LFOs) and this\nthreshold is being modulated as well.\n"}, {"default": "0", "type": "cv", "name": "lowvalue", "description": "Output value that is output for logic low, false or {\\t off}.\n"}, {"default": "1", "type": "cv", "name": "highvalue", "description": "Output value that is output for a logic high, true or {\\t on}.\n"}, {"default": "0.1", "type": "cv", "name": "countvalue", "description": "Value added to the {\\t count} output for each input with a high level\n"}], "description": "Utility circuit for logic operations on gate signals. It can do\noperations like AND, OR, NAND, NOR, etc.\n\n\\subsubsection*{Basic operation}\n\nIn this example we do an {\\t and} operation.\n{\\t O1} will output 1 ({\\t on}) if all of {\\t I1}, {\\t I2}\nand {\\t I3} see {\\t on} (voltage above 1~V):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    and     = O1}    and     = O1\n\\end{droidini}\n\nHere is how to do a logic negate of a signal:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    negated = O1}    negated = O1\n\\end{droidini}\n\nIf you do not like the 1~V threshold, you can change it:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input     = I1}    input     = I1\n\\immediate\\write\\patchexamples{    negated   = O1}    negated   = O1\n\\immediate\\write\\patchexamples{    threshold = 5V}    threshold = 5V\n\\end{droidini}\n\n\\subsubsection*{Doing logic without this circuit}\n\nPlease note, that many times when you think you need the logic circuit\nyou can do the same much simpler. Here is an example, where you use\na toggle button to switch on a clock send output {\\t O1}.\nThe idea is to make an AND combination of the clock signal and the\nbutton state:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz     = 2}    hz     = 2\n\\immediate\\write\\patchexamples{    square = _LFO}    square = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input1 = L1.1}    input1 = L1.1\n\\immediate\\write\\patchexamples{    input2 = _LFO}    input2 = _LFO\n\\immediate\\write\\patchexamples{    and    = O1}    and    = O1\n\\end{droidini}\n\nWhile this works pretty well, here is a solution that makes use of the\nfact, that the {\\it multiplication} of two gate signals is in fact\na kind of AND combination, since $A \\times B$ is just 1, if $A$ {\\it and}\n$B$ are 1 and 0 otherwise:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz     = 2}    hz     = 2\n\\immediate\\write\\patchexamples{    square = _LFO}    square = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input  = _LFO * L1.1}    input  = _LFO * L1.1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nYou even can avoid the Copy-circuit if you make use of the {\\t level} input\nof the LFO, since setting the level to 0 disables it:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button  = B1.1}    button  = B1.1\n\\immediate\\write\\patchexamples{    led     = L1.1}    led     = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz      = 2}    hz      = 2\n\\immediate\\write\\patchexamples{    square  = _LFO}    square  = _LFO\n\\immediate\\write\\patchexamples{    level   = L1.1}    level   = L1.1\n\\end{droidini}\n\n\\columnbreak\n\nAnother nice solution is to make use of {\\t offvalue} and {\\t onvalue} of\nthe {\\t button} circuit. {\\t offvalue} is 0 per default, so we just need to\ndefine {\\t onvalue}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 2}    hz       = 2\n\\immediate\\write\\patchexamples{    square   = _LFO}    square   = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button   = B1.1}    button   = B1.1\n\\immediate\\write\\patchexamples{    led      = L1.1}    led      = L1.1\n\\immediate\\write\\patchexamples{    onvalue  = _LFO}    onvalue  = _LFO\n\\end{droidini}\n\nIf you need to combine two gates in order to create a common gate\npattern, you can use {\\it addition} -- which is very similar to\na logic OR combination. The following example creates two overlayed\neuclidean rhythms:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    length = 16}    length = 16\n\\immediate\\write\\patchexamples{    beats  = 3}    beats  = 3\n\\immediate\\write\\patchexamples{    output = _E1}    output = _E1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    length = 13}    length = 13\n\\immediate\\write\\patchexamples{    beats  = 2}    beats  = 2\n\\immediate\\write\\patchexamples{    output = _E2}    output = _E2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input  = _E1 + _E2}    input  = _E1 + _E2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNote: When both {\\t \\_E1} and {\\t \\_E2} are 1 at the same\ntime, the sum is 2, of course. This does not matter, since the\noutput voltage is capped at 10~V ({\\t 1.0}) anyway.\n\n\\clearpage", "title": " Logic operations utility", "outputs": [{"default": null, "type": "cv", "name": "and", "description": "A logic AND operation on all patched inputs:\nThis output is set to {\\t highvalue} if all inputs are high (i.e. at least\n{\\t threshold}), else {\\t lowvalue}\n"}, {"default": null, "type": "cv", "name": "or", "description": "A logic OR operation on all patched inputs:\nThis output is set to {\\t highvalue} if at least one of the inputs is high\n"}, {"default": null, "type": "cv", "name": "xor", "description": "Exclusive OR: This is high, if the number of high inputs is odd! This means\nthat any change in one of the inputs will also change the output.\n"}, {"default": null, "type": "cv", "name": "nand", "description": "Like AND but the outcome is negated.\n"}, {"default": null, "type": "cv", "name": "nor", "description": "Like OR but the outcome is negated.\n"}, {"default": null, "type": "cv", "name": "negated", "description": "Logical negate of {\\t input1} (which can abbreviated as {\\t input}). Note:\nThe inputs {\\t input2} ... {\\t input7} are ignored here. Another note:\nIf you use {\\t input1} anyway, {\\t negated} always outputs exactly the\nsame as {\\t nand} and {\\t nor}. It's just more convenient to write and easier\nto understand. Hence a dedicated output for a logic negate.\n"}, {"default": null, "type": "integer", "name": "count", "description": "Adds {\\t countvalue} to this output for each input that is high.\n"}, {"default": null, "type": "cv", "name": "countlow", "description": "Adds {\\t countvalue} to this output for each input that is low.\n"}], "presets": 0}, "algoquencer": {"category": "sequencing", "inputs": [{"default": "0", "type": "integer", "name": "preset", "description": "This is the preset number to save or to load.\n"}, {"default": null, "type": "trigger", "name": "loadpreset", "description": "A trigger here loads a preset.\n"}, {"default": null, "type": "trigger", "name": "savepreset", "description": "A trigger here saves a preset.\n"}, {"default": "unpatched", "type": "gate", "name": "select", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n"}, {"default": "unpatched", "type": "integer", "name": "selectat", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n"}, {"default": null, "type": "trigger", "name": "clock", "description": "Clock input. This is mandatory. For each clock pulse the sequencer\nis advanced by one step.\n"}, {"default": null, "type": "trigger", "name": "reset", "description": "Reset input. A trigger here switches back to step 1.\n"}, {"count": 16, "start_at": 1, "name": "button1 ... button16", "default": null, "prefix": "button", "type": "gate", "description": "\\nth1 ... \\nth{16} step button. Assign these buttons to\nbuttons on your controllers.\n"}, {"default": "unpatched", "type": "integer", "name": "length", "description": "Sets the length of the pattern. Note: if you use\n{\\t lengthbutton}, this input is ignored as soon as the\nlength button has been used for the first time. If you have assigned at\nleast one button, the default value of {\\t length} is the number\nof buttons you have assigned. Otherwise it defaults to {\\t 16}.\nThe maximum length is 64. Any larger number will be truncated\nto 64.\n"}, {"default": "0", "type": "integer", "name": "pattern", "description": "Selects a pattern of pseudo random values. If you set {\\t dejavu} to 1,\nall ``random'' decision are deterministic and repeat again and again. If you\ndo not like these choices, you can choose a different pattern, just by setting\nthis input to any integer number you like. The default pattern is 0. If you\npatch a pot here, simply multiply it by the number of different patterns\nyou want to select, e.g. {\\t pattern = P1.1 * 10}. This will allow you\nto select one of the pattern 0, 1, ... 10.\n"}, {"default": null, "type": "trigger", "name": "nextpattern", "description": "Switches forward to the next pseudo random pattern.\n"}, {"default": null, "type": "trigger", "name": "prevpattern", "description": "Switches back to the previous pseudo random pattern.\n"}, {"default": null, "type": "trigger", "name": "reroll", "description": "Select one of the pseudo random patterns completely by random.\n"}, {"default": null, "type": "trigger", "name": "clear", "description": "A trigger here unselects all step buttons in the currently active page\n(normal, alternate, accent).\n"}, {"default": "0", "type": "cv", "name": "pitchlow", "description": "This set a lower voltage boundary for the {\\t pitch} output for\nnotes that are randomized.\n"}, {"default": "0.3", "type": "cv", "name": "pitchhigh", "description": "This set an upper voltage boundary for the {\\t pitch} output for\nnotes that are randomized.\n"}, {"default": "0", "type": "integer", "name": "pitchresolution", "description": "If this is non-zero, it make the {\\t pitch} output adopt that number of\npossible discrete values. E.g. if you set it to {\\t 2}, only the values\nset by {\\t pitchlow} and {\\t pitchhigh} are possible. A value of {\\t 3} will\nallow an additional value in the middle, and so on.\n"}, {"default": "0.1", "type": "cv", "name": "gatelength", "description": "The gate length in input clock cycles. A value of {\\t 0.5} (5~V)\nthus means half a clock cycle. A steady input clock is needed for\nthis to work. Please note that if the gate length is $>= 1.0$,\ntwo succeeding notes will get a steady gate, which\nessentially means legato.\n"}, {"default": null, "type": "gate", "name": "lengthbutton", "description": "Map this to a button like {\\t B1.1}. While you press and hold\nthis button the sequencer switches to {\\it change length mode}. While\nin this mode a press of one of the step buttons will change the length\nof the pattern. Also while in this mode the LEDs of the step buttons will\nshow the current length. If you do not like to hold the button but\nswitch it on and off, you can create a toggle button with {\\t [button]} and\nsend its output here.\n"}, {"default": "1", "type": "integer", "name": "repeats", "description": "Usually one bar has the length of one pattern. Setting this to 2\nwill consider one bar as a run of two times through the pattern. So\nif you have 8 buttons and {\\t bars = 2}, one bar will be 16\nsteps, where the \\nth{1} and \\nth{9} step are set by {\\t button1},\n\\nth{2} and \\nth{10} by {\\t button2} and so on.\n\nWhy should that be useful? Well -- the difference shows up when you\nuse {\\t fills}, or {\\t branches} or work with the {\\it alternate}\npattern. These three algorithms work based on {\\it bars}. And {\\t\nrepeats = 2} makes one bar have 16 steps, even if you just have\neight buttons.\n"}, {"default": "unpatched", "type": "integer", "name": "alternaterepeats", "description": "Are use using {\\t repeats} and {\\t alternatebars} / {\\t alternatebutton}\nat the same time? Then with this input you can specify a different\nvalue for repeats when it comes to selecting the alternate button\npage.\n\nAssume you have eight buttons and {\\t repeats = 2} and\n{\\t alternatebars = 2}. Then Algoquencer will play two times your\n8-step pattern normally and two times alternated (since two times\nthe 8 steps form one bar). This results in a form of A A B B.\n\nIf you want your form rather to be A B A B, set {\\t alternaterepeats\n= 1}. That way, when it comes to alteration, the length of one bar\nis just normal length (8 steps here).\n"}, {"default": "0", "type": "integer", "name": "branches", "description": "Enables the branching feature (sometimes also called fractal sequencing.\nWhen {\\t branches = 1}, then every second bar will be using other\nrandom values -- giving a sequence of the bars\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}}.\n\nWith {\\t branches = 2} you get a sequence of the form\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{C}}.\n\nA value of {\\t 3} creates an even longer sequence that repeats itself\nafter eight bars:\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{C}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{D}}.\n\nNote: this only takes effect when deterministic random\nnumbers are being used. For this {\\t dejavu} needs to be $>0$. The largest\neffect is when it is set to {\\t 1}. And the you need to use either\n{\\t variation} or set {\\t activity} to a value greater than {\\t 0.5}.\nBecause otherwise Algoquencer will strictly play the gates that you've set\nwith your buttons and then every bar will be the same, of course.\n"}, {"default": null, "type": "trigger", "name": "mutebutton", "description": "Wire this to a button like {\\t B1.2}. When you press then\nbutton once then all triggers are muted. Pressing again unmutes\nthem. So this behaves like a toggle {\\t [button]} in itself.\nYou probably want to wire {\\t muteled} to the LED in that button,\ne.g. {\\t L1.2}. It show the mute state. The mute button works\ntogether with the unmute button (see below). Note: even if you\nuse the {\\t select} jack in order to overlay your buttons with\nseveral algoquencers, the {\\t mutebutton} will always be active.\nThe idea is to always have direct access to that button.\n"}, {"default": null, "type": "trigger", "name": "unmutebutton", "description": "A trigger to this jack resets the mute button exactly\nat the beginning of the next bar. While waiting for that\nto happen, the output {\\t unmuteled} will blink. Wire this\nto the LED in the button. Note: even if you\nuse the {\\t select} jack in order to overlay your buttons with\nseveral algoquencers, the {\\t mutebutton} will always be active.\nThe idea is to always have direct access to that button.\n"}, {"default": null, "type": "gate", "name": "accentbutton", "description": "While this input is high you are in {\\it accent editing mode}. This\nis very similar to the mode where you set the length. But now for\neach step you edit whether this step is outputting an accent when\ntriggered. You might want to use a {\\t [button]} for this function, so\nyou can operate without holding down the button all the time.\n"}, {"default": null, "type": "gate", "name": "alternatebutton", "description": "If this input is high, you are in {\\it alternate editing mode}.\nEvery Algoquencer has an alternate set of steps. Each step\nthat is currenty activated {\\it toggles} the state of the normal step,\nbut only for each even bar. This allows to introduce variations\nof the pattern that occur every second bar.\n"}, {"default": "2", "type": "integer", "name": "alternatebars", "description": "With this input you can change the influence of the\n{\\t alternatebutton}. Per default the pattern alternation is\ndone every second bar. You can change this to any number you\nlike with this input. Value less than {\\t 1} will be considered\nas one -- which means that every bar is alternated.\n"}, {"default": "0", "type": "cv", "name": "accentlow", "description": "This value is output at {\\t accent} when a note without an\naccent is being triggered or when no note is triggered at all.\n"}, {"default": "1", "type": "cv", "name": "accenthigh", "description": "This value is output at {\\t accent} while a note with an\naccent is triggered. The value will be kept for the full time\nof the clock cycle.\n"}, {"default": "unpatched", "type": "bipolar", "name": "activity", "description": "This is the most important parameter and  you will probably\nwire it to a pot like {\\t P1.1}. The activity controls, how\n``busy'' the sequencer is playing, or in other words how often\na step gets an active gate (und thus a changing output pitch).\n\nLet's first assume that {\\t variation}\nis set to {0.0} (which is the default). Then at a value of\n{\\t 0.5} (or pot at 12'clock) Algoquencer will exactly play that\npattern that you have set with the step buttons. Turning the knob\nCCW will remove more and more beats from the pattern until it is\ncompletely silent at a value of {\\t 0.0} (or pot fully\nCCW). But if you turn up the knob above the middle position then more\nand more {\\it additional} beats will be placed into you pattern in\na random way until -- at {\\t 1.0} -- a trigger will happen at\n{\\it every} beat.\n\n{\\bf Note}: If you do not use step buttons, this parameter\nbehaves slightly different: A value of {\\t 0.5} then means an\nactivity of 50\\%, which means that exactly the half of the steps\nwill get an event. This is different from a situation where you\n{\\it have} defined buttons but all are deselected. In that case\n{\\t 0.5} means that exactly the number of beats of your pattern\nare being played, which is zero in that case.\n"}, {"default": "0", "type": "fraction", "name": "variation", "description": "The {\\it variation} controls how strictly Algoquencer will stick\nto the pattern that you have set with your step buttons. You probably\nwant to wire this to a knob. A value of {\\t 0.0} (or the knob\nfully CCW) will allow no variations. Your pattern by played exactly\nas it is. If the {\\it activity} goes beyond {\\t 0.5}, additional\nbeats will be placed, of course. And these are random.\n\nIf you increase the variation, more and more beats of your\npattern are being replaced with other beats -- while keeping the\ntotal number of beats the same. If you set {\\t variation} to\n{\\t 1.0} (or the pot fully CW) then your pattern is completely\nignored except for the actual number of beats it contains.\n"}, {"default": "1", "type": "fraction", "name": "dejavu", "description": "The {\\t dejavu} parameter controls what {\\it random} should mean.\nIf {\\t dejavu = 0.0}, then all random decisions are completely\nchaotic -- and every time a decision is taken the dice are being\nrolled again.\n\nAt {\\t dejavu = 1.0} on the other hand -- once a random decision\nhas been taken for a certain step in a certain bar then it will be\nalways the same from now on. This will lead to repeating exactly\nthe pattern bars over and over again. We sometimes call this random\nto be ``deterministic''.\n\nAny position in between will make some of the steps use chaotic\nrandom and some of the steps and deterministic for others.\n"}, {"default": "0", "type": "fraction", "name": "morphs", "description": "This parameter is a bit like automatic rerolls from time to time.\nIf you crank it up above zero, then at every start of bar {\\it some}\nof the deterministic random decisions will be rerolled. Setting\n{\\t morphs = 1} will essential disable {\\t dejavu}, since all\ndecisions are redone every bar anyway then.\n\nIf you know the Turing Machine: In principle that has the same idea,\nbut Algoquencer has a few improvements:\n\n\\begin{itemize}\n\\item The number of random changes is exactly controlled by the setting.\nAt each specific setting of {\\t morphs} exactly the same number of\nchanges will be done at each bar.\n\\item Changes always only appear at the beginning of each bar. If\nyou use {\\t branches} then it will appear whenever you sequence\nis over.\n\\item Small settings will introduce just one morph each \\nth{64} step.\n\\end{itemize}\n"}, {"default": "0.5", "type": "bipolar", "name": "offbeats", "description": "Whenever random beats are being placed then this setting controlls\nwhether {\\it downbeats} or {\\it offbeats} should be preferred. At at\nsetting of {\\t 0.5} there will be no difference. If you increase the\nvalue then more and more offbeats will appear. Offbeats are steps with\nan {\\it even} number, like 2, 4, 6 and so on. Value smaller than\n{\\t 0.5} will prefer downbeats.\n\nOffbeats sound more ``complex'' and downbeats more simple or\n``down to earthish''.\n"}, {"default": "0.5", "type": "bipolar", "name": "distribution", "description": "This is very similar to {\\t offbeats}, but this time you decide\nwhether beats should be placed rather in the first half of the bar\nor in the second half.\n"}, {"default": "0", "type": "fraction", "name": "fills", "description": "When this parameter is raised above {\\t 0.0} then additional\nbeats will be placed in order to make the beat more ``active''. This\nhappens at musically useful times controlled by {\\t fillorder} (see\nbelow). The additional beats within the bar are placed in a way that\nprefers the end of the bar. If there are already too many beats in the\nbar then the fill will {\\it remove} or change some instead.\n"}, {"default": "0", "type": "integer", "name": "fillorder", "description": "This integer number controls how fills are being placed:\n\n\\begin{tabular}{|c|l|}\\hline\n{\\t 0} & every bar \\\\ \\hline\n{\\t 1} & every second bar \\\\ \\hline\n{\\t 2} & small fill in bar 2, big fill in bar 4 \\\\ \\hline\n{\\t 3} & tiny fill in bar 2 and 6, medium fill in bar 4, big fill in bar 8 \\\\ \\hline\n\\end{tabular}\n\\vspace{2mm}\n"}, {"default": "0", "type": "fraction", "name": "rolls", "description": "This parameter controls if drum rolls (or ratchets as you might\ncall it) are being created. At {\\t 0.0} no rolls are being created.\nAt {\\t 1.0} {\\it every} beat will be converted into a roll. Rolls\nalways happen before the actual beat, they lead to it. If you\nusing this feature for snare rolls you might want to use the\noutput {\\t rollvelocity} for controlling the snare volume.\n"}, {"default": "1", "type": "integer", "name": "rollcount", "description": "Number of additional beats for playing the roll. Setting\n{\\t rollcount = 0} would disable rolls. All these beats are\ndistributed in the clock tick before the beat the roll is\nleading to. The first beat of the roll is exactly one tick before\nthat beat -- or more if you increase {\\t rollsteps}.\n"}, {"default": "1", "type": "integer", "name": "rollsteps", "description": "Length of the roll in clock ticks (steps). The total number\nof additional beats is thus {\\t rollcount} $\\times$ {\\t rollsteps}\n"}, {"default": "0.5", "type": "cv", "name": "rollstartvelo", "description": "Rolls can be played with an increasing velocity. This first\nbeat starts with the velocity set with this parameter. Then\nevery beat gets a bit louder until the last beat is played with\nvelocity {\\t 1.0}. The velocity for rolls is output at the jack\n{\\t rollvelocity}.\n"}, {"count": 16, "start_at": 1, "name": "pitch1 ... pitch16", "default": "unpatched", "prefix": "pitch", "type": "cv", "description": "You can use these inputs, if you want the pitches of the {\\t pitch}\noutput play a certain melody. That way the Algoquencer behaves like\na normal melody sequencer -- but all the algorithmic parameters will\nbe applied. For example {\\t variation} will also be applied to these\nnotes. Note: If {\\t length} is larger than 16, these pitch inputs\nwill be cycled through, so step 17 uses {\\t pitch1}, step 18 uses\n{\\t pitch2} and so on.\n"}], "description": "The Algoquencer is a versatile sequencer with a strong focus to live\nperformances. It implements a completely new approach: It combines a classical\ntrigger sequencer with a turing machine and other randomization algorithms in\norder to create a very hands on pattern generator for live improvisation. It's\nmain tasks are:\n\n\\begin{itemize}\n\\item trigger sequencer for drum voices\n\\item pitch sequencer\n\\item melody generator\n\\item generator of repeating random CVs\n\\end{itemize}\n\nIt can also be used as a simple random number generator -- may it be\ntotally chaotic random numbers or self similar patterns like those\ngenerated by the so called ``Turing Machine''.\n\nThere are lots of interesting high-level parameters that you can easily map to\npots on your controllers -- such as {\\it Activity}, {\\it Variation}, {\\it\nD\\'ej\\`a-vu} and many more. With a turn of a knob you can instantly increase\nor decrease the density or complexity or your patterns in various ways.\n\nHere are some of the features:\n\n\\begin{itemize}\n\\item Up to 16 step buttons\n\\item change the pattern length on the fly\n\\item manually editable accents for each step\n\\item ratchets and drum rolls\n\\item fills\n\\item deterministic and chaotic randomization\n\\item simple muting\n\\item fractal sequencing\n\\end{itemize}\n\nIf you use the Algoquencer for drumming, each {\\t algoquencer} circuit plays\njust one voice -- e.g. a snare drum. For orchestrating a whole drum kit simply\nuse more Algoquencers with possibly different parameters.  It totally makes\nsense to use some of the pots and buttons will all drum instruments -- e.g. a\npot for {\\it D\\'ej\\`a-vu} -- and others on a per-instrument base, like {\\it Activity}.\n\nHere are some examples of how to use the Algoquencer circuit.\n\n\\subsection*{Pseudo random voltages / Turing machine}\n\nWithout any inputs other than {\\t clock} the algorithmic sequencer creates\na sequence of random numbers that {\\it repeat} over and over every 16 steps.\nThis is much like the ``Turing Machine''. The voltage range of the {\\t pitch}\noutput defaults to 0~V ... 3~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock  = G1}    clock  = G1\n\\immediate\\write\\patchexamples{    pitch  = O1}    pitch  = O1\n\\end{droidini}\n\nYou can change the length to any other value up to 64 by using the {\\t length} parameter:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock  = G1}    clock  = G1\n\\immediate\\write\\patchexamples{    pitch  = O1}    pitch  = O1\n\\immediate\\write\\patchexamples{    length = 12}    length = 12\n\\end{droidini}\n\nIf you do not like the default output voltage range you can adjust that\nwith the inputs {\\t pitchlow} and {\\t pitchhigh}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock     = G1}    clock     = G1\n\\immediate\\write\\patchexamples{    pitchlow  = 1V}    pitchlow  = 1V\n\\immediate\\write\\patchexamples{    pitchhigh = 4V}    pitchhigh = 4V\n\\immediate\\write\\patchexamples{    pitch     = O1}    pitch     = O1\n\\end{droidini}\n\n\n{\\t dejavu} controls the randomness -- or to be more precise how random\nvalues are picked. It has a default of {\\t 1.0}. This means\nthat once a random decision has been made for a certain step of the pattern\nit will be that way for ever. The same random pattern will\nrepeat again and again. Making {\\t dejavu} smaller will convert {\\it some} of\nthe decisions to be random while others still repeat unchanged over and over\nagain.\n\nYou want to change the entire pattern? You can choose another one by setting\n{\\t pattern} to an arbitrary integer number:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    pitch   = O1}    pitch   = O1\n\\immediate\\write\\patchexamples{    length  = 12}    length  = 12\n\\immediate\\write\\patchexamples{    pattern = 5}    pattern = 5\n\\end{droidini}\n\nAnother way to change the pattern is to send a trigger\nto {\\t nextpattern}, for example with a button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock       = G1}    clock       = G1\n\\immediate\\write\\patchexamples{    pitch       = O1}    pitch       = O1\n\\immediate\\write\\patchexamples{    length      = 12}    length      = 12\n\\immediate\\write\\patchexamples{    dejavu      = 1}    dejavu      = 1\n\\immediate\\write\\patchexamples{    nextpattern = B1.1}    nextpattern = B1.1\n\\end{droidini}\n\nDo you like slowly evolving patterns (which is a feature from the\n``Turing Machine''? The {\\t morphs} parameter -- which is usually {\\t 0.0}\n-- will introduce random changes to the repeating pattern in a very controlled\nway:\n\n\\begin{itemize}\n\\item Changes (aka morphs) are introduced each time the pattern starts (again) -- never in-between\n\\item The exact {\\it number} of changes is controlled with the {\\t morphs} parameter\nand is {\\it not} random.\n\\item The steps where these changes happen and the changes itself {\\it are} random.\n\\end{itemize}\n\n{\\t morphs} takes a number between {\\t 0.0} and {\\t 1.0}. At {\\t 0.0}\nno morphs happen. At {\\t 1.0} every step will be morphed -- thus completely\nchanging the pattern every time it would repeat. Here is a table of how\nexactly the parameter affects the number of morphs per 64 steps. It is done\nin a way that is very suitable for mapping it directly to a pot and gives\na very fine resolution at the left half of the pot:\n\n\\begin{center}\n\\begin{tabular}{|c|r|} \\hline\n{\\t morphs} & morphs per 100 steps \\\\ \\hline\n\\t 0.0 &  no morphs \\\\ \\hline\n\\t 0.1 &  1 \\\\ \\hline\n\\t 0.2 &  4 \\\\ \\hline\n\\t 0.3 &  9 \\\\ \\hline\n\\t 0.4 &  16 \\\\ \\hline\n\\t 0.5 &  25 \\\\ \\hline\n\\t 0.6 &  36 \\\\ \\hline\n\\t 0.7 &  49 \\\\ \\hline\n\\t 0.8 &  64 \\\\ \\hline\n\\t 0.9 &  81 \\\\ \\hline\n\\t 1.0 & 100 \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\nAs you can see the smallest number of morphs -- if you set {\\t morphs} just a little above 0 -- is one per 64 steps.\n\nNote: If you are curious whether morphs are happening you can wire\nthe output {\\t morphled} to some LED. It will flash whenever morphs happen.\n\n\\subsubsection*{Dejavu or morphs?}\n\nDid you get the difference between {\\t dejavu} and {\\t morphs}? Here once again:\n\n\\begin{itemize}\n\\item {\\t dejavu} controls, whether to use just complete random values ({\\t dejavu = 0}) or\nrepeating pseudo-random sequences ({\\t dejavu = 1}).\n\\item {\\t morphs} comes into play, when {\\t dejavu} is $> 0$ and modifies the pseudo-random\nsequences from time to time a bit so they won't get boring.\n\\end{itemize}\n\n\\subsection*{True random voltages}\n\nIf you do not want the random pitches to repeat you can set the {\\t dejavu}\nparameter to 0. This transforms the {\\t algoquencer} into a simple random\nnumber generator:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    dejavu = 0}    dejavu = 0\n\\end{droidini}\n\nIt can be very interesting to map {\\t dejavu} to one of the pots of your\ncontrollers. That way you can change on-the-fly between structured melodies\nand complete randomness -- or anything between!\n\n\\subsection*{Using the Algoquencer as drum sequencer}\n\nThis is how you setup the Algoquencer for use as a drum sequencer.  Like in the\nprevious examples you need a clock signal. Also using a reset input helps\nyou to sync your drums with some external stuff. A trigger here resets the\npattern to the first step:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    reset = G2}    reset = G2\n\\end{droidini}\n\nA trigger into {\\t clock} will move to the next step of the pattern.\nOne into {\\t reset} resets back to the first step.\n\nAlgoquencer supports up to 16 buttons (aka {\\it step buttons}) for manually\nsetting up a trigger pattern. If you assign less than 16 buttons then your\npatterns will be shorter. You probably want to assign these to buttons of\nyour controllers, e.g.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\end{droidini}\n\nIn order for the LEDs in these buttons to work you also need to\nassign the {\\t led...} outputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\end{droidini}\n\nPlease make sure that there is no ``hole'' in your definitions. You cannot\nuse {\\t button8} if you not also use {\\t button1} through {\\t button7}.\n\nNote: You can use Algoquencer even without step buttons. This is like having\nan empty pattern, but {\\t activity} will still work and create artifical\nbeats if it is not zero.\n\nLast but not least wire the output {\\t trigger} to the trigger input\nof some drum voice.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    trigger = O1}    trigger = O1\n\\end{droidini}\n\nFor a simple ``normal'' trigger sequencer this is enough. I'd suggest you\nsetup this small example first and once it is up and running you investigate\nfurther features of Algoquencer. Here is the example once again complete for\nusage while we assume that you have an P2B8 controller:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    reset   = I2}    reset   = I2\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    led3    = L1.3}    led3    = L1.3\n\\immediate\\write\\patchexamples{    led4    = L1.4}    led4    = L1.4\n\\immediate\\write\\patchexamples{    trigger = O1}    trigger = O1\n\\end{droidini}\n\n\\subsection*{Accents}\n\nAlgoquencer supports setting or not setting an accent for each of the steps.\nFor this there is a ``second page'' of the buttons where you can edit these\naccents. In order to access that accent page you need to wire the input {\\t\naccentbutton} to one of your buttons (e.g. {\\t B1.5}). Also wire the output\n{\\t accent} to some external output jack and patch that to the accent input\nof your drum voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    accentbutton = B1.5}    accentbutton = B1.5\n\\immediate\\write\\patchexamples{    accent       = O3}    accent       = O3\n\\end{droidini}\n\nNow while you hold the accent button the step buttons will switch over\nto showing the accents intead of the normal beats. And you can set and\nremove accents now.\n\nNote: if you do not want to be forced to {\\it hold} the button while\nediting accents you can convert it into toggle button using the {\\t [button]}\ncircuit:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{   button        = B1.5}   button        = B1.5\n\\immediate\\write\\patchexamples{   led           = L1.5}   led           = L1.5\n\\immediate\\write\\patchexamples{   output        = _ACCENTS}   output        = _ACCENTS\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    # ... the other stuff}    # ... the other stuff\n\\immediate\\write\\patchexamples{    accentbutton = _ACCENTS}    accentbutton = _ACCENTS\n\\immediate\\write\\patchexamples{    accent       = O3}    accent       = O3\n\\end{droidini}\n\n\n\\subsection*{Alternate steps}\n\nThe Algoquencer just supports 16 steps, but there is a great way to extend\nyour pattern to 32 or more steps. The concept for this is a bit unusual,\nbut all the more musical and hands on. It goes like this:\n\nThere is an {\\it alternate page} of another 16 buttons. These\nare like a third layer of buttons (if you account the accents for the\nsecond layer). Just like with the accents you define a button\nfor bringing up that layer, for example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   alternatebutton = B1.7}   alternatebutton = B1.7\n\\end{droidini}\n\nWhile you hold that button you edit the alternate page instead\nof the normal steps.\n\nNow: every active step in the alternate page will {\\it flip} the according\nstep in the normal page {\\it for every second bar}. That way you\ncan have a variation of the pattern every second bar but you just\nedit the {\\it differences} to the normal pattern. So adding or removing\none beat every second bar can be done by activating exactly one step\nin the alternate page.\n\nYou are not limited to a pattern of two bars. By setting {\\t alternatebars}\nto another value you can change the frequency of the alternate bar:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   alternatebutton = B1.7}   alternatebutton = B1.7\n\\immediate\\write\\patchexamples{   alternatebars = 4}   alternatebars = 4\n\\end{droidini}\n\nNow bars 1 - 3 are played normally and every forth bar the alternate\npage is applied. That basically forms a pattern of 64 steps.\n\n\n\n\\subsection*{Pattern length and bars}\n\nAs you have at most 16 buttons one pattern can have a length of at most\n16 steps. The length of the pattern can be set in various ways:\n\n\\begin{itemize}\n\\item If you wire at least one {\\t button1} then the length defaults to\nthe number of wired buttons.\n\\item This can be overridden by setting {\\t length} to any value (e.g. {\\t\nlength = 7}).\n\\item If you use the {\\t lengthbutton} then you can interactively change\nthe pattern length during your performance. This will always override the\n{\\t length} input.\n\\end{itemize}\n\nAdd the button for changing the length is easy:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   lengthbutton = B1.6}   lengthbutton = B1.6\n\\end{droidini}\n\nOne {\\it bar} usually has the same number of steps as your pattern. But if\nyou set {\\t repeats = 2}, one bar will consist of two times the pattern\n(and thus lasts twice as long).\nBars are useful when you use {\\t fills} or {\\it branches}.\n\n\\subsection*{Playing fills}\n\nFills are additional beats the Algoquencer adds at the end of certain bars\nin order to play a musically interesting fill. In order to use this\nfirst wire {\\t fills} to some CV or most likely to a pot:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    fills = P1.1}    fills = P1.1\n\\end{droidini}\n\nNow if you crank up that pot clockwise then more and more beats will\nbe added -- with a tendency to the end of the bar. In music -- however -- playing\na fill each bar is not very interesting. By setting {\\t fillorder} to\n{\\t 1}, {\\t 2} or {\\t 3} (or even a higher number) will make the fills\nassume a cycle of 2, 4 or 8 or move bars. Please see below for details.\n\n\\subsection*{Activity and random}\n\nFour inputs are key features of Algoquencer, since they extend it from\na plain old trigger sequencer to an algorithmic drummer. These are\n{\\t variation}, {\\t activity}, {\\t dejavu} and {\\t morphs}.\nThe latter two already have been discussed when using Algoquencer\nas random generator. They have the same effect here.\n\nThe default value of {\\t variation} is {\\t 0.0}. That means\nthat Algoquencer will exactly play the pattern as you have dialled it\nin with your step buttons. If you increase that value (a pot is handy\nfor doing this, of course) then randomly some of the beats will move to other\nsteps. Setting {\\t various} to {\\t 1.0} will completely alter your\npattern. The number of beats will stay the same!\n\n{\\t activity} will change exactly that: the number of triggered beats\nin one bar. The default value is {\\t 0.5} -- which is the center position\nif assigned to a pot. Here the number of played beats is exactly the\nsame as you have set in your pattern. Turn it left to remove (randomly)\nsome of the beats. Turn it right to add some. At {\\t 0.0} no beats\nare triggered, at {\\t 1.0} there is a beat for every clock cycle.\n\nThe {\\t activity} also has an effect when you create random voltages.\nHere the voltage only changes when a ``beat'' happens at that step,\neven if you are not using the {\\t trigger} output.\n\n\\subsection*{Further nifty parameters}\n\nThere are some more interesting parameters like {\\t rolls}, {\\t offbeats},\n{\\t distribution} and {\\t branches}. Please look at the table of inputs\nfor more details.\n\n\\subsection*{Presets}\n\nThe algoquencer supports up to 16 presets. Each preset comprises\nall settings that can be interactively changed, i.e. the activated\nsteps, accents, alternate steps, the manually changed length, the\nstate of the mute button and also the current random seed (which\nwas modified by {\\t nextpattern}, {\\t prevpattern} or {\\t reroll}.\n\nThere are two ways of switching between presets. The first way\nis easy to implement. Simply send the number of the current preset\nto the input {\\t preset}. It has to be a number from {\\t 0} to {\\t 15}.\nYou can for example use a pot if you multiply it with 15:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    preset = P1.1 * 15}    preset = P1.1 * 15\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow any change you make will immediately be saved to that current\npreset. If you change the preset number by turning the pot, another\npreset will immediately be loaded and activated.\n\nThe second -- more sophisticated -- way is to use triggers for\nloading and saving. These could be buttons, e.g.:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    preset = P1.1 * 15}    preset = P1.1 * 15\n\\immediate\\write\\patchexamples{    loadpreset = B1.1}    loadpreset = B1.1\n\\immediate\\write\\patchexamples{    savepreset = B1.2}    savepreset = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow turning the knob does not load or save any preset. The input {\\t preset}\nis just evaluated when you press {\\t B1.1} or {\\t B1.2}:\n\n\\begin{itemize}\n\\item A trigger to {\\t savepreset} will save the current settings into the preset\nthat is selected with the {\\t preset} input.\n\\item A trigger to {\\t loadpreset} will copy the contents of the preset selected\nby {\\t preset} into the current settings.\n\\end{itemize}\n\nNote: In the second mode you effectively have 17 presets, since the \"current\nsettings\" could also be considered to be a preset.\n\n\\subsection*{Sharing buttons between multiple algoquencers}\n\nThe buttons on your controllers are a valuable ressources and not\nto be wasted lightheartedly. And especially the {\\t algoquencer} uses quite\na lot of buttons. But the good news is: you can share most of these\nbuttons with other instances of {\\t algoquencer}, to create a multi-track\nsequencer with just one set of buttons. You can even share the buttons\nwith completely other circuits.\n\nThe key to this is the {\\t select} input. If you patch it, all buttons\nand LEDs will just be used by this instance of {\\t algoquencer} as long\nas {\\t select} gets a high gate signal. Here is an example (which is just a\nsketch and not complete):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select = _SELECT_1}    select = _SELECT_1\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select = _SELECT_2}    select = _SELECT_2\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow you need to make sure that at any given time either {\\t \\_SELECT\\_1}\n{\\it or} {\\t \\_SELECT\\_2} is active. The easiest way is with a {\\t buttongroup},\nbecause here you can add more and more tracks if you like. Let's assume that\nfor switching between tracks you use the buttons {\\t B2.7} (track 1) and\n{\\t B2.8} (track 2). This would look like this:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B2.7 # select track 1}    button1 = B2.7 # select track 1\n\\immediate\\write\\patchexamples{    button2 = B2.8 # select track 2}    button2 = B2.8 # select track 2\n\\immediate\\write\\patchexamples{    led1 = L2.7}    led1 = L2.7\n\\immediate\\write\\patchexamples{    led2 = L2.8}    led2 = L2.8\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select =  L2.7 # becomes 1 if B2.7 is selected}    select =  L2.7 # becomes 1 if B2.7 is selected\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select =  L2.8 # becomes 1 if B2.8 is selected}    select =  L2.8 # becomes 1 if B2.8 is selected\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nPlease note: the buttons {\\t mutebutton} and {\\t unmutebutton} and their\naccording LEDs are {\\bf not} handled by the {\\t select} jack. The idea is\nthat they always get their own dedicated buttons. This allows you quickly\nmuting or unmuting several tracks at once.", "title": " Algorithmic sequencer", "outputs": [{"default": null, "type": "trigger", "name": "trigger", "description": "Here comes the trigger output. Patch this to the trigger input\nof your drum or synth voice.\n"}, {"default": null, "type": "gate", "name": "gate", "description": "The gate output is alternative to the trigger and has a variable\nlength. It is useful when Algoquencer is used for creating melodies.\nPatch the gate input of an envelope or something similar here.\n"}, {"default": null, "type": "stepped", "name": "pitch", "description": "Outputs the (pseudo-)random voltage (unquantized) at each step\nwith an active gate. This honors all the settings that control the randomness\nand variation, like {\\t dejavu}, {\\t variation}, {\\t fills} and {\\t branches}.\n"}, {"default": null, "type": "cv", "name": "accent", "description": "Whenever a beat with an accent is being played, the value\nset by {\\t accenthigh} is sent here, otherwise {\\t accentlow}.\nIf you are wiring this to one of the jacks of the G8 expander\nthen that will output just 0V and 5V of course.\n"}, {"count": 16, "start_at": 1, "name": "led1 ... led16", "default": null, "prefix": "led", "type": "stepped", "description": "\\nth1 ... \\nth{16} LEDs of the step buttons. Assign these\nto the LEDs in the step buttons.\n"}, {"count": 4, "start_at": 1, "name": "barled1 ... barled4", "default": null, "prefix": "barled", "type": "gate", "description": "Patch these output to some LEDs in order to show you the\ncurrent bar in the sequence.\n"}, {"default": null, "type": "cv", "name": "rollvelocity", "description": "If you enable rolls, then the velocity of the roll beats\nwill be output here. For normal beats this will always be {\\t 1.0}.\n"}, {"default": null, "type": "trigger", "name": "startofbar", "description": "At the beginning of every bar a trigger is output here.\n"}, {"default": null, "type": "gate", "name": "muteled", "description": "Wire this to the LED in your mute button. It will then be lit\nwhile the voice is muted.\n"}, {"default": null, "type": "gate", "name": "unmuteled", "description": "Wire this to the LED in your unmute button (if used). It will\nblink while the unmute is waiting for the start of the next bar.\n"}, {"default": null, "type": "gate", "name": "morphled", "description": "This output will get a trigger every time a morph happens. It\nis intended to be wired to an LED.\n"}, {"default": null, "type": "gate", "name": "fillsled", "description": "This output will get a trigger every time a fill beat is being\nplayed. Wire this to some LED if you like.\n"}, {"default": null, "type": "integer", "name": "branch", "description": "This output will output the current branch number, e.g. 1, 2, 3 and\nso on. If you do not use {\\t branches} then it is always 1.\n"}], "presets": 16}}, "firmware_version": "FOO"}