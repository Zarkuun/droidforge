{"firmware_version": "blue-3", "available_memory": 111879, "circuits": {"adc": {"category": "logic", "title": " AD Converter with 12 bits", "description": "This circuit converts an input value into a binary representation\nof up to 12 bits. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[adc]}[adc]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    bit1 = O1}    bit1 = O1\n\\immediate\\write\\patchexamples{    bit2 = O2}    bit2 = O2\n\\immediate\\write\\patchexamples{    bit3 = O3}    bit3 = O3\n\\end{droidini}\n\nIn this example three bits are being used. Three bits can represent\na number from 0 to 7. These are mapped to the input range from 0\nto 1 (or 0~V to 10~V) in the following way:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\ninput                  & {\\t bit1} & {\\t bit2} & {\\t bit3} & bit value \\\\ \\hline\n$-\\infty$ ... 0.125    & {\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0} \\\\ \\hline\n0.125     ... 0.250    & {\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1} \\\\ \\hline\n0.250     ... 0.375    & {\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2} \\\\ \\hline\n0.375     ... 0.500    & {\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3} \\\\ \\hline\n0.500     ... 0.625    & {\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4} \\\\ \\hline\n0.625     ... 0.750    & {\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5} \\\\ \\hline\n0.750     ... 0.875    & {\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6} \\\\ \\hline\n0.875     ... $\\infty$ & {\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7} \\\\ \\hline\n\\end{tabular}}\n\nValues lower than 0 are treated as 0. Values higher than 1 are treated\nas one.\n\nIn other words: this circuit will convert an analog input value\ninto three different gate outputs.\n\nThe expected range of the input value is from 0 to 1 per default, but\nyou can change that with the parameters {\\t minimum} and {\\t maximum}.\nFor example you could have just the range of 0.1 to 0.5 mapped to\nthe three bits:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[adc]}[adc]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    minimum = 0.1 # 1V}    minimum = 0.1 # 1V\n\\immediate\\write\\patchexamples{    maximum = 0.5 # 4V}    maximum = 0.5 # 4V\n\\immediate\\write\\patchexamples{    bit1 = O1}    bit1 = O1\n\\immediate\\write\\patchexamples{    bit2 = O2}    bit2 = O2\n\\immediate\\write\\patchexamples{    bit3 = O3}    bit3 = O3\n\\end{droidini}\n\nNow the table looks like this:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\ninput              & {\\t bit1} & {\\t bit2} & {\\t bit3} & bit value \\\\ \\hline\n$-\\infty$ ... 0.15 & {\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0} \\\\ \\hline\n0.15 ... 0.20      & {\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1} \\\\ \\hline\n0.20 ... 0.25      & {\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2} \\\\ \\hline\n0.25 ... 0.30      & {\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3} \\\\ \\hline\n0.30 ... 0.35      & {\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4} \\\\ \\hline\n0.35 ... 0.40      & {\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5} \\\\ \\hline\n0.40 ... 0.45      & {\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6} \\\\ \\hline\n0.45 ... $\\infty$  & {\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7} \\\\ \\hline\n\\end{tabular}}\n\nIf you use more of the {\\t bit}-outputs you get more resolution.\nFor example if you use {\\t bit1} ... {\\t bit8}, the total range\nwill be divided into 256 equal pieces. Since bit~1 is the most significant\nbit, adding more and more bits will not change the way bit~1 is behaving.\n\nThe applications of this circuit are various and often surprising. For example\nusing different LFO wave forms as inputs (other than square) and you will\nget slower and faster gate patterns.\n\nPlease also have a look at the circuit {\\t dac} (see page \\pageref{dac},\nwhich does the exact opposite!\n\n\\clearpage", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Input signal to convert to binary representation.\n", "essential": 2, "ramsize": 12}, {"name": "minimum", "type": "cv", "default": "0", "description": "The lowest assumed input value. This value and all lower\nvalues will be converted to the bit sequence {\\t 000000000000}.\n", "essential": 0, "ramsize": 12}, {"name": "maximum", "type": "cv", "default": "1", "description": "The highest assumed input value. This value and all higher\nvalues will be converted to the bit sequence {\\t 111111111111}.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "bit", "name": "bit1 ... bit12", "count": 12, "start_at": 1, "type": "gate", "default": null, "description": "The 12 bit outputs. {\\t bit1} is the MSB -- the most significant\nbit. The LSB (least significant bit) is the highest output that\nyou actually patch. If you do not need the full resolution of\n12 bits, simply just use the first couple of outputs.\n", "essential": 2, "essential_count": 4, "ramsize": 4}], "presets": 0, "manual": 78, "ramsize": 56}, "algoquencer": {"category": "sequencing", "title": " Algorithmic sequencer", "description": "The Algoquencer is a versatile performance sequencer, that implements a\ncompletely new approach: It combines a classical trigger sequencer with a turing\nmachine and other algorithms in order to create a very hands on\npattern generator for live improvisation. It's main tasks are:\n\n\\begin{itemize}\n\\item trigger sequencer for drum voices\n\\item pitch sequencer\n\\item melody generator\n\\item generator of repeating random CVs\n\\end{itemize}\n\nIt can also be used as a simple random number generator -- may it be\ntotally chaotic random numbers or self similar patterns like those\ngenerated by the so called ``Turing Machine''.\n\nThere are lots of interesting high-level parameters that you can easily map to\npots on your controllers -- such as {\\it Activity}, {\\it Variation}, {\\it\nD\\'ej\\`a-vu} and many more. With a turn of a knob you can instantly increase\nor decrease the density or complexity or your patterns in various ways.\n\nHere are some of the features:\n\n\\begin{itemize}\n\\item Up to 16 step buttons\n\\item change the pattern length on the fly\n\\item manually editable accents for each step\n\\item ratchets and drum rolls\n\\item fills\n\\item deterministic and chaotic randomization\n\\item simple muting\n\\item fractal sequencing\n\\end{itemize}\n\nIf you use the Algoquencer for drumming, each {\\t algoquencer} circuit plays\njust one voice -- e.g. a snare drum. For orchestrating a whole drum kit simply\nuse more Algoquencers with possibly different parameters.  It totally makes\nsense to use some of the pots and buttons with all drum instruments -- e.g. a\npot for {\\it D\\'ej\\`a-vu} -- and others on a per-instrument base, like {\\it Activity}.\n\nHere are some examples of how to use the Algoquencer circuit.\n\n\\subsection*{Pseudo random voltages / Turing machine}\n\nWithout any inputs other than {\\t clock} the algorithmic sequencer creates\na sequence of random numbers that {\\it repeat} over and over every 16 steps.\nThis is much like the ``Turing Machine''. The voltage range of the {\\t pitch}\noutput defaults to 0~V ... 3~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock  = G1}    clock  = G1\n\\immediate\\write\\patchexamples{    pitch  = O1}    pitch  = O1\n\\end{droidini}\n\nYou can change the length to any other value up to 64 by using the {\\t length} parameter:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock  = G1}    clock  = G1\n\\immediate\\write\\patchexamples{    pitch  = O1}    pitch  = O1\n\\immediate\\write\\patchexamples{    length = 12}    length = 12\n\\end{droidini}\n\nIf you do not like the default output voltage range you can adjust that\nwith the inputs {\\t pitchlow} and {\\t pitchhigh}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock     = G1}    clock     = G1\n\\immediate\\write\\patchexamples{    pitchlow  = 1V}    pitchlow  = 1V\n\\immediate\\write\\patchexamples{    pitchhigh = 4V}    pitchhigh = 4V\n\\immediate\\write\\patchexamples{    pitch     = O1}    pitch     = O1\n\\end{droidini}\n\n\n{\\t dejavu} controls the randomness -- or to be more precise how random\nvalues are picked. It has a default of {\\t 1.0}. This means\nthat once a random decision has been made for a certain step of the pattern\nit will be that way for ever. The same random pattern will\nrepeat again and again. Making {\\t dejavu} smaller will convert {\\it some} of\nthe decisions to be random while others still repeat unchanged over and over\nagain.\n\nYou want to change the entire pattern? You can choose another one by setting\n{\\t pattern} to an arbitrary integer number:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    pitch   = O1}    pitch   = O1\n\\immediate\\write\\patchexamples{    length  = 12}    length  = 12\n\\immediate\\write\\patchexamples{    pattern = 5}    pattern = 5\n\\end{droidini}\n\nAnother way to change the pattern is to send a trigger\nto {\\t nextpattern}, for example with a button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock       = G1}    clock       = G1\n\\immediate\\write\\patchexamples{    pitch       = O1}    pitch       = O1\n\\immediate\\write\\patchexamples{    length      = 12}    length      = 12\n\\immediate\\write\\patchexamples{    dejavu      = 1}    dejavu      = 1\n\\immediate\\write\\patchexamples{    nextpattern = B1.1}    nextpattern = B1.1\n\\end{droidini}\n\nDo you like slowly evolving patterns (which is a feature from the\n``Turing Machine'')? The {\\t morphs} parameter -- which is usually {\\t 0.0}\n-- will introduce random changes to the repeating pattern in a very controlled\nway:\n\n\\begin{itemize}\n\\item Changes (aka morphs) are introduced each time the pattern starts (again) -- never in-between\n\\item The exact {\\it number} of changes is controlled with the {\\t morphs} parameter\nand is {\\it not} random.\n\\item The steps where these changes happen and the changes itself {\\it are} random.\n\\end{itemize}\n\n{\\t morphs} takes a number between {\\t 0.0} and {\\t 1.0}. At {\\t 0.0}\nno morphs happen. At {\\t 1.0} every step will be morphed -- thus completely\nchanging the pattern every time it would repeat. Here is a table of how\nexactly the parameter affects the number of morphs per 64 steps. It is done\nin a way that is very suitable for mapping it directly to a pot and gives\na very fine resolution at the left half of the pot:\n\n\\begin{center}\n\\begin{tabular}{|c|r|} \\hline\n{\\t morphs} & morphs per 100 steps \\\\ \\hline\n\\t 0.0 &  no morphs \\\\ \\hline\n\\t 0.1 &  1 \\\\ \\hline\n\\t 0.2 &  4 \\\\ \\hline\n\\t 0.3 &  9 \\\\ \\hline\n\\t 0.4 &  16 \\\\ \\hline\n\\t 0.5 &  25 \\\\ \\hline\n\\t 0.6 &  36 \\\\ \\hline\n\\t 0.7 &  49 \\\\ \\hline\n\\t 0.8 &  64 \\\\ \\hline\n\\t 0.9 &  81 \\\\ \\hline\n\\t 1.0 & 100 \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\nAs you can see the smallest number of morphs -- if you set {\\t morphs} just a little above 0 -- is one per 64 steps.\n\nNote: If you are curious whether morphs are happening you can wire\nthe output {\\t morphled} to some LED. It will flash whenever morphs happen.\n\n\\subsubsection*{Dejavu or morphs?}\n\nDid you get the difference between {\\t dejavu} and {\\t morphs}? Here once again:\n\n\\begin{itemize}\n\\item {\\t dejavu} controls, whether to use just complete random values ({\\t dejavu = 0}) or\nrepeating pseudo-random sequences ({\\t dejavu = 1}).\n\\item {\\t morphs} comes into play, when {\\t dejavu} is $> 0$ and modifies the pseudo-random\nsequences from time to time a bit so they won't get boring.\n\\end{itemize}\n\n\\subsection*{True random voltages}\n\nIf you do not want the random pitches to repeat you can set the {\\t dejavu}\nparameter to 0. This transforms the {\\t algoquencer} into a simple random\nnumber generator:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    dejavu = 0}    dejavu = 0\n\\end{droidini}\n\nIt can be very interesting to map {\\t dejavu} to one of the pots of your\ncontrollers. That way you can change on-the-fly between structured melodies\nand complete randomness -- or anything between!\n\n\\subsection*{Using the Algoquencer as drum sequencer}\n\nThis is how you setup the Algoquencer for use as a drum sequencer.  Like in the\nprevious examples you need a clock signal. Also using a reset input helps\nyou to sync your drums with some external stuff. A trigger here resets the\npattern to the first step:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    reset = G2}    reset = G2\n\\end{droidini}\n\nA trigger into {\\t clock} will move to the next step of the pattern.\nOne into {\\t reset} resets back to the first step.\n\nAlgoquencer supports up to 16 buttons (aka {\\it step buttons}) for manually\nsetting up a trigger pattern. If you assign less than 16 buttons then your\npatterns will be shorter. You probably want to assign these to buttons of\nyour controllers, e.g.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\end{droidini}\n\nIn order for the LEDs in these buttons to work you also need to\nassign the {\\t led...} outputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\end{droidini}\n\nPlease make sure that there is no ``hole'' in your definitions. You cannot\nuse {\\t button8} if you not also use {\\t button1} through {\\t button7}.\n\nNote: You can use Algoquencer even without step buttons. This is like having\nan empty pattern, but {\\t activity} will still work and create artifical\nbeats if it is not zero.\n\nLast but not least wire the output {\\t trigger} to the trigger input\nof some drum voice.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    trigger = O1}    trigger = O1\n\\end{droidini}\n\nFor a simple ``normal'' trigger sequencer this is enough. I'd suggest you\nsetup this small example first and once it is up and running you investigate\nfurther features of Algoquencer. Here is the example once again complete for\nusage while we assume that you have an P2B8 controller:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    reset   = I2}    reset   = I2\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    led3    = L1.3}    led3    = L1.3\n\\immediate\\write\\patchexamples{    led4    = L1.4}    led4    = L1.4\n\\immediate\\write\\patchexamples{    trigger = O1}    trigger = O1\n\\end{droidini}\n\n\\subsection*{Accents}\n\nAlgoquencer supports setting or not setting an accent for each of the steps.\nFor this there is a ``second page'' of the buttons where you can edit these\naccents. In order to access that accent page you need to wire the input {\\t\naccentbutton} to one of your buttons (e.g. {\\t B1.5}). Also wire the output\n{\\t accent} to some external output jack and patch that to the accent input\nof your drum voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    accentbutton = B1.5}    accentbutton = B1.5\n\\immediate\\write\\patchexamples{    accent       = O3}    accent       = O3\n\\end{droidini}\n\nNow while you hold the accent button the step buttons will switch over\nto showing the accents intead of the normal beats. And you can set and\nremove accents now.\n\nNote: if you do not want to be forced to {\\it hold} the button while\nediting accents you can convert it into toggle button using the {\\t [button]}\ncircuit:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{   button        = B1.5}   button        = B1.5\n\\immediate\\write\\patchexamples{   led           = L1.5}   led           = L1.5\n\\immediate\\write\\patchexamples{   output        = _ACCENTS}   output        = _ACCENTS\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    # ... the other stuff}    # ... the other stuff\n\\immediate\\write\\patchexamples{    accentbutton = _ACCENTS}    accentbutton = _ACCENTS\n\\immediate\\write\\patchexamples{    accent       = O3}    accent       = O3\n\\end{droidini}\n\n\n\\subsection*{Alternate steps}\n\nThe Algoquencer just supports 16 steps, but there is a great way to extend\nyour pattern to 32 or more steps. The concept for this is a bit unusual,\nbut all the more musical and hands on. It goes like this:\n\nThere is an {\\it alternate page} of another 16 buttons. These\nare like a third layer of buttons (if you account the accents for the\nsecond layer). Just like with the accents you define a button\nfor bringing up that layer, for example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   alternatebutton = B1.7}   alternatebutton = B1.7\n\\end{droidini}\n\nWhile you hold that button you edit the alternate page instead\nof the normal steps.\n\nNow: every active step in the alternate page will {\\it flip} the according\nstep in the normal page {\\it for every second bar}. That way you\ncan have a variation of the pattern every second bar but you just\nedit the {\\it differences} to the normal pattern. So adding or removing\none beat every second bar can be done by activating exactly one step\nin the alternate page.\n\nYou are not limited to a pattern of two bars. By setting {\\t alternatebars}\nto another value you can change the frequency of the alternate bar:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   alternatebutton = B1.7}   alternatebutton = B1.7\n\\immediate\\write\\patchexamples{   alternatebars = 4}   alternatebars = 4\n\\end{droidini}\n\nNow bars 1 - 3 are played normally and every forth bar the alternate\npage is applied. That basically forms a pattern of 64 steps.\n\n\n\n\\subsection*{Pattern length and bars}\n\nAs you have at most 16 buttons one pattern can have a length of at most\n16 steps. The length of the pattern can be set in various ways:\n\n\\begin{itemize}\n\\item If you wire at least one {\\t button1} then the length defaults to\nthe number of wired buttons.\n\\item This can be overridden by setting {\\t length} to any value (e.g. {\\t\nlength = 7}).\n\\item If you use the {\\t lengthbutton} then you can interactively change\nthe pattern length during your performance. This will always override the\n{\\t length} input.\n\\end{itemize}\n\nAdd the button for changing the length is easy:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{   lengthbutton = B1.6}   lengthbutton = B1.6\n\\end{droidini}\n\nOne {\\it bar} usually has the same number of steps as your pattern. But if\nyou set {\\t repeats = 2}, one bar will consist of two times the pattern\n(and thus lasts twice as long).\nBars are useful when you use {\\t fills} or {\\it branches}.\n\n\\subsection*{Playing fills}\n\nFills are additional beats the Algoquencer adds at the end of certain bars\nin order to play a musically interesting fill. In order to use this\nfirst wire {\\t fills} to some CV or most likely to a pot:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    fills = P1.1}    fills = P1.1\n\\end{droidini}\n\nNow if you crank up that pot clockwise then more and more beats will\nbe added -- with a tendency to the end of the bar. In music -- however -- playing\na fill each bar is not very interesting. By setting {\\t fillorder} to\n{\\t 1}, {\\t 2} or {\\t 3} (or even a higher number) will make the fills\nassume a cycle of 2, 4 or 8 or move bars. Please see below for details.\n\n\\subsection*{Activity and random}\n\nFour inputs are key features of Algoquencer, since they extend it from\na plain old trigger sequencer to an algorithmic drummer. These are\n{\\t variation}, {\\t activity}, {\\t dejavu} and {\\t morphs}.\nThe latter two already have been discussed when using Algoquencer\nas random generator. They have the same effect here.\n\nThe default value of {\\t variation} is {\\t 0.0}. That means\nthat Algoquencer will exactly play the pattern as you have dialled it\nin with your step buttons. If you increase that value (a pot is handy\nfor doing this, of course) then randomly some of the beats will move to other\nsteps. Setting {\\t various} to {\\t 1.0} will completely alter your\npattern. The number of beats will stay the same!\n\n{\\t activity} will change exactly that: the number of triggered beats\nin one bar. The default value is {\\t 0.5} -- which is the center position\nif assigned to a pot. Here the number of played beats is exactly the\nsame as you have set in your pattern. Turn it left to remove (randomly)\nsome of the beats. Turn it right to add some. At {\\t 0.0} no beats\nare triggered, at {\\t 1.0} there is a beat for every clock cycle.\n\nThe {\\t activity} also has an effect when you create random voltages.\nHere the voltage only changes when a ``beat'' happens at that step,\neven if you are not using the {\\t trigger} output.\n\n\\subsection*{Further nifty parameters}\n\nThere are some more interesting parameters like {\\t rolls}, {\\t offbeats},\n{\\t distribution} and {\\t branches}. Please look at the table of inputs\nfor more details.\n\n\\subsection*{Presets}\n\nThe algoquencer supports up to 16 presets. Each preset comprises\nall settings that can be interactively changed, i.e. the activated\nsteps, accents, alternate steps, the manually changed length, the\nstate of the mute button and also the current random seed (which\nwas modified by {\\t nextpattern}, {\\t prevpattern} or {\\t reroll}.\n\nThere are three ways of switching between presets. The first way\nis easy to implement. Simply send the number of the current preset\nto the input {\\t preset}. It has to be a number from {\\t 0} to {\\t 15}.\nYou can for example use a pot if you multiply it with 15:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    preset = P1.1 * 15}    preset = P1.1 * 15\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow any change you make will immediately be saved to that current\npreset. If you change the preset number by turning the pot, another\npreset will immediately be loaded and activated.\n\nThe second -- more sophisticated -- way is to use triggers for\nloading and saving. These could be buttons, e.g.:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    preset = P1.1 * 15}    preset = P1.1 * 15\n\\immediate\\write\\patchexamples{    loadpreset = B1.1}    loadpreset = B1.1\n\\immediate\\write\\patchexamples{    savepreset = B1.2}    savepreset = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow turning the knob does not load or save any preset. The input {\\t preset}\nis just evaluated when you press {\\t B1.1} or {\\t B1.2}:\n\n\\begin{itemize}\n\\item A trigger to {\\t savepreset} will save the current settings into the preset\nthat is selected with the {\\t preset} input.\n\\item A trigger to {\\t loadpreset} will copy the contents of the preset selected\nby {\\t preset} into the current settings.\n\\end{itemize}\n\nNote: In the second mode you effectively have 17 presets, since the \"current\nsettings\" could also be considered to be a preset. The advantage of this mode\nis that playing around with the settings of the algoquencer does not immediately\neffect any of the presets.\n\nHint: In order to avoid saving or loading presets by mistake, have a look\nat the \\circuit{button} circuit and the {\\t longpress} output. It sends\na trigger when a button is pressed and hold for a certain time.\n\nThe {\\bf third} way is a combination of the first two ways. Here you\nwork with triggers, as well. But these triggers at the same time hold the\nnumber of the preset to load or to save. This makes situations easier\nwhere you have one button per preset\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{   input1 = B1.1 * 1}   input1 = B1.1 * 1\n\\immediate\\write\\patchexamples{   input2 = B1.2 * 2}   input2 = B1.2 * 2\n\\immediate\\write\\patchexamples{   input2 = B1.3 * 3}   input2 = B1.3 * 3\n\\immediate\\write\\patchexamples{   output = _LOAD_PRESET}   output = _LOAD_PRESET\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{   input1 = B1.4 * 1}   input1 = B1.4 * 1\n\\immediate\\write\\patchexamples{   input2 = B1.5 * 2}   input2 = B1.5 * 2\n\\immediate\\write\\patchexamples{   input2 = B1.6 * 3}   input2 = B1.6 * 3\n\\immediate\\write\\patchexamples{   output = _SAVE_PRESET}   output = _SAVE_PRESET\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    loadpreset = _LOAD_PRESET}    loadpreset = _LOAD_PRESET\n\\immediate\\write\\patchexamples{    savepreset = _SAVE_PRESET}    savepreset = _SAVE_PRESET\n\\end{droidini}\n\nThis means that if the trigger CV has the value {\\t 2} when it is non-zero,\nit load preset number 2. This mode is automatically active, if you don't\npatch the {\\t preset} input.\n\nThere is one drawback of this method: you cannot easily access preset number\n{\\t 0} that way, since the CV {\\t 0} is not sufficient for triggering the\ninput. The trick is sending a value larger than {\\t 0.1} (which is the\nthreshold for boolean ``true'' values) and less than {\\t 0.5} (which would\nbe rounded to 1). So for example send a trigger with the value {\\t 0.3}\nto load or save preset number 0.\n\n\n\\subsection*{Sharing buttons between multiple algoquencers}\n\nThe buttons on your controllers are a valuable ressources and not\nto be wasted lightheartedly. And especially the {\\t algoquencer} uses quite\na lot of buttons. But the good news is: you can share most of these\nbuttons with other instances of {\\t algoquencer}, to create a multi-track\nsequencer with just one set of buttons. You can even share the buttons\nwith completely other circuits.\n\nThe key to this is the {\\t select} input. If you patch it, all buttons\nand LEDs will just be used by this instance of {\\t algoquencer} as long\nas {\\t select} gets a high gate signal. Here is an example (which is just a\nsketch and not complete):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select = _SELECT_1}    select = _SELECT_1\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select = _SELECT_2}    select = _SELECT_2\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nNow you need to make sure that at any given time either {\\t \\_SELECT\\_1}\n{\\it or} {\\t \\_SELECT\\_2} is active. The easiest way is with a {\\t buttongroup},\nbecause here you can add more and more tracks if you like. Let's assume that\nfor switching between tracks you use the buttons {\\t B2.7} (track 1) and\n{\\t B2.8} (track 2). This would look like this:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B2.7 # select track 1}    button1 = B2.7 # select track 1\n\\immediate\\write\\patchexamples{    button2 = B2.8 # select track 2}    button2 = B2.8 # select track 2\n\\immediate\\write\\patchexamples{    led1 = L2.7}    led1 = L2.7\n\\immediate\\write\\patchexamples{    led2 = L2.8}    led2 = L2.8\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select =  L2.7 # becomes 1 if B2.7 is selected}    select =  L2.7 # becomes 1 if B2.7 is selected\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    select =  L2.8 # becomes 1 if B2.8 is selected}    select =  L2.8 # becomes 1 if B2.8 is selected\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nPlease note: the buttons {\\t mutebutton} and {\\t unmutebutton} and their\naccording LEDs are {\\bf not} handled by the {\\t select} jack. The idea is\nthat they always get their own dedicated buttons. This allows you to quickly\nmute or unmute several tracks at once.\n\n\\clearpage", "inputs": [{"name": "clock", "type": "trigger", "default": null, "description": "Clock input. This is mandatory. For each clock pulse the sequencer\nis advanced by one step.\n", "essential": 2, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "Reset input. A trigger here switches back to step 1.\n", "essential": 1, "ramsize": 16}, {"prefix": "button", "name": "button1 ... button16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "\\nth1 ... \\nth{16} step button. Assign these buttons to\nbuttons on your controllers.\n", "essential": 1, "essential_count": 8, "ramsize": 16}, {"name": "length", "type": "integer", "default": "unpatched", "description": "Sets the length of the pattern. Note: if you use\n{\\t lengthbutton}, this input is ignored as soon as the\nlength button has been used for the first time. If you have assigned at\nleast one button, the default value of {\\t length} is the number\nof buttons you have assigned. Otherwise it defaults to {\\t 16}.\nThe maximum length is 64. Any larger number will be truncated\nto 64.\n", "essential": 0, "ramsize": 12}, {"name": "pattern", "type": "integer", "default": "unpatched", "description": "Selects a pattern of pseudo random values. If you set {\\t dejavu}\nto 1, all ``random'' decision are deterministic and repeat again\nand again. If you do not like these choices, you can choose a\ndifferent pattern, just by setting this input to any integer number\nyou like. The default pattern is 0. If you patch a pot here, simply\nmultiply it by the number of different patterns you want to select,\ne.g. {\\t pattern = P1.1 * 10}. This will allow you to select one of\nthe pattern 0, 1, ... 10.\n\nNote: If you use {\\t pattern}, the trigger inputs {\\t nextpattern},\n{\\t prevpattern} and {\\t reroll} are ignored.\n", "essential": 0, "ramsize": 12}, {"name": "nextpattern", "type": "trigger", "default": null, "description": "Switches forward to the next pseudo random pattern.\n", "essential": 0, "ramsize": 16}, {"name": "prevpattern", "type": "trigger", "default": null, "description": "Switches back to the previous pseudo random pattern.\n", "essential": 0, "ramsize": 16}, {"name": "reroll", "type": "trigger", "default": null, "description": "Select one of the pseudo random patterns completely by random.\n", "essential": 0, "ramsize": 16}, {"name": "clearpage", "type": "trigger", "default": null, "description": "A trigger here unselects all step buttons in the currently active page\n(normal, alternate, accent).\n", "essential": 0, "ramsize": 16}, {"name": "pitchlow", "type": "cv", "default": "0", "description": "This set a lower voltage boundary for the {\\t pitch} output for\nnotes that are randomized.\n", "essential": 0, "ramsize": 12}, {"name": "pitchhigh", "type": "cv", "default": "0.3", "description": "This set an upper voltage boundary for the {\\t pitch} output for\nnotes that are randomized.\n", "essential": 0, "ramsize": 12}, {"name": "pitchresolution", "type": "integer", "default": "0", "description": "If this is non-zero, it make the {\\t pitch} output adopt that number of\npossible discrete values. E.g. if you set it to {\\t 2}, only the values\nset by {\\t pitchlow} and {\\t pitchhigh} are possible. A value of {\\t 3} will\nallow an additional value in the middle, and so on.\n", "essential": 0, "ramsize": 12}, {"name": "gatelength", "type": "cv", "default": "0.1", "description": "The gate length in input clock cycles. A value of {\\t 0.5} (5~V)\nthus means half a clock cycle. A steady input clock is needed for\nthis to work. Please note that if the gate length is $>= 1.0$,\ntwo succeeding notes will get a steady gate, which\nessentially means legato.\n\nWhen playing rolls, i.e. more than one beat per step, the\ngate length is divided by the number of rolls. That way the gates\nget shorter and even at a gatelength close to 1.0 the gates\nare still audible and do not merge together.\n", "essential": 0, "ramsize": 12}, {"name": "lengthbutton", "type": "gate", "default": null, "description": "Map this to a button like {\\t B1.1}. While you press and hold\nthis button the sequencer switches to {\\it change length mode}. While\nin this mode a press of one of the step buttons will change the length\nof the pattern. Also while in this mode the LEDs of the step buttons will\nshow the current length. If you do not like to hold the button but\nswitch it on and off, you can create a toggle button with {\\t [button]} and\nsend its output here.\n", "essential": 0, "ramsize": 12}, {"name": "repeats", "type": "integer", "default": "1", "description": "Usually one bar has the length of one pattern. Setting this to 2\nwill consider one bar as a run of two times through the pattern. So\nif you have 8 buttons and {\\t bars = 2}, one bar will be 16\nsteps, where the \\nth{1} and \\nth{9} step are set by {\\t button1},\n\\nth{2} and \\nth{10} by {\\t button2} and so on.\n\nWhy should that be useful? Well -- the difference shows up when you\nuse {\\t fills}, or {\\t branches} or work with the {\\it alternate}\npattern. These three algorithms work based on {\\it bars}. And {\\t\nrepeats = 2} makes one bar have 16 steps, even if you just have\neight buttons.\n", "essential": 0, "ramsize": 12}, {"name": "alternaterepeats", "type": "integer", "default": "unpatched", "description": "If you are use using {\\t repeats} and {\\t alternatebars} / {\\t alternatebutton}\nat the same time, with this input you can specify a different\nvalue for repeats when it comes to selecting the alternate button\npage.\n\nAssume you have eight buttons and {\\t repeats = 2} and\n{\\t alternatebars = 2}. Then Algoquencer will play two times your\n8-step pattern normally and two times alternated (since two times\nthe 8 steps form one bar). This results in a form of A A B B.\n\nIf you want your form rather to be A B A B, set {\\t alternaterepeats\n= 1}. This way, when it comes to alteration, the length of one bar\nis just normal length (8 steps here).\n", "essential": 0, "ramsize": 12}, {"name": "branches", "type": "integer", "default": "0", "description": "Enables the branching feature (sometimes also called fractal sequencing.\nWhen {\\t branches = 1}, then every second bar will be using other\nrandom values -- giving a sequence of the bars\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}}.\n\nWith {\\t branches = 2} you get a sequence of the form\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{C}}.\n\nA value of {\\t 3} creates an even longer sequence that repeats itself\nafter eight bars:\n{\\footnotesize\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{C}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{B}\n\\framebox[5mm][c]{A}\n\\framebox[5mm][c]{D}}.\n\nNote: this only takes effect when you set {\\t dejavu} $>0$. The largest\neffect is when it is set to {\\t 1}. And the you need to use either\n{\\t variation} or set {\\t activity} to a value greater than {\\t 0.5}.\nBecause otherwise Algoquencer will strictly play the gates that you've set\nwith your buttons and then every bar will be the same, of course.\n", "essential": 0, "ramsize": 12}, {"name": "mutebutton", "type": "trigger", "default": null, "description": "Wire this to a button like {\\t B1.2}. When you press the\nbutton once, all triggers are muted. Pressing again unmutes\nthem. So this behaves like a toggle {\\t [button]} in itself.\nYou probably want to wire {\\t muteled} to the LED in that button,\ne.g. {\\t L1.2}. It show the mute state. The mute button works\ntogether with the unmute button (see below). Note: even if you\nuse the {\\t select} jack in order to overlay your buttons with\nseveral algoquencers, the {\\t mutebutton} will always be active.\nThe idea is to always have direct access to this button.\n", "essential": 0, "ramsize": 16}, {"name": "unmutebutton", "type": "trigger", "default": null, "description": "A trigger to this jack resets the mute button exactly\nat the beginning of the next bar. While waiting for that\nto happen, the output {\\t unmuteled} will blink. Wire this\nto the LED in the button. Note: even if you\nuse the {\\t select} jack in order to overlay your buttons with\nseveral algoquencers, the {\\t mutebutton} will always be active.\nThe idea is to always have direct access to this button.\n", "essential": 0, "ramsize": 16}, {"name": "accentbutton", "type": "gate", "default": null, "description": "While this input is high you are in {\\it accent editing mode}. This\nis very similar to the mode where you set the length. But now for\neach step you edit whether this step is outputting an accent when\ntriggered. You might want to use a toggle button for this function, so\nyou can operate without holding down the button all the time.\n", "essential": 0, "ramsize": 12}, {"name": "alternatebutton", "type": "gate", "default": null, "description": "If this input is high, you are in {\\it alternate editing mode}.\nEvery Algoquencer has an alternate set of steps. Each step\nthat is currenty activated {\\it toggles} the state of the normal step,\nbut only for each even bar. This allows to introduce variations\nof the pattern that occur every second bar.\n", "essential": 0, "ramsize": 12}, {"name": "alternatebars", "type": "integer", "default": "2", "description": "With this input you can change the influence of the\n{\\t alternatebutton}. Per default the pattern alternation is\ndone every second bar. You can change this to any number you\nlike with this input. Values less than {\\t 1} will be considered\nas one -- which means that every bar is alternated.\n", "essential": 0, "ramsize": 12}, {"name": "accentlow", "type": "cv", "default": "0", "description": "This value is output at {\\t accent} when a note without an\naccent is being triggered or when no note is triggered at all.\n", "essential": 0, "ramsize": 12}, {"name": "accenthigh", "type": "cv", "default": "1", "description": "This value is output at {\\t accent} while a note with an\naccent is triggered. The value will be kept for the full time\nof the clock cycle.\n", "essential": 0, "ramsize": 12}, {"name": "activity", "type": "bipolar", "default": "unpatched", "description": "This is the most important parameter and  you will probably\nwire it to a pot like {\\t P1.1}. The activity controls, how\n``busy'' the sequencer is playing, or in other words how often\na step gets an active gate (und thus a changing output pitch).\n\nLet's first assume that {\\t variation}\nis set to {\\t 0.0} (which is the default). Then at a value of\n{\\t 0.5} (or pot at 12'clock) Algoquencer will exactly play that\npattern that you have set with the step buttons. Turning the knob\nCCW will remove more and more beats from the pattern until it is\ncompletely silent at a value of {\\t 0.0} (or pot fully\nCCW). But if you turn up the knob above the middle position then more\nand more {\\it additional} beats will be placed into you pattern in\na random way until -- at {\\t 1.0} -- a trigger will happen at\n{\\it every} beat.\n\n{\\bf Note}: If you do not use step buttons, this parameter\nbehaves slightly different: A value of {\\t 0.5} then means an\nactivity of 50\\%, which means that exactly the half of the steps\nwill get an event. This is different from a situation where you\n{\\it have} defined buttons but all are deselected. In that case\n{\\t 0.5} means that exactly the number of beats of your pattern\nare being played, which is zero in that case.\n", "essential": 1, "ramsize": 12}, {"name": "variation", "type": "fraction", "default": "0", "description": "The {\\it variation} controls how strictly Algoquencer will stick\nto the pattern that you have set with your step buttons. You probably\nwant to wire this to a knob. A value of {\\t 0.0} (or the knob\nfully CCW) will allow no variations. Your pattern will be played exactly\nas it is. If the {\\it activity} goes beyond {\\t 0.5}, additional\nbeats will be placed, of course. And these are random.\n\nIf you increase the variation, more and more beats of your\npattern are being replaced with other beats -- while keeping the\ntotal number of beats the same. If you set {\\t variation} to\n{\\t 1.0} (or the pot fully CW) then your pattern is completely\nignored except for the actual number of beats it contains.\n", "essential": 1, "ramsize": 12}, {"name": "dejavu", "type": "fraction", "default": "1", "description": "The {\\t dejavu} parameter controls what {\\it random} should mean.\nIf {\\t dejavu = 0.0}, then all random decisions are completely\nchaotic -- and every time a decision is taken the dice are being\nrolled again.\n\nAt {\\t dejavu = 1.0} on the other hand -- once a random decision\nhas been taken for a certain step in a certain bar, it will stay\nalways the same from now on. This will lead to repeating exactly\nthe pattern bars over and over again. We sometimes call this random\nto be ``deterministic''.\n\nAny position in between will choose some of the steps as chaotic\nrandom and some of the steps as deterministic.\n", "essential": 1, "ramsize": 12}, {"name": "morphs", "type": "fraction", "default": "0", "description": "This parameter will introduce changes in formerly taken\nrandom decisions from time to time.\nIf you set it above zero, at every start of a bar {\\it some}\nof the deterministic random decisions will be remade. Setting\n{\\t morphs = 1} will essentially disable {\\t dejavu}, since all\ndecisions are redone every bar anyway then.\n\nIf you know the Turing Machine: In principle that has the same idea,\nbut Algoquencer has a few improvements:\n\n\\begin{itemize}\n\\item The number of random changes is exactly controlled by the setting.\nAt each specific setting of {\\t morphs} the same number of\nchanges will be done at each bar.\n\\item Changes only appear at the beginning of each bar. If\nyou use {\\t branches}, they will appear whenever you sequence\nis over.\n\\item Small settings will introduce just one morph each \\nth{64} step.\n\\end{itemize}\n", "essential": 1, "ramsize": 12}, {"name": "offbeats", "type": "bipolar", "default": "0.5", "description": "Whenever random beats are being placed then this setting controlls\nwhether {\\it downbeats} or {\\it offbeats} should be preferred. At at\nsetting of {\\t 0.5} there will be no difference. If you increase the\nvalue then more and more offbeats will appear. Offbeats are steps with\nan {\\it even} number, like 2, 4, 6 and so on. Value smaller than\n{\\t 0.5} will prefer downbeats.\n\nOffbeats sound more ``complex'' and downbeats more simple or\n``down to earth''.\n", "essential": 0, "ramsize": 12}, {"name": "distribution", "type": "bipolar", "default": "0.5", "description": "This is very similar to {\\t offbeats}, but this time you decide\nwhether beats should be placed rather in the first half of the bar\nor in the second half.\n", "essential": 0, "ramsize": 12}, {"name": "fills", "type": "fraction", "default": "0", "description": "When this parameter is set above {\\t 0.0}, additional\nbeats will be placed in order to make the beat more ``active''. This\nhappens at musically useful times controlled by {\\t fillorder} (see\nbelow). The additional beats within the bar are placed in a way that\nprefers the end of the bar. If there are already too many beats in the\nbar then the fill will {\\it remove} or change some instead.\n", "essential": 0, "ramsize": 12}, {"name": "fillorder", "type": "integer", "default": "0", "description": "This integer number controls how fills are being placed:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{every bar}\n\\jacktablerow{1}{every second bar}\n\\jacktablerow{2}{small fill in bar 2, big fill in bar 4}\n\\jacktablerow{3}{tiny fill in bar 2 and 6, medium fill in bar 4, big fill in bar 8}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 12}, {"name": "rolls", "type": "fraction", "default": "0", "description": "This parameter controls if drum rolls (or ratchets as you might\ncall it) are being created. At {\\t 0.0} no rolls are being created.\nAt {\\t 1.0} {\\it every} beat will be converted into a roll. Rolls\nalways happen before the actual beat, they lead to it. If you\nusing this feature for snare rolls you might want to use the\noutput {\\t rollvelocity} for controlling the snare volume.\n", "essential": 0, "ramsize": 12}, {"name": "rollcount", "type": "integer", "default": "1", "description": "Number of additional beats for playing the roll. Setting\n{\\t rollcount = 0} would disable rolls. All these beats are\ndistributed in the clock tick before the beat the roll is\nleading to. The first beat of the roll is exactly one tick before\nthat beat -- or more if you increase {\\t rollsteps}.\n", "essential": 0, "ramsize": 12}, {"name": "rollsteps", "type": "integer", "default": "1", "description": "Length of the roll in clock ticks (steps). The total number\nof additional beats is thus {\\t rollcount} $\\times$ {\\t rollsteps}\n", "essential": 0, "ramsize": 12}, {"name": "rollstartvelo", "type": "cv", "default": "0.5", "description": "Rolls can be played with an increasing velocity. This first\nbeat starts with the velocity set with this parameter. Then\nevery beat gets a bit louder until the last beat is played with\nvelocity {\\t 1.0}. The velocity for rolls is output at the jack\n{\\t rollvelocity}.\n", "essential": 0, "ramsize": 12}, {"prefix": "pitch", "name": "pitch1 ... pitch16", "count": 16, "start_at": 1, "type": "cv", "default": "unpatched", "description": "You can use these inputs, if you want the pitches of the {\\t pitch}\noutput play a certain melody. That way the Algoquencer behaves like\na normal melody sequencer -- but all the algorithmic parameters will\nbe applied. For example {\\t variation} will also be applied to these\nnotes. Note: If {\\t length} is larger than 16, these pitch inputs\nwill be cycled through, so step 17 uses {\\t pitch1}, step 18 uses\n{\\t pitch2} and so on.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "trigger", "type": "trigger", "default": null, "description": "Here comes the trigger output. Patch this to the trigger input\nof your drum or synth voice.\n", "essential": 2, "ramsize": 8}, {"name": "gate", "type": "gate", "default": null, "description": "The gate output is alternative to the trigger and has a variable\nlength. It is useful when Algoquencer is used for creating melodies.\nPatch the gate input of an envelope or something similar here.\n", "essential": 0, "ramsize": 8}, {"name": "pitch", "type": "stepped", "default": null, "description": "Outputs the (pseudo-)random voltage (unquantized) at each step\nwith an active gate. This honors all the settings that control the randomness\nand variation, like {\\t dejavu}, {\\t variation}, {\\t fills} and {\\t branches}.\n", "essential": 2, "ramsize": 4}, {"name": "accent", "type": "cv", "default": null, "description": "Whenever a beat with an accent is being played, the value\nset by {\\t accenthigh} is sent here, otherwise {\\t accentlow}.\nIf you are wiring this to one of the jacks of the G8 expander\nthen that will output just 0V and 5V of course.\n", "essential": 1, "ramsize": 4}, {"prefix": "led", "name": "led1 ... led16", "count": 16, "start_at": 1, "type": "stepped", "default": null, "description": "\\nth1 ... \\nth{16} LEDs of the step buttons. Assign these\nto the LEDs in the step buttons.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "barled", "name": "barled1 ... barled4", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "Patch these output to some LEDs in order to show you the\ncurrent bar in the sequence.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "rollvelocity", "type": "cv", "default": null, "description": "If you enable rolls, then the velocity of the roll beats\nwill be output here. For normal beats this will always be {\\t 1.0}.\n", "essential": 0, "ramsize": 4}, {"name": "startofbar", "type": "trigger", "default": null, "description": "At the beginning of every bar a trigger is output here.\n", "essential": 0, "ramsize": 8}, {"name": "muteled", "type": "gate", "default": null, "description": "Wire this to the LED in your mute button. It will then be lit\nwhile the voice is muted.\n", "essential": 0, "ramsize": 4}, {"name": "unmuteled", "type": "gate", "default": null, "description": "Wire this to the LED in your unmute button (if used). It will\nblink while the unmute is waiting for the start of the next bar.\n", "essential": 0, "ramsize": 4}, {"name": "morphled", "type": "gate", "default": null, "description": "This output will get a trigger every time a morph happens. It\nis intended to be wired to an LED.\n", "essential": 0, "ramsize": 8}, {"name": "fillsled", "type": "gate", "default": null, "description": "This output will get a trigger every time a fill beat is being\nplayed. Wire this to some LED if you like.\n", "essential": 0, "ramsize": 8}, {"name": "branch", "type": "integer", "default": null, "description": "This output will output the current branch number, e.g. 1, 2, 3 and\nso on. If you do not use {\\t branches} then it is always 1.\n", "essential": 0, "ramsize": 4}, {"name": "lengthoutput", "type": "integer", "default": null, "description": "Outputs the currently selected length. This is useful if you are\nusing the {\\t lengthbutton} for interactively changing the length\nof the pattern and want to share that setting with other circuits.\n", "essential": 0, "ramsize": 4}], "presets": 16, "manual": 80, "ramsize": 872}, "arpeggio": {"category": "sequencing", "title": " Arpeggiator -- pattern based melody generator", "description": "This circuit creates melodic patterns based on simple rules and many\ninteresting configuration settings, which can lead to very simple\nbut also most complex patterns.\n\n\\subsubsection*{Introduction}\n\nIn order to better understand, how the arpeggiator works, let's compare four\ndifferent ways for constructing melodies:\n\n{\\footnotesize\n\\begin{tabular}{p{27mm}|p{44mm}}\nSequencer & manually composed melodies \\\\ \\hline\nRandom generator & completely chaotic sequences \\\\ \\hline\nTuring machine,\n\\newline Algoquencer\n& pseudo-random melodies, which repeat themselves \\\\ \\hline\nArpeggiator & melodies constructed from rules \\\\\n\\end{tabular}}\n\nThe rules for the arpeggiator can be as simple as {\\it on each clock tick\nplay the next note in the C minor scale.} Additional parametes are for\nexample the pitch range, i.e. the start and the end note.\n\nThe arpeggiator shares root, scale and interval selection with {\\t chord} (see\npage \\pageref{chord}) and {\\t minifonion} (see page \\pageref{minifonion}).\nIf you own a Sinfonion: the arpeggiator in the DROID is working a bit\ndifferently and is more about general principles than about preprogrammed\npatterns.  That makes it more flexible and powerful.\n\n\\subsection*{The simplest possible example}\n\nAs always, we start with the simplest possible example. And it is simple,\nindeed, since each of the many parameters has a useful default value. The only\ninput the arpeggiator  {\\it always} needs is a clock input.  The word ``clock''\nis probably a bit misleading since it doesn't {\\it need} to be a steady clock\nsignal. It can be any rhythmic pattern you like.  Each clock tick advances the\nmelody to the next note and a new pitch CV will be presented at {\\t output},\nwhich is, of course, in the typical 1V/oct scheme.\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nPatch {\\t I1} to an external clock and {\\t O1} to the 1V/oct of some\nsynth voice. The easiest way is to use the same clock also for triggering\nthe voice's envelope.\n\nNow you will hear a C major scale (lydian) being played step by step in a\nrange from 0~V to 2~V. This makes 15 notes, since the scale consists of the seven\nnotes C, D, E, F\\sharp, G, A and B and is repeated over two octaves, but the\nC is here three times: at the beginning, in the middle and at the end:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=18]\n\\repeat volta 2 {c'8 d' e' fis' g' a' b' c'' d'' e'' fis'' g'' a'' b'' c'''}\n\\end{lilypond}\n\nWhen it reaches the end it immediately starts over again. So the second ``bar''\nis really just 7 eights here!\n\n\n\\subsubsection*{Root, scale and interval selection}\n\nYou probably don't like lydian C major. Changing that is easy with the\ninputs {\\t root} and {\\t degree}. Please have a look at the {\\t minifonion}\ncircuit (see page \\pageref{minifonion}) for an explanation of these\nparameters. Let's go for a D minor (natural) scale as an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    root = 2}    root = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\end{droidini}\n\nNow we get:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  d'8\n  e' f' g' a' bes' c'' d'' e'' f'' g'' a'' bes'' c''' d'''}\n\\end{lilypond}\n\n\\subsubsection*{Patterns}\n\nThis ``go through the scale'' mode is just one of several possible patterns.\nThe pattern is selected with the {\\t pattern} input. And the default value\nof {\\t 0} produces the result we just have seen. Let's look at pattern\n{\\t 1}. This goes two steps forward and one step backward in the scale:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    root = 2}    root = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\immediate\\write\\patchexamples{    pattern = 1}    pattern = 1\n\\end{droidini}\n\nSince pattern 1 repeats its structure every three notes it's\nbest to display it in a metric that is divisible by three:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ \\time 6/8\n  d'8 ^\\markup {pattern 1}\n  e' f'\n  e' f' g'\n  f' g' a'\n  g' a' bes'\n  a' bes' c''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 2} is similar, but makes one double step forward instead\nof two single steps:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ d'8 ^\\markup {pattern 2}\n  f' e' g'\n  f' a' g' bes'\n  a' c'' bes' d''\n  c'' e'' d'' f''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 3} goes a double step forward, a double step backward and a\nsingle step forward:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{ \\time 6/8\n  d'8 ^\\markup {pattern 3}\n  f' d' e' g' e' f' a' f' g' bes' g' a' c'' a' \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 4} is even more sophisticated. It goes a double step forward,\na single step forward, a double step {\\it backward} and again a single\nstep forward:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n{\n  d'8 ^\\markup {pattern 4}\n  f' g' e'\n  f' a' bes' g'\n  a' c'' d'' bes'\n  c'' e'' f'' d''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nPattern {\\t 5} is a bit different since for each note it flips a coin\nfor deciding whether to go one step up or down.\n\nAnd Pattern {\\t 6} simply randomly chooses one of the possible notes. So\nstrictly spoken this has nothing to do with ``arpeggiation'', but it's\nfun, so what?\n\nNote: it's not entirely impossible that future versions of the arpeggiator\nintroduce new patterns. So better do not yet rely on these numbers to be\nfixed forever.\n\n\\subsubsection*{The range}\n\nPer default the pattern is played in a range of two octaves. But\nthat can be set easily with two parameters. {\\t pitch} defines the\nlowest possible pitch of a note. The arpeggiator will chose the\nstart note such that it is in the scale and just at or above this\npitch.\n\nAnd {\\t range} defines the voltage range the pattern is being played\nupwards until it starts again. So if {\\t range} is 2~V, you get a range\nof two octaves. A range of 0 will deform the pattern into one single\nnote.\n\nFor interactive playing, mapping {\\t pitch} and {\\t range} to pots\nis fun:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pitch = P1.1}    pitch = P1.1\n\\immediate\\write\\patchexamples{    range = P1.2}    range = P1.2\n\\end{droidini}\n\n\\subsubsection*{Changing the playing direction}\n\nSo far all pattern where going more or less upwards. From lower\nnotes to higher notes. This can be changed by setting {\\t direction}\nto {\\t 1}. Now the arpeggiator starts with the highest allowed note\nand reverses the pattern for going downwards. Why not map this\nsetting to a nice toggle button?\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    output = _DIRECTION}    output = _DIRECTION\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pitch = P1.1}    pitch = P1.1\n\\immediate\\write\\patchexamples{    range = P1.2}    range = P1.2\n\\immediate\\write\\patchexamples{    direction = _DIRECTION}    direction = _DIRECTION\n\\end{droidini}\n\nAnother setting that influences the direction is the {\\t pingpong}\nparameter. This is a binary (gate) input, too. If it is set to {\\t 1}\nthe direction of the pattern changes into the opposite once the end\nof the range has been reached. Check this example...\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pingpong = 1}    pingpong = 1\n\\immediate\\write\\patchexamples{    pitch = 0}    pitch = 0\n\\immediate\\write\\patchexamples{    range = 7/12V}    range = 7/12V\n\\end{droidini}\n\n... will create the following melody:\n\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 d' e' fis'\n  g' fis' e' d'\n}\n\\end{lilypond}\n\nWhy is that? Well -- $\\frac{7}{12}$~V is the same as 7 semitones,\nwhich is in turn one fifth. Since no root and degree are defined\nwe are back at C major lydian. The pattern is 0 (default) -- hence\nthe simple note-by-note scale. And {\\t pingpong = 1} makes the pattern\ngoing down again after having reached the upper limit.\n\n\\subsubsection*{Octaves up and down}\n\nThe nice thing about all these parameter is that you can combine\nthem all. They interact with each other and most combinations do\nuseful things (well, when using the ``random'' pattern, the direction\nand pingpong are without effect, of course). And there is one more\nfun setting: {\\t octaves}. This can be {\\t 0} (default) or {\\t 1} or\n{\\t 2}.\n\nWhen octaves is {\\t 1}, each note is directly followed by the same\nnote one octave above. That octave note is ignoring the {\\t range}-parameter.\nIt is always in addition to the selected range. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    range = 1V}    range = 1V\n\\immediate\\write\\patchexamples{    octaves = 1}    octaves = 1\n\\end{droidini}\n\nAnd here is the pattern this creates:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 ^\\markup {octaves = 1} c'' d' d'' e' e'' fis' fis''\n  g' g'' a' a'' b' b'' c'' c'''\n}\n\\end{lilypond}\n\nSet {\\t octaves = 2} and you get the same but the octaves go {\\it down}\ninstead:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 ^\\markup {octaves = 2} c d' d e' e fis' fis\n  g' g a' a b' b c'' c'\n}\n\\end{lilypond}\n\n\n\\subsubsection*{Dropping}\n\nThe {\\t drop} input lets you select different schemes of leaving out\nnotes from the original line of scale notes. For example {\\t drop = 1}\nwill leave out every second note. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    drop = 1}    drop = 1\n\\end{droidini}\n\nThis will create the following melody:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  c'8 e' g' b'\n  d'' f'' a'' c'''\n}\n\\end{lilypond}\n\nIf you have a closer look, you will see that in the upper octave other\nnotes are being played than in the lower octave. This can sound very\ninteresting!\n\nDropping can, of course, be combined with other patterns as well.\nLet's see the line for pattern 1:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  \\time 6/8\n  c'8 e' g'\n  e' g' b'\n  g' b' d''\n  b' d'' f''\n  d'' f'' a''\n  \\bar \";\"\n}\n\\end{lilypond}\n\nThere are more dropping-schemes. Please have a look into the table\nof input parameters down below.\n\n\\subsubsection*{Note selection}\n\nThe most important thing comes last. For didactical reasons! What {\\it really}\nmakes this arpeggiator so musically versatile is its interval selection.\nThis is the same as for the {\\t minifonion} (see page \\pageref{minifonion})\nand the chord generator (page \\pageref{chord}).\n\nThe point is that you are not restricted to the seven notes of a scale.\nFor this there are seven inputs {\\t select1}, {\\t select3}, ...\n{\\t select13} that select the notes of the current scale and\nanother five inputs {\\t selectfill1} ... {\\t selectfill5} that\nselect the notes not in the current scale.\nThese 12 inputs are binary inputs that expect either {\\t 0} or\none {\\t 1}. Each of them selects one of the seven intervals of the\nscale for being part of the chord. Here is a table of all these\ninputs and the notes they would select in a C major or C minor scale:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|c|c|c|}\\hline\nInput & interval & step & C$^{maj}$ & C$^{min}$ \\\\\n{\\t select1}  & root               & {\\t I}   & C & C \\\\\n{\\t select3}  & \\nth{3}            & {\\t III} & E & E\\flat \\\\\n{\\t select5}  & \\nth{5}            & {\\t V}   & G & G \\\\\n{\\t select7}  & \\nth{7}            & {\\t VII} & B & B\\flat \\\\\n{\\t select9}  & \\nth{9} = \\nth{2}  & {\\t II}  & D & D \\\\\n{\\t select11} & \\nth{11} = \\nth{4} & {\\t IV}  & F & F \\\\\n{\\t select13} & \\nth{13} = \\nth{6} & {\\t VI}  & A & A\\flat \\\\\n\\hline\n\\end{tabular}}\n\nLet's make a simple example: The arpeggio of a C major {\\it triad}\nover two octaves going up and down again:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    select1 = 1}    select1 = 1\n\\immediate\\write\\patchexamples{    select3 = 1}    select3 = 1\n\\immediate\\write\\patchexamples{    select5 = 1}    select5 = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    pingpong = 1}    pingpong = 1\n\\end{droidini}\n\nAnd here is the result:\n\n\\hspace{-4mm}\n\\begin{lilypond}[staffsize=17]\n\\repeat volta 2 {\n  \\time 6/8\n  c'8 e' g'\n  c'' e'' g''\n  c''' g'' e''\n  c'' g' e'\n}\n\\end{lilypond}\n\n\nOne typical way to select these notes is with seven toggle buttons.\nMuch like the Sinfonion. Assign the output\nof each of the seven buttons to one of these functions:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led = L1.2}    led = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led = L1.3}    led = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led = L1.4}    led = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.5}    button = B1.5\n\\immediate\\write\\patchexamples{    led = L1.5}    led = L1.5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.6}    button = B1.6\n\\immediate\\write\\patchexamples{    led = L1.6}    led = L1.6\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.7}    button = B1.7\n\\immediate\\write\\patchexamples{    led = L1.7}    led = L1.7\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[arpeggio]}[arpeggio]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    select1 = L1.1}    select1 = L1.1\n\\immediate\\write\\patchexamples{    select3 = L1.2}    select3 = L1.2\n\\immediate\\write\\patchexamples{    select5 = L1.3}    select5 = L1.3\n\\immediate\\write\\patchexamples{    select7 = L1.4}    select7 = L1.4\n\\immediate\\write\\patchexamples{    select9 = L1.5}    select9 = L1.5\n\\immediate\\write\\patchexamples{    select11 = L1.6}    select11 = L1.6\n\\immediate\\write\\patchexamples{    select13 = L1.7}    select13 = L1.7\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow you can switch on and off scale notes for being part of\nthe patterns. Have fun!", "inputs": [{"name": "pitch", "type": "voltperoctave", "default": "0", "description": "Sets the base pitch of the arpeggio. The first note of the\npattern will be the nearest selected note just above that pitch.\n", "essential": 2, "ramsize": 12}, {"name": "range", "type": "voltperoctave", "default": "0.2", "description": "Selects the range between the lowest and highest note of the\narpeggio. A range of 0 means that there is just one single note\npossible and the arpeggio will stick to that note. A value of\n1~V (or 0.1) means that the arpeggio will run over one octave.\nThe maximum allowed range is 0.8 (8 octaves). Higher values will be\ncapped to that.\n", "essential": 1, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "This input is vital: each trigger here make the arpeggio\nmove forward by one step and adapt the pitch output. Without\na clock the arpeggio will do nothing but stick to the same\nnote all the time.\n", "essential": 2, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "Resets the arpeggio to the first step of the current pattern.\n", "essential": 1, "ramsize": 16}, {"name": "pattern", "type": "integer", "default": "0", "description": "Selects one of a list of arpeggio pattern. The following\npatterns are available:\n\n\\begin{tabular}{|l|l|l|} \\hline\n\\jacktablerowE{0}{step forward through the allowed notes}{$\\rightarrow$}\n\\jacktablerowE{1}{two steps forward, one step backward}{$\\rightarrow$ $\\rightarrow$ $\\leftarrow$}\n\\jacktablerowE{2}{double step forward, one step backward}{$\\Rightarrow$ $\\leftarrow$}\n\\jacktablerowE{3}{double step forward, double step backward, single step forward}{$\\Rightarrow$ $\\Leftarrow$  $\\rightarrow$}\n\\jacktablerowE{4}{double step forward, single step forward, double step backward, single step forward}{$\\Rightarrow$ $\\rightarrow$ $\\Leftarrow$ $\\rightarrow$}\n\\jacktablerowE{5}{random single step forward or backward}{$\\leftrightarrow$}\n\\jacktablerowE{6}{random jump to any allowed (other) note}{$\\Updownarrow$}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "direction", "type": "gate", "default": "0", "description": "Sets the general direction in which the pattern moves.\n{\\t 0} means upwards and {\\t 1} means downwards.\n", "essential": 1, "ramsize": 12}, {"name": "pingpong", "type": "gate", "default": "0", "description": "If set to {\\t 1}, the pattern will reverse its direction\nonce it has reached the end of the range. Otherwise it restarts\nfrom the beginning. So enabling {\\t pingpong} is a bit like a triangle\nwave, whereas otherwise it's more like a sawtooth.\n", "essential": 1, "ramsize": 12}, {"name": "butterfly", "type": "gate", "default": "0", "description": "If set to {\\t 1}, every second note in the range of selected\nnotes will be mirrored. So for example you have selected the notes\n1 - 10, the new order will be 1, 10, 2, 9, 3, 8, 4, 7, 5, 6\n", "essential": 1, "ramsize": 12}, {"name": "drop", "type": "integer", "default": "0", "description": "Selects a scheme of skipping some of the allowed scale notes.\nFour different values are allowed:\n\n\\begin{tabular}{|l|l|l|} \\hline\n\\jacktablerowE{0}{Do not skip any notes}{\\ding{202} \\ding{203} \\ding{204} \\ding{205} \\ding{206} \\ding{207}}\n\\jacktablerowE{1}{Skip every second selected note}{\\ding{202} \\ding{193} \\ding{204} \\ding{195} \\ding{206} \\ding{197}}\n\\jacktablerowE{2}{Skip every third selected note}{\\ding{202} \\ding{203} \\ding{194} \\ding{205} \\ding{206} \\ding{197}}\n\\jacktablerowE{3}{Skip the \\nth2 and \\nth3 note of each group of three}{\\ding{202} \\ding{193} \\ding{194} \\ding{205} \\ding{196} \\ding{197}}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "octaves", "type": "gate", "default": "0", "description": "When this is set to {\\t 1} or {\\t 2}, each note will be followed\nby the same note one octave up (for {\\t 1}) or down (for {\\t 2})\nrespectively. These additional octave notes are in addition to the\nselected range.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{Don't play octaves}\n\\jacktablerow{1}{Each note is followed by the same note one octave up}\n\\jacktablerow{2}{Each note is followed by the same note one octave down}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "startnote", "type": "integer", "default": "0", "description": "When {\\t startnote} is set to non-zero, it will force the pattern\nto begin with a certain scale note regardless of the current note\nselection. {\\t 1} will select the first note of the scale (root),\n{\\t 2} the second and so on until {\\t 7}, which selects the \\nth7\nas start note. This force start note replaces the note that would\noriginally have been played.\n", "essential": 0, "ramsize": 12}, {"name": "root", "type": "integer", "default": "0", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{C}\n\\jacktablerow{1}{C\\sharp}\n\\jacktablerow{2}{D}\n\\jacktablerow{3}{D\\sharp}\n\\jacktablerow{4}{E}\n\\jacktablerow{5}{F}\n\\jacktablerow{6}{F\\sharp}\n\\jacktablerow{7}{G}\n\\jacktablerow{8}{G\\sharp}\n\\jacktablerow{9}{A}\n\\jacktablerow{10}{A\\sharp}\n\\jacktablerow{11}{B}\n\\jacktablerow{12}{C}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "degree", "type": "integer", "default": "0", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{lyd -- Lydian major scale (it has a $\\sharp 4$)}\n\\jacktablerow{1}{maj -- Normal major scale (ionian)}\n\\jacktablerow{2}{X$^7$ -- Mixolydian (dominant seven chords)}\n\\jacktablerow{3}{sus -- mixolydian with \\nth3/\\nth4 swapped}\n\\jacktablerow{4}{alt -- Altered scale}\n\\jacktablerow{5}{hm$^5$ -- Harmonic minor scale from the \\nth5}\n\\jacktablerow{6}{dor -- Dorian minor (minor with $\\sharp 13$)}\n\\jacktablerow{7}{min -- Natural minor (aeolian)}\n\\jacktablerow{8}{hm -- Harmonic minor ($\\flat 6$ but $\\sharp 7$)}\n\\jacktablerow{9}{phr -- Phrygian minor scale (with $\\flat 9$)}\n\\jacktablerow{10}{dim -- Diminished scale (whole/half tone)}\n\\jacktablerow{11}{aug -- Augmented scale (just whole tones)}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "select1", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n", "essential": 1, "ramsize": 12}, {"name": "select3", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{3}.\n", "essential": 1, "ramsize": 12}, {"name": "select5", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{5}.\n", "essential": 1, "ramsize": 12}, {"name": "select7", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{7}.\n", "essential": 1, "ramsize": 12}, {"name": "select9", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n", "essential": 1, "ramsize": 12}, {"name": "select11", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n", "essential": 1, "ramsize": 12}, {"name": "select13", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n", "essential": 1, "ramsize": 12}, {"name": "selectfill1", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill2", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill3", "type": "gate", "default": "off", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill4", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill5", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "voltperoctave", "default": null, "description": "This is what it's all about: here comes the pitch CV for the\ncurrent arpeggio note.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 92, "ramsize": 112}, "bernoulli": {"category": "clock", "title": " Random gate distributor", "description": "This circuit implements a ``bernoulli gate''. For each gate or\ntrigger received at {\\t input} there is made a random decision\nof whether to forward that gate to {\\t output1} or {\\t output2}.\nThe probability for each of the outputs can be shifted with the\nparameter {\\t distribution}. It determines the probability of\na gate signal to go to {\\t output1}.\n\nExample:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[bernoulli]}[bernoulli]\n\\immediate\\write\\patchexamples{    input        = G1}    input        = G1\n\\immediate\\write\\patchexamples{    distribution = P1.1}    distribution = P1.1\n\\immediate\\write\\patchexamples{    output1      = G2}    output1      = G2\n\\immediate\\write\\patchexamples{    output2      = G4}    output2      = G4\n\\end{droidini}\n\nNote: each time a positive trigger edge is seen at {\\t input}\na new random decision is made for which output to use.\nFrom now on that chosen output gets an exact copy of the input\nsignal -- even if it is not a simple trigger signal but something\nmore complex like an envelope. The other output will send 0~V.", "inputs": [{"name": "input", "type": "gate", "default": "0", "description": "Send gate or trigger signals here.\n", "essential": 2, "ramsize": 16}, {"name": "distribution", "type": "bipolar", "default": "0.5", "description": "This controls the probability of a gate to be forwarded to\n{\\t output1}. A value of {\\t 0.5} means 50\\%.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "output1", "type": "gate", "default": null, "description": "Gates from input are forwarded here if the random decision was\nin favour of output 1.\n", "essential": 2, "ramsize": 4}, {"name": "output2", "type": "gate", "default": null, "description": "Gates from input are forwarded here if the random decision was\nin favour of output 2.\n", "essential": 1, "ramsize": 4}], "presets": 0, "manual": 100, "ramsize": 32}, "burst": {"category": "clock", "title": " Generate burst of pulses", "description": "This circuit produces -- when triggered -- a number of pulses.\nIt can be used for solving various musical or technical tasks.\nLook at this example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    hz       = 10}    hz       = 10\n\\immediate\\write\\patchexamples{    count    = 5}    count    = 5\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\nWhen a trigger arrives at {\\t I1}, the output {\\t O1} will\nsend five triggers in a row, with a distance of 0.1 seconds (thus\n10~Hz). The gate length is fixed to half of the cycle (thus here 0.05 seconds).\nThis means that the pulse width is 50\\% -- or in other words -- the faster the\nburst the shorter the outgoing triggers.\n\nNote: When a new trigger arrives while the current burst is still ongoing,\nit will not be finished but restarted from the beginning immediately.\n\nIf you want the bursts to be synchronized to a musical clock, you\ncan use the {\\t taptempo} input (here {\\t I2}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I2}    taptempo = I2\n\\immediate\\write\\patchexamples{    count    = 4}    count    = 4\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\nSimilar to the circuit \\circuit{lfo}, there is a third input for selecting\nthe speed: {\\t rate}. This works on a 1~V/Oct base, so here is an example\nfor outputting the bursts at half of the clock speed (-1~V pitches down one\noctave, which is the same as half of the speed):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I2}    taptempo = I2\n\\immediate\\write\\patchexamples{    rate     = @1V}    rate     = -1V\n\\immediate\\write\\patchexamples{    count    = 4}    count    = 4\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\n\n{\\t burst} can also be used for very fast switching through things like presets in\nexternal gear. Here you might want fast updates. Simply set a very high frequency.\nBurst makes sure that the actual output rate is limited to the maximum the DROID\nhardware can do, so not one single burst can get lost. Also you might want to use\nthe {\\t skip} input, which skips a certain number of ticks before starting. This\ncan be used to send out a reset signal to some input and {\\it after that} sending\na couple of {\\t skip forward} triggers to some other input:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    hz = 5000}    hz = 5000\n\\immediate\\write\\patchexamples{    skip = 5}    skip = 5\n\\immediate\\write\\patchexamples{    count = 3}    count = 3\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}\n\nAnother very simple yet useful application of {\\t burst} is converting a gate signal\ninto a short trigger. That way you can for example convert a {\\it running} state\nfrom MIDI into a reset trigger. Since {\\t count} defaults to {\\t 1}, you don't\nneed any parameters except the input and output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    trigger = _MIDI_RUNNING}    trigger = _MIDI_RUNNING\n\\immediate\\write\\patchexamples{    output = _RESET}    output = _RESET\n\\end{droidini}\n\nIn this example the trigger is emitted when the running state goes from 0 to\n1.\n\n\\subsubsection*{Simple clocked trigger delay}\n\nAnother application of {\\t burst} is a clocked trigger delay. Consider the following\npatch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[burst]}[burst]\n\\immediate\\write\\patchexamples{    taptempo = I1}    taptempo = I1\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    skip = 7}    skip = 7\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nA trigger at {\\t I2} will be delayed by 7 clock cycles.\n\n{\\bf Note:} This simple trigger delay has no memory of more than one\ntrigger. Any ongoing trigger currently being delayed is overridden and\nforgotten as soon as the next trigger arrives. If that is what you want,\nfine. If you are looking for a more complex trigger delay, you find one\nin the circuit \\circuit{triggerdelay} circuit.\n\n\\pagebreak", "inputs": [{"name": "rate", "type": "cv", "default": "0", "description": "Frequency control: The default frequency of the burst rate is 1~Hz\n(one trigger per second or 60~BPM if you like). Each volt doubles\nthe frequency. So an input of 1~V (a number of {\\t 0.1}) speeds up\nto two triggers per second (120~BPM), 2~V ({\\t 0.2}) creates triggers\nat 4~Hz (240~BPM) and so on. On the other hand negative voltages\nreduce the speed, so -1~V ({\\t -0.1}) will give 0.5~Hz (30~BPM)\nand so on.\n", "essential": 1, "ramsize": 12}, {"name": "taptempo", "type": "trigger", "default": null, "description": "Feed a reference clock here and the burst will run at the speed of\nthat clock -- albeit optionally modified by {\\t rate}.\nPlease see page \\pageref{taptempo} for details on using\n{\\t taptempo} inputs.\n", "essential": 1, "ramsize": 30}, {"name": "hz", "type": "cv", "default": "1", "description": "Set the frequency in Hz directly by setting a number here. This\nis exclusive to {\\t taptempo}, but will work in combination with\n{\\t rate}.\n", "essential": 0, "ramsize": 12}, {"name": "trigger", "type": "trigger", "default": null, "description": "Send a trigger here in order to start the bursts\n", "essential": 2, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "Send a trigger here to immediately stop any ongoing burst.\n", "essential": 0, "ramsize": 16}, {"name": "count", "type": "integer", "default": "1", "description": "Number of triggers to send in one burst.\n", "essential": 2, "ramsize": 12}, {"name": "skip", "type": "integer", "default": "0", "description": "Number of time slots to wait before starting with the burst.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "trigger", "default": null, "description": "The triggers are output here.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 101, "ramsize": 40}, "button": {"category": "ui", "title": " Does all sorts of useful things with buttons", "description": "This is a utility circuit for efficiently working with the buttons\nof your controllers. It can implement toggle buttons (that do on/off)\nor even have three or four states. It can detect long presses and\ndouble clicks and also helps you to overload one button with several\nswitchable functions. Note: If you just need a plain momentary button\nwithout any of these or other nifty features, you can use the\nregister {\\t B1.1}, {\\t B1.2}, etc. directly and do not need this circuit.\n\nNote: don't forget to declare your controllers at the top\nof your patch with lines like {\\t [p2b8]} or {\\t [b32]}. In the\nbelow examples I've omitted these declarations for sake of simplicity.\n\n\n\\subsubsection*{Toggle buttons}\n\nThe most common use of {\\t button} is to implement a toggle button.\nThat's a button that changes from on to off and back at each press\nof the button. The current state of the button will persist on your\nSD card so you don't lose your state if you switch off your rack.\n\nTypically you will wire the {\\t button} input to one of your controller's\nbuttons like {\\t B1.1} and {\\t led} to the LED in that button ({\\t L1.1}). LED\nwill then always visualise the current state of the button. As a side effect\nthe LED register {\\t L1.1} will store the button state as a value {\\t 0}\nor {\\t 1} and hence can be used by some other circuit as an input.\n\nHere is a typical example. The button is being used for enabling\nthe loop in a CV looper:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop        = L1.4}    loop        = L1.4\n\\end{droidini}\n\nIf you do not want the state of the button to be persisted on the SD card,\nuse {\\t dontsave = 1}. This make sense for the CV looper since the loop is\napparently empty anyway when your \\droid starts.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.4}    button     = B1.4\n\\immediate\\write\\patchexamples{    led        = L1.4}    led        = L1.4\n\\immediate\\write\\patchexamples{    dontsave   = 1}    dontsave   = 1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop       = L1.4}    loop       = L1.4\n\\end{droidini}\n\n\nUsually the button switches between the two values {\\t 0} and {\\t\n1}. Sometimes, however, you need different values. For this purpose there\nare the two inputs {\\t offvalue} and {\\t onvalue}. They set two alternative\nvalues for the \"off\" and \"on\" states. And the output {\\t output} outputs the\nselected value ({\\t led} still goes to 0 and 1). Here is an example for a\ntoggle button that switches a clock divider between {\\t 2} and {\\t 4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{    offvalue    = 2}    offvalue    = 2\n\\immediate\\write\\patchexamples{    onvalue     = 4}    onvalue     = 4\n\\immediate\\write\\patchexamples{    output      = _CLOCK_DIV}    output      = _CLOCK_DIV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    input       = G1 # external clock}    input       = G1 # external clock\n\\immediate\\write\\patchexamples{    output      = G2}    output      = G2\n\\immediate\\write\\patchexamples{    divide      = _CLOCK_DIV}    divide      = _CLOCK_DIV\n\\end{droidini}\n\nOf course {\\t offvalue} and {\\t onvalue} are CV controllable. How can this\nmake sense? Well -- as they can take variable inputs you can use a button\nfor directly switching between two different input CV signals. The following\nexample will use a button to switch between two different wave forms of an\nLFO (see page \\pageref{lfo}). The button {\\t B3.1} switches between sawtooth\nand sine and sends the result to {\\t O1}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    offvalue    = _SAWTOOTH}    offvalue    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    onvalue     = _SINE}    onvalue     = _SINE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\n\n\\subsubsection*{Buttons with three or four states}\n\nSometime you might want more than just two values. {\\t button} supports\nswitching between up to four values. Use the {\\t states} input and set\nit to {\\t 3} or {\\t 4}. In the following examples {\\t output} will go\nthrough the values {\\t 0}, {\\t 1}, {\\t 2} and {\\t 3}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    states = 4}    states = 4\n\\immediate\\write\\patchexamples{    output = _SOMETHING}    output = _SOMETHING\n\\end{droidini}\n\nIf you don't like the default values, use the inputs {\\t value1} through {\\t\nvalue4} for setting the four values. In fact {\\t offvalue} is the same as\n{\\t value1} and {\\t onvalue} as {\\t value2}. If you specify {\\t value3}\nor {\\t value3}, {\\t states} is automatically set accordingly and you\ncan simply omit it .The following example switches\nbetween {\\it four} different wave forms of an LFO:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{    square      = _SQUARE}    square      = _SQUARE\n\\immediate\\write\\patchexamples{    triangle    = _TRIANGLE}    triangle    = _TRIANGLE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    value1      = _SAWTOOTH}    value1      = _SAWTOOTH\n\\immediate\\write\\patchexamples{    value2      = _SINE}    value2      = _SINE\n\\immediate\\write\\patchexamples{    value3      = _SQUARE}    value3      = _SQUARE\n\\immediate\\write\\patchexamples{    value4      = _TRIANGLE}    value4      = _TRIANGLE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nIf you have three or four states, the LED will use different brightness\nlevels for indicating the current state.\n\n\n\\subsubsection*{Momentary buttons}\n\nIf you just need a momentary button (one that just lights up\nwhile you hold it down), strictly spoken you don't need a {\\t button}\ncircuit. You can directly use the {\\t B} register, like in this example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    nextpattern = B1.1}    nextpattern = B1.1\n\\end{droidini}\n\nSometimes, however, you may want to make use of some of the features\nof the {\\t button} circuit without creating a toggle button.\nThis is easily done by setting {\\t states = 1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    states = 1}    states = 1\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    nextpattern = L1.1}    nextpattern = L1.1\n\\end{droidini}\n\nNow you are ready for adding some fun stuff like overlaying one button\nwith multiple functions (see below) or using the {\\t longpress} output.\n\n\\subsubsection*{Long and short presses}\n\nWhen creating patches, you will constantly run out of buttons. One\nway to increase the effective number of buttons is to map two different\nactions on a button depending on wether it is pressed long or short.\nFor this purpose there is the {\\t longpress} output. Consider the\nfollowing example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button    = B1.1}    button    = B1.1\n\\immediate\\write\\patchexamples{    led       = L1.1}    led       = L1.1\n\\immediate\\write\\patchexamples{    output    = _SOME_STATE}    output    = _SOME_STATE\n\\immediate\\write\\patchexamples{    longpress = _LONG}    longpress = _LONG\n\\end{droidini}\n\nA button press with a duration below 1.5 secs will toggle the LED {\\t L1.1}\nas usual. If you hold the button longer than 1.5 seconds, the output {\\t longpress}\nwill get high until you release the button. And the state of {\\t L1.1} does\n{\\t not} toggle.\n\nIf you don't want the button to toggle any state, but just distinguish\nbetween long and short presses, you can use the {\\t shortpress} output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    longpress  = _LONG}    longpress  = _LONG\n\\immediate\\write\\patchexamples{    shortpress = _SHORT}    shortpress = _SHORT\n\\end{droidini}\n\n{\\it Note}: The output {\\t led} is not used here since we are just interested\nin the presses and you cannot really see the LED anyway while you finger is on\nthe button. If you want the LED anyway, set {\\t states = 1} so it won't toggle:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    led        = L1.1}    led        = L1.1\n\\immediate\\write\\patchexamples{    states     = 1}    states     = 1\n\\immediate\\write\\patchexamples{    longpress  = _LONG}    longpress  = _LONG\n\\immediate\\write\\patchexamples{    shortpress = _SHORT}    shortpress = _SHORT\n\\end{droidini}\n\nUsing {\\t output} does not do the same as {\\t shortpress}: it always is high\nas long as your finger is on the button (and the button is selected).\n\n\\subsubsection*{Sharing buttons}\n\nYou can never have too many buttons! It's more likely that you have too\nfew. So you want to overlay one or more buttons with multiple functions.\n\nThey key to this is the {\\t select} input of the {\\t button} circuit.\nIf you patch this, the circuit will only interact with the actual\nbutton and LED if {\\t select} is active (e.g. set to {\\t 1}). Otherwise\nit will continue to output its current value to {\\t output} and leave\nthe control of the button and the LED to some other circuit.\n\nThe following example uses the button {\\t B1.1}, (which is not overloaded!) for\nswitching between two \"layers\" or \"banks\" of buttons. And in each bank\nthe button has a different meaning. Note how I use the {\\t negated} output\nof the button. That is {\\t 0} if the normal output is {\\t 1} and vice\nversa.\n\nIn order to keep things short, the bank just consists of the single button\n{\\t B1.2}. Of course in practice this wouldn't make sense since you wouldn't\nactually save a button, but you get the idea...\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{    output = _BANK1}    output = _BANK1\n\\immediate\\write\\patchexamples{    negated = _BANK2}    negated = _BANK2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    select = _BANK1}    select = _BANK1\n\\immediate\\write\\patchexamples{    button = B3.1}    button = B3.1\n\\immediate\\write\\patchexamples{    led = L3.1}    led = L3.1\n\\immediate\\write\\patchexamples{    output = _VIRTUAL_BUTTON_1}    output = _VIRTUAL_BUTTON_1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    select = _BANK2}    select = _BANK2\n\\immediate\\write\\patchexamples{    button = B3.1}    button = B3.1\n\\immediate\\write\\patchexamples{    led = L3.1}    led = L3.1\n\\immediate\\write\\patchexamples{    output = _VIRTUAL_BUTTON_2}    output = _VIRTUAL_BUTTON_2\n\\end{droidini}\n\nNote: If you need more than two banks, consider switching with a {\\t buttongroup}\n(see page \\pageref{buttongroup}).\n\n\\clearpage", "inputs": [{"name": "button", "type": "gate", "default": null, "description": "The actual push button. Usually you want to wire this to {\\t B1.1},\n{\\t B1.2} and so on: to one of the push buttons of your\ncontrollers. Each time that input goes from low to high,\nthe state of the push button will toggle.\n", "essential": 2, "ramsize": 12}, {"name": "onvalue", "type": "cv", "default": "1", "description": "Value sent to {\\t output} when the push button is on. You can also\nuse a dynamic signal here. This is an alternative name for the\ninput {\\t value1}.\n", "essential": 1, "ramsize": 12}, {"name": "offvalue", "type": "cv", "default": "0", "description": "Value sent to {\\t output} when the push button is off. This\nis an alternative name for the input {\\t value2}.\n", "essential": 1, "ramsize": 12}, {"prefix": "value", "name": "value1 ... value4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "The up to four values to output at {\\t output} when the button\nis on the according state. {\\t value1} is the same as {\\t offvalue}\nand {\\t value2} is the same as {\\t onvalue}. The default values\nof these four inputs are {\\t 0}, {\\t 1}, {\\t 2} and {\\t 3}, so\nin many cases you don't need to specify them.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "doubleclickmode", "type": "gate", "default": "off", "description": "This input can enable a {\\it double click mode} when set to {\\t 1}.\nIn that mode the button only toggles it's constant state if you double\npress it in a short time. Otherwise it behaves like a momentary button,\nthat inverts the persisted state (which you toggle with the double click).\nNote: The double clock mode is only makes sense if the number of\nstates is 2.\n", "essential": 0, "ramsize": 12}, {"name": "longpresstime", "type": "cv", "default": "1.5", "description": "The number of seconds after which a button press is considered\nas a {\\it long press}.\n", "essential": 0, "ramsize": 12}, {"name": "states", "type": "integer", "default": "2", "description": "Number of states this button can have. The default value is {\\t 2},\nwhich creates a toggle button which changes between on and off at each\npress. A value of {\\t 1} creates a momentary button. Note: If you just\nneed a plain momentary button, you can directly use {\\t B1.1}, {\\t B1.2}\nand so on. You don't need an extra circuit. But if you want things like\noverloading (with {\\t select}) or the {\\t longpress} output, this does\nmake sense. The maximum number of states is 4. When the button has\n3 or 4 states, every press will switch to the next state and then\nback to the first state again.\n", "essential": 0, "ramsize": 12}, {"name": "startvalue", "type": "integer", "default": "0", "description": "State of the push button when you switch on your system or on a\ntrigger to {\\t clear}. If you have three\nstates, the start value needs to be {\\t 0}, {\\t 1} or {\\t 2}. With\nfour states, it can also be {\\t 3}.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "led", "type": "cv", "default": null, "description": "When the button state is {\\t on}, a value of {\\t 1.0} will be sent to that\noutput -- regardless of the values in {\\t onvalue}\nand {\\t offvalue}. If the number of states is 3 or 4 the output get's intermediate\nvalues so the attached LED will be dimmed into different brightness\nlevels. Usually you wire that output to a LED register, e.g.\nto {\\t L1.1}, {\\t L1.2} and so on.\n", "essential": 2, "ramsize": 4}, {"name": "output", "type": "cv", "default": null, "description": "This output will output the current button states. This is usually\n{\\t 0} for off and {\\t 1} for on. If {\\t states} is 3 or 4, the\nvalues {\\t 2} or {\\t 3} are output for the additional states.\nYou can modify all four values with the inputs {\\t offvalue}/{\\t value1},\n{\\t onvalue}/{\\t value2}, {\\t value3} and {\\t value4}. Note:\nif you haven't changed any of these inputs and {\\t states} is\nunchanged or 1 or 2, the {\\t led} output will output the same\nvalues.\n", "essential": 1, "ramsize": 4}, {"name": "inverted", "type": "cv", "default": null, "description": "The same as {\\t output}, but sends {\\t onvalue} when the\nbutton is off and {\\t offvalue} when the button is on.\nIf {\\t states} is 3 or 4, the order of the four output values will\nbe mirrored (probably a feature that is rarely of any use).\n", "essential": 0, "ramsize": 4}, {"name": "negated", "type": "gate", "default": null, "description": "Similar to {\\t inverted}, but always sends {\\t 1} when the button\nis off and {\\t 0} when the button is on -- independent of the values\nof {\\t onvalue} and {\\t offvalue}. When {\\t states} is 3 or 4,\nthis output will be {\\t 1} if the button is off and {\\t 0} in\nthe other three states.\n", "essential": 0, "ramsize": 4}, {"name": "longpress", "type": "gate", "default": null, "description": "Goes from {\\t 0} to {\\t 1}, when the button is pressed and hold\nfor at least 1.5 seconds. If this output is used, the effect of\ntoggling the button's state is delayed until the button is {\\it\nreleased}. When it's released after 1.5 secs, no toggling happens.\nThis will avoid double actions for long presses.\n", "essential": 0, "ramsize": 4}, {"name": "shortpress", "type": "trigger", "default": null, "description": "Emits a trigger, when the button is pressed, regardless of\nthe settings of {\\t states}. If at the same time {\\t longpress}\nis used (which is the whole point in this output), the trigger\nis delayed until the button is released and only sent, if it\nwas not a long press.\n", "essential": 0, "ramsize": 8}], "presets": 16, "manual": 103, "ramsize": 96}, "buttongroup": {"category": "ui", "title": " Connected buttons", "description": "This utility circuit combines a number of push buttons into a group that\nbehave as a unit. One classic operation is to form a group of ``radio\nbuttons''. This means that at any time just one of these buttons is on and\nall others are off.\n\nThe following example uses four buttons for selecting one of the voltages 0~V,\n1V, 2V and -1V. This voltage is then being sent to the output jack. This could\nbe used as an octave switch or the like.  The four buttons {\\t B2.1} ... {\\t B2.4}\nare grouped in a way that just one button is on and the others are off. The\nfour selectable voltages are assigned to one button each. The value of the\ncurrently active button is being sent to the output. The outputs {\\t output1}\n... {\\t output4} will be set to 1 if their corresponding button is active and\nare used for controlling the LEDs within the buttons.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1   = B2.1}    button1   = B2.1\n\\immediate\\write\\patchexamples{    button2   = B2.2}    button2   = B2.2\n\\immediate\\write\\patchexamples{    button3   = B2.3}    button3   = B2.3\n\\immediate\\write\\patchexamples{    button4   = B2.4}    button4   = B2.4\n\\immediate\\write\\patchexamples{    led1      = L2.1 # LED in button 2.1}    led1      = L2.1 # LED in button 2.1\n\\immediate\\write\\patchexamples{    led2      = L2.2}    led2      = L2.2\n\\immediate\\write\\patchexamples{    led3      = L2.3}    led3      = L2.3\n\\immediate\\write\\patchexamples{    led4      = L2.4}    led4      = L2.4\n\\immediate\\write\\patchexamples{    value1    = 0V}    value1    = 0V\n\\immediate\\write\\patchexamples{    value2    = 1V}    value2    = 1V\n\\immediate\\write\\patchexamples{    value3    = 2V}    value3    = 2V\n\\immediate\\write\\patchexamples{    value4    = @1V}    value4    = -1V\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\nIf you set {\\t maxactive} to a number greater than one, more than one button\ncan be active at the same time. If this is the case then the sum of the\nvalues of all active buttons will be sent to the output. Here is an example,\nwhere three buttons are being used for selecting a number between 0 and 7 by\nselecting any combination of the buttons ``1'', ``2'', and ``4''.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1   = B2.1}    button1   = B2.1\n\\immediate\\write\\patchexamples{    button2   = B2.2}    button2   = B2.2\n\\immediate\\write\\patchexamples{    button3   = B2.3}    button3   = B2.3\n\\immediate\\write\\patchexamples{    led1      = L2.1 # LED in button 2.1}    led1      = L2.1 # LED in button 2.1\n\\immediate\\write\\patchexamples{    led2      = L2.2}    led2      = L2.2\n\\immediate\\write\\patchexamples{    led3      = L2.3}    led3      = L2.3\n\\immediate\\write\\patchexamples{    value1    = 1}    value1    = 1\n\\immediate\\write\\patchexamples{    value2    = 2}    value2    = 2\n\\immediate\\write\\patchexamples{    value3    = 4}    value3    = 4\n\\immediate\\write\\patchexamples{    minactive = 0 # allow all buttons to be off}    minactive = 0 # allow all buttons to be off\n\\immediate\\write\\patchexamples{    maxactive = 3 # allow all buttons to be on}    maxactive = 3 # allow all buttons to be on\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\n\\subsubsection*{Overlaying buttons}\n\nWhen you make more complex \\droid patches, it's likely that you might run\nout of buttons. In such a situation you can {\\it overlay} buttons with multiple\nfunctions and use other buttons to switch between these layers.\n\nConsider the following example: We have one P2B8 controller. The buttons\n1 and 2 should switch between the layers {\\it root note} and {\\it scale}.\nWe do this with a simple button group (you could also use a {\\t button}\ncircuit and save one button, but for simplicity we allow us two here):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    led1    = L1.1}    led1    = L1.1\n\\immediate\\write\\patchexamples{    led2    = L1.2}    led2    = L1.2\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nThe remaining six buttons select either one of six possible root notes or\none of six possible scales (adhering to the scheme of the {\\t minifonion}\ncircuit, see page \\pageref{minifonion}). Please note how we have added a\n{\\t select} input at each of both circuits to make sure that at any given\ntime exactly one of the two groups is selected:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    select = L1.1 # be active only when L1.1 is active}    select = L1.1 # be active only when L1.1 is active\n\\immediate\\write\\patchexamples{    button1 = B1.3}    button1 = B1.3\n\\immediate\\write\\patchexamples{    button2 = B1.4}    button2 = B1.4\n\\immediate\\write\\patchexamples{    button3 = B1.5}    button3 = B1.5\n\\immediate\\write\\patchexamples{    button4 = B1.6}    button4 = B1.6\n\\immediate\\write\\patchexamples{    button5 = B1.7}    button5 = B1.7\n\\immediate\\write\\patchexamples{    button6 = B1.8}    button6 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.3}    led1 = L1.3\n\\immediate\\write\\patchexamples{    led2 = L1.4}    led2 = L1.4\n\\immediate\\write\\patchexamples{    led3 = L1.5}    led3 = L1.5\n\\immediate\\write\\patchexamples{    led4 = L1.6}    led4 = L1.6\n\\immediate\\write\\patchexamples{    led5 = L1.7}    led5 = L1.7\n\\immediate\\write\\patchexamples{    led6 = L1.8}    led6 = L1.8\n\\immediate\\write\\patchexamples{    value1 = 0  # C}    value1 = 0  # C\n\\immediate\\write\\patchexamples{    value2 = 2  # D}    value2 = 2  # D\n\\immediate\\write\\patchexamples{    value3 = 5  # F}    value3 = 5  # F\n\\immediate\\write\\patchexamples{    value4 = 7  # G}    value4 = 7  # G\n\\immediate\\write\\patchexamples{    value5 = 9  # A}    value5 = 9  # A\n\\immediate\\write\\patchexamples{    value6 = 10 # Bb}    value6 = 10 # Bb\n\\immediate\\write\\patchexamples{    output = _ROOT}    output = _ROOT\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    select = L1.2 # be active only when L1.2 is active}    select = L1.2 # be active only when L1.2 is active\n\\immediate\\write\\patchexamples{    button1 = B1.3}    button1 = B1.3\n\\immediate\\write\\patchexamples{    button2 = B1.4}    button2 = B1.4\n\\immediate\\write\\patchexamples{    button3 = B1.5}    button3 = B1.5\n\\immediate\\write\\patchexamples{    button4 = B1.6}    button4 = B1.6\n\\immediate\\write\\patchexamples{    button5 = B1.7}    button5 = B1.7\n\\immediate\\write\\patchexamples{    button6 = B1.8}    button6 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.3}    led1 = L1.3\n\\immediate\\write\\patchexamples{    led2 = L1.4}    led2 = L1.4\n\\immediate\\write\\patchexamples{    led3 = L1.5}    led3 = L1.5\n\\immediate\\write\\patchexamples{    led4 = L1.6}    led4 = L1.6\n\\immediate\\write\\patchexamples{    led5 = L1.7}    led5 = L1.7\n\\immediate\\write\\patchexamples{    led6 = L1.8}    led6 = L1.8\n\\immediate\\write\\patchexamples{    value1 = 1  # major}    value1 = 1  # major\n\\immediate\\write\\patchexamples{    value2 = 6  # dorian minor}    value2 = 6  # dorian minor\n\\immediate\\write\\patchexamples{    value3 = 7  # natural minor}    value3 = 7  # natural minor\n\\immediate\\write\\patchexamples{    value4 = 9  # phrygian minor}    value4 = 9  # phrygian minor\n\\immediate\\write\\patchexamples{    value5 = 10 # diminished scale}    value5 = 10 # diminished scale\n\\immediate\\write\\patchexamples{    value6 = 2  # mixolydian}    value6 = 2  # mixolydian\n\\immediate\\write\\patchexamples{    output = _DEGREE}    output = _DEGREE\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nHere you can patch {\\t \\_ROOT} and {\\t \\_SCALE} to some {\\t minifonion},\n{\\t arpeggio} or other circuit that works with scales.\n\nNow, with the top buttons you can switch between root and scale selection\nand with the remaining six buttons select either the root or the scale.", "inputs": [{"name": "minactive", "type": "integer", "default": "1", "description": "Minimum number of active buttons. If you set this to {\\t 2}, then\nit is guaranteed that at least 2 buttons are active. If you\nset this to {\\t 0}, then it is possible to switch off all buttons.\nThe {\\t output} will be set to {\\t 0.0} in that case.\n", "essential": 0, "ramsize": 12}, {"name": "maxactive", "type": "integer", "default": "1", "description": "Maximum number of active buttons. It is an error to set this to\n{\\t 0}, since this would make this circuit useless.\n", "essential": 0, "ramsize": 12}, {"name": "longpresstime", "type": "cv", "default": "1.5", "description": "The number of seconds after which a button press is considered\nas a {\\it long press}.\n", "essential": 0, "ramsize": 12}, {"prefix": "button", "name": "button1 ... button32", "count": 32, "start_at": 1, "type": "trigger", "default": null, "description": "\\nth1 ... \\nth{32} button of the group. Any positive trigger seen here will\ntoggle this button. And another button might go on or off in\norder to make sure that the number of active buttons is withing the\nallowed range.\n", "essential": 2, "essential_count": 4, "ramsize": 16}, {"prefix": "value", "name": "value1 ... value32", "count": 32, "start_at": 1, "type": "cv", "default": "unpatched", "description": "Value that will be sent to the output if the \\nth1 ...\n\\nth{32} button is active. These inputs default to {\\t 0} for\n{\\t value1}, {\\t 1} for {\\t value2} and so on and {\\t 31} for {\\t value32}.\n", "essential": 1, "essential_count": 4, "ramsize": 12}, {"name": "startbutton", "type": "integer", "default": "1", "description": "If you set this parameter to the number of a button, that\nbutton will be selected (and all other deselected) at the\nstart when no state is loaded or at a trigger to {\\t clear}.\nThis allows you to set useful default values for your button groups.\nNote: this only makes sense if {\\t maxactive} is not {\\t 0}.\nAlso it is not possible to select more than one button, even in\na group where {\\t maxactive} is greater than 1.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "led", "name": "led1 ... led32", "count": 32, "start_at": 1, "type": "gate", "default": null, "description": "This output will be {\\t on} / 1.0, whenever the \\nth1 ...\n\\nth{32} button is active\nand {\\t off} / 0.0 otherwise. Wire this to the LED in the button. If\nyou have wired {\\t select}, these LED outputs will do nothing\n(not even send 0) unless this circuit is selected.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "buttonoutput", "name": "buttonoutput1 ... buttonoutput32", "count": 32, "start_at": 1, "type": "cv", "default": null, "description": "These are individual outputs for every button in the group. They\noutput button's {\\t value} when it is active, otherwise {\\t 0}.\nIf {\\t value}X is not defined for {\\t button}X, the value\n{\\t 1} is output (not the button's number!).\n\nNote: in contrast to the {\\t led} output, these outputs are\nnot affected by {\\t select} but always functional.\n\nOne application of these outputs is to use a {\\t buttongroup}\nwith {\\t maxactive = } X and {\\t minactive = 0} as a cheap\nbunch of X toggle buttons in one single circuit and still\nuse {\\t select}.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "output", "type": "cv", "default": null, "description": "The sum of the values of all active buttons will be sent here.\nif no button is active, {\\t 0.0} is being output.\n", "essential": 1, "ramsize": 4}, {"name": "buttonpress", "type": "trigger", "default": null, "description": "Emits a trigger if any button is being pressed\n", "essential": 0, "ramsize": 8}, {"name": "longpress", "type": "trigger", "default": null, "description": "Emits a trigger, when any button is pressed for at least 1.5\nseconds. If this jack is used, {\\t buttonpress} will emit\na signal if the button in question is released before the 1.5\nseconds, not immediately. This way you trigger {\\it either}\nat {\\t buttonpress} or at {\\t longpress}, not at both.\n", "essential": 0, "ramsize": 8}, {"name": "selectionchanged", "type": "trigger", "default": null, "description": "Emits a trigger when the selection of the buttons has changed.\nThis is not quite the same as {\\t shortpress}, since a button\npress might not lead to a change. Also in multi button situations\n(e.g. {\\t maxactive = 4} where you have 7 buttons) the change\nis delayed up to 25~ms due to detection of bursts of quasi\nsimultanous presses.\n", "essential": 0, "ramsize": 8}], "presets": 16, "manual": 108, "ramsize": 432}, "calibrator": {"category": "pitch", "title": " VCO Calibrator", "description": "This circuit allows you to precisely compensate for decalibrated or otherwise\nimperfectly tracking VCOs -- which is probably a property of all existing\nanalog VCOs to some degree.  It does this by applying one specific adaptation\nvalue per individual octave. This way you can make even those VCO track well\nover 10 octaves, that would normally only do 2 or 3.\n\nThe calibration of the error compensation is done manually -- by you.\nAt first this may seem like a disadvantage. In practice, however, this is\nmuch easier and more accurate than the way some ``autotune'' modules do it.\nThose modules have an additional input for ``listening'' to a waveform output\nof the oscillator and measure and adjust the tracking at a button press.\n\nThe advantages of manual tuning are:\n\n\\begin{itemize}\n\n\\item You don't need an extra waveform output of your VCO.\n\n\\item You can calibrate sound sources with complex wave forms, whose pitch\nis are hard to grab by autotune devices.\n\n\\item You can change the correction at any time during a live performance without\nyour audience noticing.\n\n\\item It's possible to make one VCO follow the (imperfect) tracking of a second\none, in order to create perfect FM sounds while just one VCO\nneeds to be adapted.\n\n\\item It's also possible to fix the tracking of unprecise pitch CV {\\it\ngenerators}, such as sequencers, quantizers or MIDI interfaces.\n\n\\end{itemize}\n\nThe calibrator circuit happily profits from the \\droid's highly\nprecise, linear and low-jitter ADCs and DACs. And using eight such\ncircuits one \\droid could fix the tuning of up to eight VCOs.\n\n\\subsubsection*{How to use}\n\nHere is a typical patch for the use of the calibrator:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input     = I1}    input     = I1\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    nudgeup   = B1.1}    nudgeup   = B1.1\n\\immediate\\write\\patchexamples{    nudgedown = B1.3}    nudgedown = B1.3\n\\immediate\\write\\patchexamples{    ledup     = L1.1}    ledup     = L1.1\n\\immediate\\write\\patchexamples{    leddown   = L1.3}    leddown   = L1.3\n\\end{droidini}\n\nThe original pitch information from the sequencer, quantizer, MIDI converter\nor whatever comes into {\\t I1}. The adapted pitch goes to {\\t O1} and\nfrom there to the V/Oct input of your VCO. Of course the pitch information\ncould also come from some internal circuit like the {\\t minifonion} (page\n\\pageref{minifonion}).  In that case {\\t input} is connected to an internal patch cable\ncoming from that circuit.\n\nNow with the two buttons {\\t B1.1} and {\\t B1.3} you can adjust the tuning up\nand down at any time while playing. Each button press just very slightly shifts\nthe pitch up or down. The adjustment is only done for the octave that's\ncurrently playing. {\\t calibrator} saves one calibration value for each octave\nfrom 0 to 8 and also one for the pitches below 0~V and those above 8~V. Your\ntuning profile is automatically saved to the memory card.\n\nPressing both buttons at the same time resets the calibration of the current\noctave.\n\nFor a good result I suggest either using a precise tuner or playing the voice\nat the same time as a reference voice and try to minimize the audible beatings.\n\nAs second way of using the VCO calibrator is specifying a tuning adjustment for\neach octave by a fixed number (or a potentiometer if you can afford). This is\ndone with the inputs {\\t tune0} ... {\\t tune8} and {\\t tunelowtail} and {\\t\ntunehightail}.A value of 1.0 means an upwards tuning of one semitone (100 cents)\n{\\it per octave}, and -1.0 likewise downwards.\n\n\\subsubsection*{Persistence}\n\nAs always, the internal state of the {\\t calibrator} circuit is automatically\nsaved to your SD card and loaded when your \\droid starts.\n\nBut what if you are using several calibrators, each for a different (and\ndifferently tracking) VCO? How do you know which of the saved calibration\nstates is applied to which VCO?\n\nThe answer to this is: all calibrators in your patch are enumerated starting\nfrom 1. For each of them there is one configuration saved to the SD card,\nbased on that number. So when you modify the calibration of the third {\\t\ncalibrator} circuit in your patch, the modified configuration will be saved\nas belonging to calibrator number 3.\n\nSo if you make sure that each VCO is always handled by the same {\\t calibrator}\ncircuit you will always get the right configuration.\n\nIf you for example remove the first calibrator from your patch, the second\none will become the new first one and load its calibration state when you\nload the new patch. If you don't want that to happen, simply keep the calibrator\nin the patch, even if you don't need it anymore. It is sufficient to keep\njust the line {\\t [calibrator]} without any further jack specifications.\n\n\\clearpage", "inputs": [{"name": "input", "type": "voltperoctave", "default": "0", "description": "Patch your V/Oct pitch input here.\n", "essential": 2, "ramsize": 12}, {"name": "nudgeup", "type": "trigger", "default": null, "description": "A trigger here (most likely a button press) will modify the tuning of\nthe currently played note (as read by {\\t input}) {\\it upwards} by\none cent (or by {\\t nudgeamount} if that is used.\n", "essential": 2, "ramsize": 16}, {"name": "nudgedown", "type": "trigger", "default": null, "description": "A trigger here will modify the tuning of\nthe currently played note down.\n", "essential": 2, "ramsize": 16}, {"name": "nudgeamount", "type": "cv", "default": "0.01", "description": "Changes the amount each button press detunes. A value of one would mean\none semitone, so the default value of 0.01 corresponds to one cent ($\\frac{1}{100})$\nof a semitone.\n", "essential": 0, "ramsize": 12}, {"prefix": "tune", "name": "tune0 ... tune8", "count": 9, "start_at": 0, "type": "cv", "default": "0", "description": "Explicit tuning of the octaves 0 through 8 -- if you do not want\nto nudge manually. {\\t tune0} sets the tuning for the input\npitch of 0~V, {\\t tune1} for 1~V and so on. A value of 1 means a tune adjustment\nof one semitone -- which is 100 cent. The maximum detuning is $\\pm$ 1~Octave (\nat a value of $\\pm 12$).\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "tunelowtail", "type": "cv", "default": "0", "description": "Tuning adaption for the negative voltage range.\nA value of 1 means an upwards tuning of one semitone\n{\\it per octave}, -1 likewise downwards.\n", "essential": 0, "ramsize": 12}, {"name": "tunehightail", "type": "cv", "default": "0", "description": "Tuning adaption for voltages $>$ 8~V. A value of 1 means\nan upwards tuning of one semitone {\\it per octave}, -1 likewise\ndownwards.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "voltperoctave", "default": null, "description": "The calibrated pitch goes out here.\n", "essential": 2, "ramsize": 4}, {"name": "ledup", "type": "fraction", "default": null, "description": "When {\\t nudgeup} is mapped to a button (which is most likely),\nmap this output to the according LED and it will indicate whenever\nit's currently adjusting the output pitch upwards.\n", "essential": 1, "ramsize": 4}, {"name": "leddown", "type": "fraction", "default": null, "description": "This is the LED for {\\t nudgedown}, which indicates downwards\nadjustment.\n", "essential": 1, "ramsize": 4}], "presets": 4, "manual": 111, "ramsize": 216}, "chord": {"category": "pitch", "title": " Chord generator", "description": "This circuit creates the pitch information for up to four voices of a musical\nchord. This means that you can attach the Volts per octave inputs of up to\nfour synth voices and they will play a nice musical chord. Hereby you have\nthe flexibility of building your chord out of any of the seven notes of\na selected scale. So you are not limited to root, \\nth3, \\nth5 and \\nth7.\nThe algorithm is similar to that in the Sinfonion but has an adapted mode\nfor three voiced chords in addition.\n\n\\subsubsection*{Minimal example}\n\nHere is the most simple (and probably useless) example: it will play a\nC major 7 chord, i.e. output the respective pitch CVs for the notes C, E,\nG and B at the outputs {\\t O1}, {\\t O2}, {\\t O3} and {\\t O4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\nOutput {\\t O1} will be at 0~V, representing a C. Or course, if you\njust have three voices, don't use {\\t output4} and you will get\na C major triad.\n\n\\subsubsection*{Selecting root and scale}\n\nMost likely you do not want to play in C major all the time (or even never!),\nso you can select the root note and the scale with the inputs {\\t root}\nand {\\t degree}. Setting {\\t root} to {\\t 2} and {\\t degree} to {\\t 7},\nfor example, will select D natural minor:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\nBoth {\\t root} and {\\t degree} range from {\\t 0} to {\\t 11}. Please refer\nto the description of {\\t minifonion} (see page \\pageref{minifonion}) for\na complete list of all available scales. It has the same logic for {\\t root}\nand {\\t degree} and is thus compatible with {\\t chord}.\n\nBut why the heck is that input named {\\t degree}?? Well, it's a jargon from\nthe Sinfonion and does make sense there in some contexts. Please have a look\ninto the manual of the Sinfonion if you are interested!\n\n\\subsubsection*{Selecting the pitch of the notes}\n\nPer default all outputs are in the first octave, i.e. in the range 0~V ... 1~V.\nPer convention this is very low and probably sounds ugly. With the {\\t pitch}\ninput you can set the {\\it minimum} pitch of the lowest output chord note. In the\nnext example this is read from {\\t I1}. So you could, for example, patch a sequencer\nhere and have the chord outputs play a kind of four voiced melody:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\n\nThe {\\t spread} parameter controls the {\\t maximum} pitch of the highest\noutput chord note. It is always relative to the pitch of the {\\it lowest}\nnote {\\it plus one octave}. So if {\\t spread} is 1.5~V (or 0.15), for example,\nthe maximum allowed distance between the lowest and the highest chord note\nis 2.5 octaves. As lowest note the chord generator places the chord note\nthat is nearest above the {\\t pitch} input. As highest note\nit places the one nearest to upper bound of the allowed range and\nthe remaining notes are distributed in between with the most equal spacing\npossible.\n\n\\subsubsection*{Selecting the chord notes}\n\nWhat makes the Sinfonion and also the harmonic circuits in the \\droid\nstand apart from other modules is the flexibility of note selection.\nSo e.g. in C major, you are not limited to playing the chord C/E/G/B.\nIn fact you can choose {\\it any} subset from the currently selected scale.\n\nFor this there are seven inputs {\\t select1}, {\\t select3}, ...\n{\\t select13} that select the notes of the current scale and\nanother five inputs {\\t selectfill1} ... {\\t selectfill5} that\nselect the notes not in the current scale.\nThese 12 inputs are binary inputs that expect either {\\t 0} or\none {\\t 1}. Each of them selects one of the seven intervals of the\nscale for being part of the chord. Here is a table of all these\ninputs and the notes they would select in a C major or C minor scale:\n\n{\\footnotesize\n\\begin{tabular}{|l|l|c|c|c|}\\hline\nInput & interval & step & C$^{maj}$ & C$^{min}$ \\\\\n{\\t select1}  & root               & {\\t I}   & C & C \\\\\n{\\t select3}  & \\nth{3}            & {\\t III} & E & E\\flat \\\\\n{\\t select5}  & \\nth{5}            & {\\t V}   & G & G \\\\\n{\\t select7}  & \\nth{7}            & {\\t VII} & B & B\\flat \\\\\n{\\t select9}  & \\nth{9} = \\nth{2}  & {\\t II}  & D & D \\\\\n{\\t select11} & \\nth{11} = \\nth{4} & {\\t IV}  & F & F \\\\\n{\\t select13} & \\nth{13} = \\nth{6} & {\\t VI}  & A & A\\flat \\\\\n\\hline\n\\end{tabular}}\n\nOne typical way to select these notes is with seven toggle buttons,\nwhich is then much like the Sinfonion does it. Assign the output\nof each of the seven buttons to one of these functions:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led = L1.2}    led = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led = L1.3}    led = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led = L1.4}    led = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.5}    button = B1.5\n\\immediate\\write\\patchexamples{    led = L1.5}    led = L1.5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.6}    button = B1.6\n\\immediate\\write\\patchexamples{    led = L1.6}    led = L1.6\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.7}    button = B1.7\n\\immediate\\write\\patchexamples{    led = L1.7}    led = L1.7\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    select1 = L1.1}    select1 = L1.1\n\\immediate\\write\\patchexamples{    select3 = L1.2}    select3 = L1.2\n\\immediate\\write\\patchexamples{    select5 = L1.3}    select5 = L1.3\n\\immediate\\write\\patchexamples{    select7 = L1.4}    select7 = L1.4\n\\immediate\\write\\patchexamples{    select9 = L1.5}    select9 = L1.5\n\\immediate\\write\\patchexamples{    select11 = L1.6}    select11 = L1.6\n\\immediate\\write\\patchexamples{    select13 = L1.7}    select13 = L1.7\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\nNow you can use the buttons to change the chord notes on the fly.\nOf course, however, you also can use other signals for the selection.\nMaybe random gates, slowly running LFOs, a sequencer, whatever you like!\n\nBut what happens, if you do {\\bf not} select exactly four notes?\n\n\\begin{itemize}\n\\item If you don't select {\\it any} note (or do not patch the {\\t select}-inputs\nat all), all scale notes are selected.\n\\item If you select just {\\it one} note, all four outputs will play that same note.\n\\item If you select {\\it two} notes, {\\t output1} and {\\t output3} will play\nthe first note and {\\t output2} and {\\t output4} the second one.\n\\item If you select three notes, {\\t output4}  will play the same as {\\t output1}.\n\\item If you select five, six or seven notes, just the first four notes will be used.\n\\end{itemize}\n\nIf some of the notes are doubled and you use a large enough {\\t spread},\nthey will be placed at different octaves.\n\nBy the way: It's of course no problem to just use three or even just two of\nthe outputs, if you don't need or have a total of four voices.\n\n\\subsubsection*{Chord inversion}\n\nThe chord generator lets you nail down the chord structure to a certain\n{\\it inversion}. If you set {\\t inversion} to {\\t 1}, the root note (or,\nto be more precise,\nthe first selected note) will be placed as the lowest note. Similarly\nthe inversions {\\t 2}, {\\t 3} and {\\t 4} will make the respective other\nselected notes the lowest note.\n\nSetting {\\t inversion} to {\\t 0} (which is the default) will allow any note\nto be the lowest. This allows the chord to be closest to the {\\t pitch}\ninput.\n\n\\subsubsection*{Triggered mode}\n\nThe {\\t trigger} input is essentially a sample \\& hold for the {\\it outputs}.\nSo as soon as you patch that input, all outputs are frozen until the next\ntrigger.\n\n\\subsubsection*{Chords with three voices}\n\nThe chord generation circuit can also create chords with just three\noutput voices. Simply omit the output {\\t output4}. When it is not\nconnected, the ``three voice mode'' is activated:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[chord]}[chord]\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    root    = 2}    root    = 2\n\\immediate\\write\\patchexamples{    degree  = 7}    degree  = 7\n\\end{droidini}\n\nAll parameters work as expected but there are some important adaptions.\nThis is {\\it not} the same as using the four voiced mode and just look\nat the first three outputs. For example:\n\n\\begin{itemize}\n\\item The spreading uses a simplified algorithm with just a bottom, middle and top note.\n\\item If just three intervals are selected, you don't get a duplication of\nthe first note on {\\t output2}, as you would otherwise.\n\\end{itemize}\n\n\\subsubsection*{Chords with two voices}\n\nEven if just two outputs are connected, you can still make use of this circuit.\nNow just the first two {\\t select...} inputs are taken into account. But things\nlike inversion and spreading works nevertheless.", "inputs": [{"name": "pitch", "type": "voltperoctave", "default": "0", "description": "This sets the minimum pitch of the lowest note of the chord.\n", "essential": 1, "ramsize": 12}, {"name": "spread", "type": "voltperoctave", "default": "0", "description": "Selects the range between the lowest and highest note of the\nchord measured in 1V/oct, while a spread of 0 means that all chord\nnotes are within {\\it one} octave, a spread of 1~V means that\nthe notes are spread out over {\\it two} octaves and so on.\n", "essential": 1, "ramsize": 12}, {"name": "inversion", "type": "integer", "default": "0", "description": "Selects the inversion of the chord. {\\t 1} means that the\nroot note should be the lowest note, {\\t 2} will make the second\nselected note the lowest note, {\\t 3} the \\nth3 and {\\t 4} the\n\\nth4. The default, however, is {\\t 0} and doesn't fix the inversion.\nRather that inversion is chosen that creates the chord closest\nto the input pitch.\n", "essential": 1, "ramsize": 12}, {"name": "trigger", "type": "trigger", "default": null, "description": "This jack is optional. If you patch it, the Chord generator just\nreads a new input pitch when it receives a trigger.\n", "essential": 0, "ramsize": 16}, {"name": "root", "type": "integer", "default": "0", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{C}\n\\jacktablerow{1}{C\\sharp}\n\\jacktablerow{2}{D}\n\\jacktablerow{3}{D\\sharp}\n\\jacktablerow{4}{E}\n\\jacktablerow{5}{F}\n\\jacktablerow{6}{F\\sharp}\n\\jacktablerow{7}{G}\n\\jacktablerow{8}{G\\sharp}\n\\jacktablerow{9}{A}\n\\jacktablerow{10}{A\\sharp}\n\\jacktablerow{11}{B}\n\\jacktablerow{12}{C}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "degree", "type": "integer", "default": "0", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{lyd -- Lydian major scale (it has a $\\sharp 4$)}\n\\jacktablerow{1}{maj -- Normal major scale (ionian)}\n\\jacktablerow{2}{X$^7$ -- Mixolydian (dominant seven chords)}\n\\jacktablerow{3}{sus -- mixolydian with \\nth3/\\nth4 swapped}\n\\jacktablerow{4}{alt -- Altered scale}\n\\jacktablerow{5}{hm$^5$ -- Harmonic minor scale from the \\nth5}\n\\jacktablerow{6}{dor -- Dorian minor (minor with $\\sharp 13$)}\n\\jacktablerow{7}{min -- Natural minor (aeolian)}\n\\jacktablerow{8}{hm -- Harmonic minor ($\\flat 6$ but $\\sharp 7$)}\n\\jacktablerow{9}{phr -- Phrygian minor scale (with $\\flat 9$)}\n\\jacktablerow{10}{dim -- Diminished scale (whole/half tone)}\n\\jacktablerow{11}{aug -- Augmented scale (just whole tones)}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "select1", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n", "essential": 1, "ramsize": 12}, {"name": "select3", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{3}.\n", "essential": 1, "ramsize": 12}, {"name": "select5", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{5}.\n", "essential": 1, "ramsize": 12}, {"name": "select7", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{7}.\n", "essential": 1, "ramsize": 12}, {"name": "select9", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n", "essential": 1, "ramsize": 12}, {"name": "select11", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n", "essential": 1, "ramsize": 12}, {"name": "select13", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n", "essential": 1, "ramsize": 12}, {"name": "selectfill1", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill2", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill3", "type": "gate", "default": "off", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill4", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill5", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output4", "count": 4, "start_at": 1, "type": "voltperoctave", "default": null, "description": "\\nth1 ... \\nth4 pitch output\n", "essential": 2, "essential_count": 4, "ramsize": 4}], "presets": 0, "manual": 115, "ramsize": 112}, "clocktool": {"category": "clock", "title": " Clock divider / multiplier / shifter", "description": "This circuit implements various clock modifications, such as a clock divider,\na clock multiplier, a tool for changing the length of an incoming gate signal\nand a clock time shift.\n\n\\subsubsection*{Multiply and divide}\n\nHere is an example of a simple clock divider that divides the incoming clock\nby 7 (i.e. for 7 incoming clocks one outgoing clock is being produced).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    divide   = 7}    divide   = 7\n\\end{droidini}\n\nThis example doubles the speed of the clock by inserting one additional clock tick\nright in the middle between two incoming ones:\nright in the middle between\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    multiply = 2}    multiply = 2\n\\end{droidini}\n\nBy using multiplication and division at the same time you can create rhythms like\n``two over three'':\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock    = I1 # patch a clock here}    clock    = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\immediate\\write\\patchexamples{    divide   = 3}    divide   = 3\n\\immediate\\write\\patchexamples{    multiply = 2}    multiply = 2\n\\end{droidini}\n\nPer default the outgoing clock has a duty cycle of 50\\%, which means that it\nis 50\\% of the time high and 50\\% of the time low -- basically a symmetrical\nsquare wave.  You can change this with the {\\t dutycycle} input, e.g. to 20\\%:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    dutycycle = 20% # same as 0.2}    dutycycle = 20% # same as 0.2\n\\end{droidini}\n\n\\subsubsection*{Time shifting the clock}\n\nThe input {\\t delay} can be used to delay the clock signal. It needs a steady\ninput clock to work. The possible range of {\\t delay} is -1.0 \\dots 1.0.\nA value of {\\t 1.0} is equivalent of delaying each clock by exactly one cycle\n-- which is pretty useless, since it results in the same output clock. But for\nexample a value of {\\t 0.1} will delay the clock by 10\\%. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    delay     = 0.1 # same as 10%}    delay     = 0.1 # same as 10%\n\\end{droidini}\n\nUsing a negative number will result in a clock that is always slightly\n{\\it before} the original clock. This example shifts the output clock 10\\%\n{\\it ahead} of the input clock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\immediate\\write\\patchexamples{    delay     = @0.1}    delay     = -0.1\n\\end{droidini}\n\nPlease note that this is {\\it not} a trigger delay, since it requires\na steady input clock. Otherwise funny and strange things can happen.\nAlso it should be obvious, that shifting a clock ahead needs knowledge\nwhen exactly the next input clock tick will happen.\n\nFeeding a trigger sequencer like the \\circuit{algoquencer} with a shifted\nclock allows you to fine tune the exact timing of that voice. You can easily\nmap the shift amount to a pot for tuning that live by ear:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock     = I1 # patch a clock here}    clock     = I1 # patch a clock here\n\\immediate\\write\\patchexamples{    output    = _SHIFTED_CLOCK}    output    = _SHIFTED_CLOCK\n\\immediate\\write\\patchexamples{    delay     = P1.1 * 0.2 @ 0.1 # limit to +/@ 10%}    delay     = P1.1 * 0.2 - 0.1 # limit to +/- 10%\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    clock     = _SHIFTED_CLOCK}    clock     = _SHIFTED_CLOCK\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nPlease also have a look at \\circuit{timing}. That can do a similar thing but\nis also able to shift the timing differently for each beat in a sequence of\nseveral beats.\n\nIf you combine {\\t delay} with {\\t divide} or {\\t multiply}, the delay is\napplied {\\it first}. This means that the amount of delay is in relation to\none {\\it input clock cycle}. The delayed input clock is then run through\nthe divider and multiplier. If you like it vice versa, split things up\ninto two {\\t clocktool} circuit, where the first one does the divide/multiply,\nfeed that output into the second one and do the delaying there.\n\n\\subsubsection*{Gate length}\n\nPer default the length of the output gate is 10~ms -- independently of the\nlength of the input gate. You can change the gate length either with the\njack {\\t gatelength} and specify a fixed number of seconds, or by using {\\t\ndutycycle}, which is a percentage of the {\\it output} clock rate. Please note:\nif your gate length exceeds the time until the next output gate, both will be\n\"joined\" and thus no new gate will be emitted.\n\nPlease note if you use {\\t dutycycle}: right at the start of the clock signal\nor after a greater speed change of the clock, {\\t clocktool} needs a short\ntime to learn the new clock speed and correctly adapt the new gate length. This\nmight lead to two merging gates, which in turn causes a missing gate output.\n\n\\pagebreak", "inputs": [{"name": "clock", "type": "trigger", "default": null, "description": "Patch a steady clock here for this circuit to be of any use\n", "essential": 2, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the internal counters. This is useful if you\nuse the clock divider and want to restart the internal counting from\n0, in order to align the clock divider with some external sequencers\nor the like\n", "essential": 1, "ramsize": 16}, {"name": "divide", "type": "integer", "default": "1", "description": "Number to divide the clock through. This will be rounded to the\nnearest integer number. Note: if you want to use an external CV then\nyou need to multiply that with some useful number, since otherwise\nyou will get a number between {\\t 0} and {\\t 1} which is not useful\nat all. Remember: 10 V translates to a number of {\\t 1}.\n", "essential": 1, "ramsize": 12}, {"name": "multiply", "type": "integer", "default": "1", "description": "Number to multiply the clock with. Same considerations hold as for {\\t divide}.\n", "essential": 1, "ramsize": 12}, {"name": "dutycycle", "type": "bipolar", "default": "unpatched", "description": "Output duty cycle of the clock -- which is essentially a square wave --\nin a range from {\\t 0.0} to {\\t 1.0} or {\\t 0\\%} to {\\t 100\\%}. If you\ndon't patch anything here, the length of the trigger output pulses will\nbe 10~ms (\\droid's standard trigger duration).\n", "essential": 0, "ramsize": 12}, {"name": "gatelength", "type": "cv", "default": "unpatched", "description": "This jack is alternative to {\\t dutycycle} and will override it\nif it is used.\tIt sets the length of each output pulse to a fixed\nvalue that is independent of the incoming clock. A value of {\\t 0.5}\n(a CV of 5 volts) translates into a gate length of 0.5 seconds.\n", "essential": 0, "ramsize": 12}, {"name": "delay", "type": "cv", "default": "0", "description": "This CV allows you to shift the {\\it input} clock beat around in time.\nA value of {\\t 0.1} will delay each beat by 10\\% of a clock cycle.\nA value of {\\t -0.1} is also allowed and shifts the beat 10\\%\n{\\it ahead}.\n\nFor an unmodulated delay {\\t -0.1} and {\\t 0.9} is just the same,\nbecause the output clock will have the same relation to the input\nclock. But if you {\\it modify} the delay from {\\t 0.0} to {\\t 0.9},\nthe next tick will be delayed by 90\\% of one cycle, where is a\nmodification from {\\t 0.0} to {\\t -0.1} will play the next tick\nby 10\\% earlier.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "output", "type": "gate", "default": null, "description": "Here comes the modified clock\n", "essential": 2, "ramsize": 8}, {"name": "inputpitch", "type": "cv", "default": null, "description": "Experimental output that outputs a representation of the input\nclock's pitch on a 1V/octave base, based on the reference of 60~BPM\n(1~Hz). This means that an input clock of 120~BPM will output 1V\n(a value of {\\t 0.1}), since 120~BPM it is one octave higher than\n60~BPM. If you feed that value to the {\\t rate} input of an LFO you\nget that running at exactly the same speed (not in the same phase,\nhowever).\n", "essential": 0, "ramsize": 4}, {"name": "outputpitch", "type": "cv", "default": null, "description": "Same for the modified output clock\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 121, "ramsize": 96}, "compare": {"category": "logic", "title": " Compare two values", "description": "This simple utility circuit allows you to make a decision by comparing\nan input value (at {\\t input}) against a reference value (at {\\t compare})\nand output one of three values depending on whether the input is less than,\ngreater than or equal to the reference.\n\nThe following simple example checks if the pot {\\t P1.1} is\nleft of the center (a value less than 0.5). If that is so,\nit outputs {\\t 1}, otherwise {\\t 0}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = 1}    ifless = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nYou can change the default output value of {\\t 0}\nwith the input {\\t else}. That specifies what happens\nif the condition is {\\it not} met. The following example\noutputs {\\t -1}, if {\\t P1.1} is greater or equal to 0.5.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = 1}    ifless = 1\n\\immediate\\write\\patchexamples{    else = @1}    else = -1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\n\\subsubsection*{Equality, analog unprecision}\n\nYou can also check if two values are {\\it equal}. This\nis done with {\\t ifequal}. Check this out:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = B1.1}    input = B1.1\n\\immediate\\write\\patchexamples{    compare = 1}    compare = 1\n\\immediate\\write\\patchexamples{    ifequal = 4}    ifequal = 4\n\\immediate\\write\\patchexamples{    else = 8}    else = 8\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow while you hold the button {\\t B1.1} this circuit will\noutput the value {\\t 4} and otherwise {\\t 8}.\n\nNote: equality can be tricky when it comes to values from {\\it analog}\nthings like inputs or potentiometers. They always undergo tiny random\nfluctiations. So the following example, that should compare the current\nvoltages of two inputs, will never really work:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    ifequal = 1 # will never happen!}    ifequal = 1 # will never happen!\n\\immediate\\write\\patchexamples{    output = O1 # This won't work!}    output = O1 # This won't work!\n\\end{droidini}\n\nIf you try this out, you will probably {\\it never} get both inputs equal.\nEven a single electron too much could theoretically make the difference.\nSo in order to make such comparisons possible, there is a way to allow for\na {\\it slight unprecision} when doing the comparison. This is set with the\n{\\t precision} parameter:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    precision = 0.1}    precision = 0.1\n\\immediate\\write\\patchexamples{    ifequal = 1}    ifequal = 1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow the inputs {\\t I1} and {\\t I2} are being treated as equal as long as\ntheir difference is {\\t 0.1} (1~V) at most.\n\n\n\\subsubsection*{Makeing a three-way switch}\n\nIt is possible to check all three relations at once. Make sure that\nyou apply a {\\t precision} if you deal with analog values:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    compare = I2}    compare = I2\n\\immediate\\write\\patchexamples{    precision = 0.1}    precision = 0.1\n\\immediate\\write\\patchexamples{    ifless = 0}    ifless = 0\n\\immediate\\write\\patchexamples{    ifequal = 1}    ifequal = 1\n\\immediate\\write\\patchexamples{    ifgreater = 2}    ifgreater = 2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow you get {\\t 0}, {\\t 1} or {\\t 2}, depending on wether {\\t I1}\nis less, equal or greater than {\\t I2}.\n\nNote: Better do not use just {\\t ifless} and {\\t ifgreater} without\nusing {\\t ifequal} or {\\t else}. This lets the equality undefined\nand will output 0 if for any chance the two input values are equal.\nBetter use {\\t ifless} / {\\t ifgreater} in combination with {\\t else}\nif you are not interested in the exact equality.\n\n\n\\subsubsection*{Omitted inputs}\n\nIt is allowed to omit any of the inputs {\\t ifless}, {\\t ifequal}, {\\t ifgreater}\nor {\\t else}. Any of these is treated as {\\t 0} with one exception:\nIf you omit all four, {\\t ifequal} defaults to {\\t 1}. This make a super\nbasic {\\t compare} circuit just check if two values are equal:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    input = B1.1}    input = B1.1\n\\immediate\\write\\patchexamples{    compare = 0}    compare = 0\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nThis will output {\\t 1} if button {\\t B1.1} as the value {\\t 0} (is not\npressed).\n\n\n\\subsubsection*{Dynamic output values}\n\nAs often, instead of using fixed values for {\\t ifless}, {\\t ifequal}, {\\t\nifgreater} and {\\t else} you can use dynamic values from somewhere else,\nof course.  The following example will output a sine wave at {\\t O1} if the\npot is left of the center or else a square wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    sine = _SINE}    sine = _SINE\n\\immediate\\write\\patchexamples{    square = _SQUARE}    square = _SQUARE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[compare]}[compare]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    compare = 0.5}    compare = 0.5\n\\immediate\\write\\patchexamples{    ifless = _SINE}    ifless = _SINE\n\\immediate\\write\\patchexamples{    else = _SQUARE}    else = _SQUARE\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "A value to compare.\n", "essential": 2, "ramsize": 12}, {"name": "compare", "type": "cv", "default": "0", "description": "A reference value to compare the input with.\n", "essential": 2, "ramsize": 12}, {"name": "ifgreater", "type": "cv", "default": "unpatched", "description": "Value to be output if {\\t input} is greater than {\\t compare}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n", "essential": 1, "ramsize": 12}, {"name": "ifless", "type": "cv", "default": "unpatched", "description": "Value to be output if {\\t input} is less than {\\t compare}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n", "essential": 1, "ramsize": 12}, {"name": "ifequal", "type": "cv", "default": "unpatched", "description": "Value to be output if {\\t input} is equal to {\\t compare} within the\nprecision defined by {\\t precision}.\nIf you patch nothing here, the value of the input {\\t else} will be used.\n", "essential": 2, "ramsize": 12}, {"name": "else", "type": "cv", "default": "0", "description": "Specifies the output value in case non of the stated conditions are met.\n", "essential": 1, "ramsize": 12}, {"name": "precision", "type": "cv", "default": "0", "description": "An optional precision to be used by {\\t ifequal}\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Here one of {\\t ifgreater}, {\\t ifless} or {\\t ifequal} is output.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 124, "ramsize": 32}, "contour": {"category": "modulation", "title": " Contour generator", "description": "An enhanced version of the classic ADSR-envelope generator with the six phases\npredelay, attack, hold, decay, sustain and release.\n\nFor triggering there are two alternative inputs: {\\t gate} and {\\t trigger}. Use\n{\\t trigger} if you are not interested in the length of the gate signal. There\nwill be no decay / sustain phase in that case.\n\nThe minimal patch just connects {\\t gate} or {\\t trigger} and the output. It\ncreates an envelope with standard timings, triggered at {\\t I1} and\noutput to {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate   = I1}    gate   = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nAssigning pots to the classic four inputs lets you use\nthe \\droid just as a normal ADSR envelope:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate    = I1}    gate    = I1\n\\immediate\\write\\patchexamples{    attack  = P1.1}    attack  = P1.1\n\\immediate\\write\\patchexamples{    decay   = P1.2}    decay   = P1.2\n\\immediate\\write\\patchexamples{    sustain = P2.1}    sustain = P2.1\n\\immediate\\write\\patchexamples{    release = P2.2}    release = P2.2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nWhen you try this out, you will notice that the time range of the {\\t attack}\nparameter is much shorter than that of {\\t decay} and {\\t release}. If fact\nit is just $\\frac1{20}$ of these. This has been chosen in this way because I\nbelieve that this makes sense from a musical point of view. Very long attack\ntimes are quite unusual and I wanted to be able to directly map the four\nvalues to pots. But if you don't like that you can -- of course -- make all\nthree timing parameters have the same range simply by multiplying attack by 20:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate    = I1}    gate    = I1\n\\immediate\\write\\patchexamples{    attack  = P1.1 * 20}    attack  = P1.1 * 20\n\\immediate\\write\\patchexamples{    decay   = P1.2}    decay   = P1.2\n\\immediate\\write\\patchexamples{    sustain = P2.1}    sustain = P2.1\n\\immediate\\write\\patchexamples{    release = P2.2}    release = P2.2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nIf you do not change the {\\t shape} parameter, the duration of\nthe attack phase is 0.1~sec at a value of 1. The phases\ndecay and release have a duration of 2.0~sec at a value of 1.\n\n\\subsubsection*{The Phases}\n\nIn addition to the traditional ADSR phases this circuit also has a an\noptional predelay ({\\bf P}) phase -- which acts like a delay before the\nenvelope starts -- and an optional hold ({\\bf H}) phase which keeps the envelope at\nmaximum level for a short time right after attack and before decay.\n\nThe following diagram shows an example envelope with all six phases. The gate\nstarts at 0 ms and ends at 200 ms.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [color=cyan]    coordinates { (0,0) (10,0) };\n\\addplot [color=red]     coordinates { (10,0) (25,10) };\n\\addplot [color=blue]    coordinates { (25,10) (40,10) };\n\\addplot [color=orange]  coordinates { (40,10) (60,5) };\n\\addplot [color=green]   coordinates { (60,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{P,A,H,D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{Attack, Decay and Release}\n\nThe phases attack, decay, release are phases where the level of the envelope\nstarts at one level and then approaches another level within a certain time.\nIn the upper example all these phases had a {\\it linear} characteristic.\nThat means that the output voltage changes by a constant amount per time.\n\n\\droid's {\\t contour} allows you to control the shape of these phases in\norder to get them {\\it bent} in either direction. For that purpose there\nare the inputs {\\t attackshape}, {\\t decayshape} and {\\t releaseshape}.\n\nLet's take decay as an example. During the decay phase the envelopes voltage\nfalls from the maximum level of 10 V (you can change this with the input {\\t\nlevel}) to the sustain level defined by the input {\\t sustain}. For simplicity\nlet's assume that you have not used these inputs, so the maximum level is\n10~V ({\\t 1.0}) and the sustain level is 5~V ({\\t 0.5}). Also we assume\nattack, predelay and hold to be {\\t 0.0}.\n\nWhen {\\t decayshape} is not patched or otherwise set to its default of {\\t 0.5},\nthe shape of the decay curve is {\\it linear}. This means that it\ngoes down by the same voltage each second until it reaches {\\t 0.5}.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [color=orange]  coordinates { (0,10) (60,5) };\n\\addplot [color=green]   coordinates { (60,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\nNow, if you set {\\t decayshape} to {\\t 1.0}, the curve\nis completely {\\it exponential}:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [domain=0:100,color=orange,samples=100] {5 + 5 * 0.95^x};\n\\addplot [color=green]   coordinates { (100,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\nSuch an envelope sounds completely different -- of course also depending on\nwhether you feed this into a linear VCA, exponential VCA or a VCF.\nFor fine control you can use any number between {\\t 1.0} and {\\t 0.5} of\ncourse. In that case you will get a curve that is bent to a certain degree.\nAssigning {\\t decayshape} to a pot helps you {\\it listening} to the different\nsounds:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate        = I1}    gate        = I1\n\\immediate\\write\\patchexamples{    decayshape  = P1.1}    decayshape  = P1.1\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nIf the shape gets a value less than {\\t 0.5}, the curve is bent into the\nopposite direction (some call this {\\it logarithmic} but mathematically this\nis not true). Here is an example where {\\t decayshape} is set to {\\t 0.0}:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 300, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    axis lines = left,\n]\n\\addplot [domain=0:100,color=orange,samples=100] {10 - (5 * 0.95^(100-x))};\n\\addplot [color=green]   coordinates { (100,5) (200,5) };\n\\addplot [color=magenta] coordinates { (200,5) (220,0) };\n\\legend{D,S,R}\n\\legend{D,S,R}\n\\end{axis}\n\\end{tikzpicture}\n\n\n% \\newpage", "inputs": [{"name": "gate", "type": "gate", "default": "unpatched", "description": "Patch a gate signal here that triggers the envelope. Gate means\nthat the length of the signal is relevant. While the gate is high\nthe sustain phase holds on. As soon as gate is going low the release\nphase is being entered.\n", "essential": 2, "ramsize": 16}, {"name": "trigger", "type": "trigger", "default": null, "description": "This is an alternative method of starting the envelope.\nIf you use {\\t trigger} instead of {\\t gate}, there are the\nfollowing differences:\n\n\\begin{itemize}\n\\item The duration of the trigger signal is being ignored.\n\\item There is no decay / sustain phase. Attack and hold are\nimmediately followed by release. The inputs {\\t sustain} and\n{\\t decay} have no impact anymore.\n\\item The predelay and attack phases are continued until their\nend even when the trigger signal ends (When using {\\t gate}\nand the gate signal ends during predelay, the envelope does\nnot start. When it ends during attack, decay / sustain are\nbeing skipped and release starts at the current level of the envelope.\nThat way short gates can result in ``quieter'' envelopes).\n\\end{itemize}\n", "essential": 0, "ramsize": 16}, {"name": "retrigger", "type": "gate", "default": "1", "description": "If you patch {\\t 0} or {\\t off} here, a gate or trigger impulse\nwill {\\bf not} immediately restart the envelope unless it already has\nreached its release phase.  The default {\\t on},\nwhich means that a trigger will immediately restart the envelope in any\ncase.\n", "essential": 0, "ramsize": 12}, {"name": "startfromzero", "type": "gate", "default": "0", "description": "If you set this to {\\t 1} or {\\t on}, a trigger or gate will\nreset the envelope's current level immediately to zero. This is sometimes\ncalled ``digital mode''. In the normal analog mode the envelope\nresumes from where it is. This means that when a trigger occurs right\nin the release phase where the level is still high, will start\nit's attack not from zero but from this hight value.\n", "essential": 0, "ramsize": 12}, {"name": "abortattack", "type": "gate", "default": "0", "description": "This is an {\\t on} / {\\t off} setting that decides what happens\nif the input gate goes {\\t off} while the predelay or attack phase\nis still not finished. Per default that phase will be finalized\nregardless of the gate state.  If {\\t abortattack} is {\\t on}, the\nend of the gate will immediately stop the attack phase and move on\nto hold. Note: In this case the value of the envelope will not reach the maximum\nlevel. If the gate ends during the predelay phase, no\nenvelope will be started at all.\n\nNote: This setting is only functional when the {\\t gate} input\nis being used for triggering the envelope. If you use {\\t trigger},\nthe attack phase is always completely executed and this setting\nhas no influence.\n", "essential": 0, "ramsize": 12}, {"name": "loop", "type": "gate", "default": "0", "description": "This is an {\\t on} / {\\t off} input that switches loop on or off. When\nloop is {\\t on}, the envelope will immediately start again once it\nhas finished. It also starts without triggering. This converts\ncontour into a kind of fancy LFO.\n\n{\\t gate} / {\\t trigger} and {\\t loop} can be combined. Any gate or\ntrigger will restart the envelope just as usual -- even in loop mode.\n", "essential": 0, "ramsize": 12}, {"name": "predelay", "type": "cv", "default": "0", "description": "The predelay phase inserts a delay between the incoming gate\nand the begin of the envelope. The length of the predelay is\n0.1 seconds per volt, so a value of {\\t 1.0} means 1 second\n", "essential": 0, "ramsize": 12}, {"name": "attack", "type": "cv", "default": "0", "description": "Length of the attack phase, i.e. the time from the beginning of\nthe gate until the maximum {\\t level} is reached. See the general\ndescription for information about the scaling of this input.\n", "essential": 1, "ramsize": 12}, {"name": "hold", "type": "cv", "default": "0", "description": "If this is none-zero, the envelopes lingers a certain amount\nof time at its maximum level after the attack and before the decay\nphase. The input value specifies a number of seconds.\nA value of {\\t 0.5} (this is 5~V) will create a hold time of\n0.5 seconds.\n", "essential": 1, "ramsize": 12}, {"name": "decay", "type": "cv", "default": "0.2", "description": "Time of the decay phase\n", "essential": 1, "ramsize": 12}, {"name": "sustain", "type": "fraction", "default": "0.5", "description": "Sustain level\n", "essential": 1, "ramsize": 12}, {"name": "swell", "type": "fraction", "default": "0", "description": "If this jack is set to a value greater than {\\t 0.0},\nthe level of the envelope will go\nup or down again during the sustain phase until it reaches\n{\\t swelllevel}.\n", "essential": 0, "ramsize": 12}, {"name": "swelltime", "type": "cv", "default": "5", "description": "Time of the swell phase\n", "essential": 0, "ramsize": 12}, {"name": "swelllevel", "type": "cv", "default": "1", "description": "Level the swell phase is approaching. Setting this to the\nsame as {\\t sustain} effectively disables swell.\n", "essential": 0, "ramsize": 12}, {"name": "release", "type": "cv", "default": "0.2", "description": "Timing of the release phase\n", "essential": 1, "ramsize": 12}, {"name": "level", "type": "cv", "default": "1", "description": "Maximum level and scaling of the envelope. It is basically an\noutput attenuator of the envelope. Sudden changes in the level will\nimmediately have an (audible) impact on the envelope.\n", "essential": 0, "ramsize": 12}, {"name": "velocity", "type": "fraction", "default": "1", "description": "{\\it energy} of the attack: The velocity is similar to the {\\t level},\nbut is effective just during the attack phase. During that phase that\nmaximum voltage that is read from the {\\t velocity} jack and will be used\nas the velocity of the envelope. Further changes during the other phases\nwill be ignored. This makes it ideal of using with a sequencer. For example\nyou can patch an {\\it accent} output here and add some offset.\nSudden changes in this input will not affect the shape of the envelope.\n", "essential": 0, "ramsize": 12}, {"name": "pitch", "type": "voltperoctave", "default": "0", "description": "This is a {\\it one volt per octave} input affecting all timings of\nthe envelope. When you set this to {\\t 0} (the default), it is neutral.\nA value of {\\t 0.1} (1 Volt) will exactly double the speed of all phases -\njust as one octave up doubles the frequency of an oscillator. This jack\ncan be used to easily implement envelopes where the length very naturally\nfollows this pitch - just like on a piano, glockenspiel or marimba lower\nnotes last longer than higher ones.\n", "essential": 0, "ramsize": 12}, {"name": "taptempo", "type": "trigger", "default": null, "description": "Tap tempo is an alternative method of specifying a pitch information.\nWhen you patch a clock to tap tempo, all time parameters in\nthe envelope are relative to that clock. If the clock speeds up,\nthe envelope gets faster and vice versa. The reference speed is 120 BPM.\nThis means that if you patch a 120 BPM clock here, nothing changes.\nClocks faster than 120 BPM will speed up the envelope. Clocks slower\nthan 120 BPM will slow it down.\n\nPlease see page \\pageref{taptempo} for details on using\n{\\t taptempo} inputs.\n", "essential": 0, "ramsize": 30}, {"name": "shape", "type": "bipolar", "default": "0.5", "description": "If you use this jack, it sets the shape for all of the\nrelevant phases, which are attack, decay, swell and release. Note:\nthis input is only effective for those phases where the dedicated\ninput (like {\\t attackshape}, etc.) is {\\it not} being used.\n", "essential": 0, "ramsize": 12}, {"name": "attackshape", "type": "bipolar", "default": "unpatched", "description": "Shape of the attack curve. If nothing is patched here, the value\nof {\\t shape} will be used.\nSee the general description for how curve shapes work.\n", "essential": 0, "ramsize": 12}, {"name": "decayshape", "type": "bipolar", "default": "unpatched", "description": "Shape of the curve in the decay phase. If nothing is patched here,\nthe value of {\\t shape} will be used.\n", "essential": 0, "ramsize": 12}, {"name": "swellshape", "type": "bipolar", "default": "unpatched", "description": "Shape of curve during the swell phase. If nothing is patched here,\nthe value of {\\t shape} will be used.\n", "essential": 0, "ramsize": 12}, {"name": "releaseshape", "type": "bipolar", "default": "unpatched", "description": "Shape of the curve in the release phase. If nothing is patched\nhere, the value of {\\t shape} will be used.\n", "essential": 0, "ramsize": 12}, {"name": "zerocrossing", "type": "cv", "default": "unpatched", "description": "This is an experimental feature: If you patch the output of an\noscillator here, an incoming gate or trigger signal will be\ndelayed until the next zero crossing of that signal. That allows\nyou to start the envelope exactly when the audio signal is at 0\nand avoid nasty klicks, even if the attack is set to 0. It comes\nat a price, however. The delay between the trigger and the first\nzero crossing might vary a lot from note to note and that could\nmake your rhythm untight, especially if the frequency of the oscillator\nis low.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Main output of the envelope. Patch this to your filter, VCA or\nwherever you like.\n", "essential": 1, "ramsize": 4}, {"name": "negated", "type": "cv", "default": null, "description": "The negated output is the same as the output but in negative\nvoltage.\n", "essential": 0, "ramsize": 4}, {"name": "inverted", "type": "cv", "default": null, "description": "The inverted output always outputs {\\it positive} voltages but\nis inverted relative to the level of the envelope. When the normal\n{\\t output} outputs 0 V, the inverted output outputs {\\t level} and\nvice versa\n", "essential": 0, "ramsize": 4}, {"name": "endofpredelay", "type": "trigger", "default": null, "description": "This output will emit a trigger with a length of 10 ms when the\npredelay phase has ended.\n", "essential": 0, "ramsize": 8}, {"name": "endofattack", "type": "trigger", "default": null, "description": "This output will emit a trigger with a length of 10 ms when the\nattack phase has ended.\n", "essential": 0, "ramsize": 8}, {"name": "endofhold", "type": "trigger", "default": null, "description": "This output will emit a trigger with a length of 10 ms when the\nhold phase has ended.\n", "essential": 0, "ramsize": 8}, {"name": "endofdecay", "type": "trigger", "default": null, "description": "This output will emit a trigger with a length of 10 ms when the\ndecay phase has ended.\n", "essential": 0, "ramsize": 8}, {"name": "endofrelease", "type": "trigger", "default": null, "description": "This output will emit a trigger with a length of 10 ms when the\nrelease phase has ended.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 126, "ramsize": 112}, "copy": {"category": "logic", "title": " Copy a signal", "description": "This circuit is a simple utility that copies a signal from an input to an\noutput. Since every input generally can be attenuated and offset this can\nbe used for scaling and offsetting a signal on its path.\n\nThe following example outputs the sine wave of the same LFO to {\\t O1}\nand {\\t O2}, where {\\t O2} is being inverted. This is also an example\nof using an output as an input.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 0.5 * P1.1}    hz = 0.5 * P1.1\n\\immediate\\write\\patchexamples{    sine = O1}    sine = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input = O1}    input = O1\n\\immediate\\write\\patchexamples{    inverted = O2}    inverted = O2\n\\end{droidini}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Connect the signal you want to copy here.\n", "essential": 2, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "The resulting signal will be sent here.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 131, "ramsize": 24}, "crossfader": {"category": "cv", "title": " Morph between 8 inputs", "description": "This utility circuit creates CV a controlled mix of two\nout of up to eight inputs. With two inputs this acts like\na classical cross fader. The following example lets you\nfade between the signals at {\\t I1} and {\\t I2} by\nturning the pot {\\t P1.1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    fade   = P1.1}    fade   = P1.1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nAt fully CCW ({\\t 0.0})\nonly the signal of the first input is being output,\nat fully CW ({\\t 1.0}) only that of the second one.\nIn the center position ({\\t 0.5}) you get the average\nof both inputs, namely $0.5\\times${\\t I1}$\\hspace{1mm}\n+ \\hspace{1mm}0.5\\times${\\t I2}.\n\nUsing more than two inputs is possible. The {\\t fade} input\nthen maps the range 0.0 ... 1.0 to a journey from the first\nto the last input. Let's see the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz           = 0.1}    hz           = 0.1\n\\immediate\\write\\patchexamples{    sawtooth     = _FADE}    sawtooth     = _FADE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1       = I1}    input1       = I1\n\\immediate\\write\\patchexamples{    input2       = I2}    input2       = I2\n\\immediate\\write\\patchexamples{    input3       = I3}    input3       = I3\n\\immediate\\write\\patchexamples{    input4       = I4}    input4       = I4\n\\immediate\\write\\patchexamples{    fade         = _FADE}    fade         = _FADE\n\\immediate\\write\\patchexamples{    output       = O1}    output       = O1\n\\end{droidini}\n\nNow during one LFO cycle of 10 seconds the output {\\t O1} begins with the\nsignal at {\\t I1} and then morphs to that of {\\t I2}. It reaches 100\\%\nof {\\t I2} at a fade value of $\\frac13$. Then it continues to {\\t I3},\nwhich it reaches at $\\frac23$ and finally -- after 10 seconds --\nit ends at {\\t I4}. After that it immediately jumps back to {\\t I1},\nin order to begin the next cycle.\n\nValues beyond 1.0 for {\\t fade} are allowed and allow you to morph from the\nlast input to the first one. In the previous example that would be the range\nfrom {\\t 1.0} to {\\t 1.3333}. So if you scale up the sawtooth to a total\nrange of {\\t 0.0} ... {\\t 1.3333} you will get a smooth cyclic morph\nbetween all four inputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz           = 0.1}    hz           = 0.1\n\\immediate\\write\\patchexamples{    sawtooth     = _FADE}    sawtooth     = _FADE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[crossfader]}[crossfader]\n\\immediate\\write\\patchexamples{    input1       = I1}    input1       = I1\n\\immediate\\write\\patchexamples{    input2       = I2}    input2       = I2\n\\immediate\\write\\patchexamples{    input3       = I3}    input3       = I3\n\\immediate\\write\\patchexamples{    input4       = I4}    input4       = I4\n\\immediate\\write\\patchexamples{    fade         = _FADE * 1.3333}    fade         = _FADE * 1.3333\n\\immediate\\write\\patchexamples{    output       = O1}    output       = O1\n\\end{droidini}", "inputs": [{"prefix": "input", "name": "input1 ... input8", "count": 8, "start_at": 1, "type": "cv", "default": "0", "description": "The input signals that you want to crossfade between. At least\n{\\t input1} and {\\t input2} need to be patched. Otherwise they\nare treated like 0 V signals.\n", "essential": 2, "essential_count": 2, "ramsize": 12}, {"name": "fade", "type": "fraction", "default": "0.5", "description": "This value decides which of the two inputs should be mixed and\nto which degree each one should go into the mix. At {\\t 0.0} the\nmix consists of 100\\% of the first inputs, at {\\t 1.0} of 100\\%\nof the last patched input.\n", "essential": 2, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Output of the mix\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 132, "ramsize": 40}, "cvlooper": {"category": "cv", "title": " Clocked CV looper", "description": "Easy to use clocked CV looper that also loops an additional gate\nand can do overlay and overdub.\n\nThis circuit is a very easy to use CV looper. It records an incoming CV (and\noptionally a gate as well) on a virtual tape loop with a resolution of one\nsample per ms.  The length of this tape is eight seconds. If you need a longer\nloop time, you can reduce the tape speed. At a speed of {\\t 0.5} you have a\nmaximum loop time of 16 seconds and a resolution of one sample per 2~ms (which\nis still pretty decent for most applications).\n\nThis looper is meant to be playable in a live situation as easily as possible.\nFor that purpose it does not implement the typical {\\it loop start $\\to$ loop\nstop} scheme -- which requires the musician to know beforehand that she will\nstart a loop. Instead the looper is {\\it always} recording. The loop length is\nspecified in {\\it clock ticks}. And as soon as the looping is activated, the\nprevious $x$ clock ticks of CV information will be repeated over and over.\n\nHere is an example for a simple looper for one CV without a gate:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    led        = L1.1}    led        = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    cvin       = I1}    cvin       = I1\n\\immediate\\write\\patchexamples{    clock      = I8    # steady clock}    clock      = I8    # steady clock\n\\immediate\\write\\patchexamples{    cvout      = O1}    cvout      = O1\n\\immediate\\write\\patchexamples{    length     = 16    # 16 clock ticks}    length     = 16    # 16 clock ticks\n\\immediate\\write\\patchexamples{    loopswitch = L1.1}    loopswitch = L1.1\n\\end{droidini}\n\nThe button {\\t B1.1} is converted into a toggle button for activating the\nlooping.  The CV is read from {\\t I1} and is sent to {\\t O1}. As long as the\nloop switch is {\\t off} the looper is in bypass mode and simply copies {\\t I1}\nto {\\t O1}. At the same time it is always recording to its internal endless tape.\nWhen the loop switch is switched {\\t on}, the last 16 clock ticks of CV information is\nlooped to {\\t O1} and {\\t I1} is ignored.\n\nPlease note: for your convenience the exact time when the loop switch is switched\n{\\t on} is {\\it quantized to the nearest clock tick} -- may it be in the future\nor past. This makes playing exactly in time much easier.\n\nThe second example adds a gate signal -- such as output by a ribbon controller. The\ngate is running through {\\t I2}$\\to${\\t O2}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button     = B1.1}    button     = B1.1\n\\immediate\\write\\patchexamples{    led        = L1.1}    led        = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    cvin       = I1}    cvin       = I1\n\\immediate\\write\\patchexamples{    gatein     = I2}    gatein     = I2\n\\immediate\\write\\patchexamples{    clock      = I8    # steady clock}    clock      = I8    # steady clock\n\\immediate\\write\\patchexamples{    cvout      = O1}    cvout      = O1\n\\immediate\\write\\patchexamples{    gateout    = O2}    gateout    = O2\n\\immediate\\write\\patchexamples{    length     = 16    # 16 clock ticks}    length     = 16    # 16 clock ticks\n\\immediate\\write\\patchexamples{    loopswitch = L1.1}    loopswitch = L1.1\n\\end{droidini}\n\nUsing a gate changes the behaviour of the CV looper.  The state of {\\t gatein}\n(not the exact voltage) is being looped as well.  The CV is recorded to the\ntape {\\it only while the gate is high}.\n\nUsing a gate makes two additional features possible:\n\n\\begin{enumerate}\n\n\\item When {\\t overlay} is {\\t on} and the input gate is active, the input CV\nwill override that on the tape and instead the source signal from {\\t cvin}\nis bypassed to the output. The tape's content stays untouched. This allows\nyou to overlay the loop CV with your own from time to time.\n\n\\item On the other hand, when {\\t overdub} is {\\t on} and the input gate is active, the input\nCV will be written to the tape and {\\it replaces the recorded CV} at those\nplaces. And it also will be routed to the output at the same time.\n\n\\end{enumerate}\n\nToggle buttons would fit nicely for these two functions.\n\nPlease note: you always need a clock! The CV looper is useless without one.  If\nyou do not want to use an external clock, you can make use of the LFO circuit\nfor creating an internal clock.\n\nWhat if you want to loop more than one CV? Just create\nmore {\\t cvlooper} circuits -- one for each CV. And control them from the\nsame set of buttons.\n\n\\subsubsection*{Changing the tape or clock speed}\n\nIt is possible to change the tape speed on the fly in order to slow down or\nspeed up the recorded loop's content. It is important -- however -- to always\nchange the tape speed and clock speed {\\it at the same time and in the same\nmanner}. Otherwise you will get stuttering effects. So if you double the {\\t\ntapespeed} you also need to double the frequency of the clock.\n\n\\subsubsection*{Changing the length}\n\nChanging {\\t length} parameter on the fly is supported and just\nworks. Remember: it does not set the length of the tape loop but just the\nlength of that part that is played back. The recording is always done with\nthe maximum length. So if you {\\it increase} the length while playing back\nyou will get access to the older parts of the CV history that way. Just don't\nmake the length longer than the actual tape (see below).\n\n\\subsubsection*{Limitations}\n\nMemory (RAM) is a valuable resource. The CV looper limits itself to 8000\nsamples in order not to waste too much memory and leave space for other circuits\nas well (the Droid master has about 100.000 bytes of memory and 8000 samples\nneed 16.000 bytes). But if you want to make longer loops, you can reduce\nthe tape speed and thus use less samples per second.\n\nA second limitation is that the total loop length can be 128 clock ticks at\nmost. If you need more ticks, you can divide the input clock down, using\n{\\t clocktool}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    clock        = G1}    clock        = G1\n\\immediate\\write\\patchexamples{    divide       = 2}    divide       = 2\n\\immediate\\write\\patchexamples{    output       = _LOOP_CLOCK}    output       = _LOOP_CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    clock        = _LOOP_CLOCK}    clock        = _LOOP_CLOCK\n\\immediate\\write\\patchexamples{    cvin         = I5}    cvin         = I5\n\\immediate\\write\\patchexamples{    tapespeed    = 0.2 # max loop five x longer}    tapespeed    = 0.2 # max loop five x longer\n\\immediate\\write\\patchexamples{    cvout        = O5}    cvout        = O5\n\\immediate\\write\\patchexamples{    length       = 128 # = 256 original ticks}    length       = 128 # = 256 original ticks\n\\immediate\\write\\patchexamples{    loopswitch   = _SOME_BUTTON}    loopswitch   = _SOME_BUTTON\n\\end{droidini}", "inputs": [{"name": "cvin", "type": "cv", "default": "0", "description": "Input CV that should be looped.\n", "essential": 2, "ramsize": 12}, {"name": "gatein", "type": "gate", "default": "1", "description": "Optional input gate. If you do not patch something here, the gate is\nassumed to be always high.\n", "essential": 1, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "Input clock. The clock is mandatory and is the base for the definition of\nthe loop length. Also the loop switch is quantized in time to the nearest\nclock.\n", "essential": 2, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the playback head immediately to the start of the loop,\nif you are in playback mode.\n", "essential": 1, "ramsize": 16}, {"name": "length", "type": "integer", "default": "16", "description": "Length of the loop in clock ticks. Example: You get a length of 16 ticks\nby patching the number {\\t 16} to {\\t length}. If you want to set the length by means\nof an external CV that would require 160 Volts. So you need to multiply your\ninput by some useful number in that case.\n", "essential": 1, "ramsize": 12}, {"name": "tapespeed", "type": "cv", "default": "1", "description": "Relative tape speed, where {\\t 1.0} is the normal speed.\nSo a value of {\\t 0.5}\nslows down the speed thus increasing the effective tape length from 8 to\n16 seconds while reducing the sampling rate from 1 ms to 2 ms per sample.\nChanging the tape speed on the fly probably leads to interesting results.\n", "essential": 0, "ramsize": 12}, {"name": "loopswitch", "type": "gate", "default": "unpatched", "description": "Mandatory parameter: While the loop switch is {\\t off} the CV looper\nsimply sends all input CV and gate to their respective outputs. At the same time CV\nand gate are also recorded to the tape. When the loop switch is {\\t on},\nthe CV and gate are being read from the tape, instead. The input\nCV and gate are now ignored.\n", "essential": 2, "ramsize": 16}, {"name": "pause", "type": "gate", "default": "off", "description": "This is a binary input. If you send a high signal here, the looper\npauses. This is only works in playback mode. The current CV value\nis hold the entire time. This is {\\it not} the same as bypass, since\nin bypass mode the original CV will be routed through.\n", "essential": 1, "ramsize": 12}, {"name": "overlay", "type": "gate", "default": "off", "description": "Overlaying changes the behaviour while looping is active. If {\\t overlay} is\nset to {\\t on}, while the input gate is active the gate and CV will be\nsent directly from the inputs rather than read from the tape.\n", "essential": 1, "ramsize": 12}, {"name": "overdub", "type": "gate", "default": "off", "description": "Overdubbing also changes the behaviour during the looping: If\nit is active then while the input gate is high the input gate\nand CV will be written\nto the tape -- thus changing the loop on the fly.\n", "essential": 1, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": "off", "description": "Setting {\\t bypass} to {\\t on} copies the input CV and gate from their\ninputs to their outputs {\\it while keeping the loop's content\nuntouched}. This disabled the looping for the while, but you\ncan get back to it later. Note: this is different from turning\noff the loop switch, because then your tape's content\nwould be overwritten.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "cvout", "type": "cv", "default": null, "description": "Output of the bypassed or looped CV\n", "essential": 2, "ramsize": 4}, {"name": "gateout", "type": "gate", "default": null, "description": "Output of the bypassed or looped gate\n", "essential": 1, "ramsize": 4}], "presets": 0, "manual": 133, "ramsize": 17336}, "dac": {"category": "logic", "title": " DA Converter with 12 bits", "description": "This circuit converts a binary representation of up to 12 bits into an output\nvalue in a given range. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[dac]}[dac]\n\\immediate\\write\\patchexamples{    bit1 = I1}    bit1 = I1\n\\immediate\\write\\patchexamples{    bit2 = I2}    bit2 = I2\n\\immediate\\write\\patchexamples{    bit3 = I3}    bit3 = I3\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nIn this example three bits are being used. Three bits can represent\na number from 0 to 7. These are mapped to the input range from 0\nto 1 (or 0~V to 10~V) in the following way:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\n{\\t bit1} & {\\t bit2} & {\\t bit3} & bit value & output \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0}    & 0.000 \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1}    & 0.143 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2}    & 0.286 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3}    & 0.429 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4}    & 0.571 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5}    & 0.714 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6}    & 0.857 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7}    & 1.000 \\\\ \\hline\n\\end{tabular}}\n\nIn other words: this circuit will convert three different gate inputs\ninto one analog output value. {\\t bit1} has the most influence, {\\t but3}\nthe least.\n\nThe normal output range is 0 to 1 (i.e. 10~V) per default, but you can change\nthat with the parameters {\\t minimum} and {\\t maximum}.  For example you\ncould have the three bits mapped to just the range of 0.1 to 0.5:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[dac]}[dac]\n\\immediate\\write\\patchexamples{    bit1 = I1}    bit1 = I1\n\\immediate\\write\\patchexamples{    bit2 = I2}    bit2 = I2\n\\immediate\\write\\patchexamples{    bit3 = I3}    bit3 = I3\n\\immediate\\write\\patchexamples{    minimum = 0.1 # 1V}    minimum = 0.1 # 1V\n\\immediate\\write\\patchexamples{    maximum = 0.5 # 5V}    maximum = 0.5 # 5V\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNow the table looks like this:\n\n{\\footnotesize\n\\begin{tabular}{|c|c|c|c|c|} \\hline\n{\\t bit1} & {\\t bit2} & {\\t bit3} & bit value & output \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 0}    & {\\t 0}    & 0.100 \\\\ \\hline\n{\\t 0}    & {\\t 0}    & {\\t 1}    & {\\t 1}    & 0.157 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 0}    & {\\t 2}    & 0.214 \\\\ \\hline\n{\\t 0}    & {\\t 1}    & {\\t 1}    & {\\t 3}    & 0.271 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 0}    & {\\t 4}    & 0.329 \\\\ \\hline\n{\\t 1}    & {\\t 0}    & {\\t 1}    & {\\t 5}    & 0.386 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 0}    & {\\t 6}    & 0.443 \\\\ \\hline\n{\\t 1}    & {\\t 1}    & {\\t 1}    & {\\t 7}    & 0.500 \\\\ \\hline\n\\end{tabular}}\n\nIf you use more of the {\\t bit}-outputs you get more resolution.\nFor example if you use {\\t bit1} ... {\\t bit8}, the total range\nwill be divided into 256 possible output values. The maximum is\n12 bits. Since bit~1 is the most significant bit, adding more\nand more bits will not change the influence of the already\nused bits.\n\nPlease also have a look at the circuit {\\t adc} (see page \\pageref{adc},\nwhich does the exact opposite!\n\n\\clearpage", "inputs": [{"prefix": "bit", "name": "bit1 ... bit12", "count": 12, "start_at": 1, "type": "gate", "default": "unpatched", "description": "The 12 bit input bits. {\\t bit1} is the MSB -- the most significant\nbit. The LSB (least significant bit) is the highest input that\nyou actually patch.\n", "essential": 2, "essential_count": 4, "ramsize": 12}, {"name": "minimum", "type": "cv", "default": "0", "description": "This sets the lower bound of the output range, i.e. the\nvalue that the bit sequence {\\t 000000000000} will produce.\n", "essential": 0, "ramsize": 12}, {"name": "maximum", "type": "cv", "default": "1", "description": "This sets the upper bound of the output value, i.e. the\nvalue that the bit sequence {\\t 111111111111} will produce.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Output signal.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 136, "ramsize": 56}, "delay": {"category": "cv", "title": " A tape delay for CVs, gates and numbers", "description": "Use this circuit to delay the movement CVs, gates or integer numbers in time.\nThe usage is very simple. Feed input signals into the circuit, set a delay\ntime and these signals are output again delayed by that time.\n\n{\\it Note: This circuit is still experimental. In a future firmware version it\nmight be changed or removed. Also the file format on the SD card for the\nsaved recordings might change and a new version might not be\nable to load old recordings.}\nThe basic usage of the delay is very simple:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[delay]}[delay]\n\\immediate\\write\\patchexamples{    cvin = I1}    cvin = I1\n\\immediate\\write\\patchexamples{    cvout = O1}    cvout = O1\n\\immediate\\write\\patchexamples{    delay = 0.5}    delay = 0.5\n\\end{droidini}\n\nHere the signal from {\\t I1} is output again at {\\t O1} with a delay\nof 0.5 seconds.\n\nYou can make the delay time depend on the speed of a clock signal.\njust feed a steady clock into {\\t clock}. Now the {\\t delay} parameter\nis measured in clock ticks -- not in seconds anymore.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[delay]}[delay]\n\\immediate\\write\\patchexamples{    cvin = I1}    cvin = I1\n\\immediate\\write\\patchexamples{    cvout = O1}    cvout = O1\n\\immediate\\write\\patchexamples{    clock = G1 # input clock}    clock = G1 # input clock\n\\immediate\\write\\patchexamples{    delay = 4 # delay by 4 ticks}    delay = 4 # delay by 4 ticks\n\\end{droidini}\n\n\\subsubsection*{Use as a trigger delay}\n\nAlongside the continous CV, eight gate signals can be fed through the\ndelay. Use {\\t gatein1} \\dots {\\t gatein8} and {\\t gateout1} \\dots {\\t\ngateout8} for this purpose:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[delay]}[delay]\n\\immediate\\write\\patchexamples{    gatein1 = G1}    gatein1 = G1\n\\immediate\\write\\patchexamples{    gatein2 = G2}    gatein2 = G2\n\\immediate\\write\\patchexamples{    gatein3 = G3}    gatein3 = G3\n\\immediate\\write\\patchexamples{    gatein4 = G4}    gatein4 = G4\n\\immediate\\write\\patchexamples{    gateout1 = G5}    gateout1 = G5\n\\immediate\\write\\patchexamples{    gateout2 = G6}    gateout2 = G6\n\\immediate\\write\\patchexamples{    gateout3 = G7}    gateout3 = G7\n\\immediate\\write\\patchexamples{    gateout4 = G8}    gateout4 = G8\n\\immediate\\write\\patchexamples{    delay = 0.5}    delay = 0.5\n\\end{droidini}\n\nNow the gate patterns at the inputs {\\t G1} through {\\t G4}\nappears time shifted by 0.5 seconds at the outputs {\\t G5}\nthrough {\\t G8}.\n\n\\input{cvtape}\n\n\\subsubsection*{Loading and saving}\n\nYou might wonder, why this circuit offers loading and saving of the tape's\ncontent to the SD card. The reason is not because it's super useful but\nbecause {\\t delay} uses the same tape implementation as {\\t recorder} and\nsaving is part of that.\n\nWhen you load a file into the tape, it's contents will be audible for a short\ntime. But soon after the tape is overwritten with the new incoming data.\n\nSaving might make more sense. You could make a snapshot of the tape's\ncontent and load that into a \\circuit{recorder} for playback. But even\nthat doesn't seem to be game changing material.", "inputs": [{"name": "delay", "type": "cv", "default": "1", "description": "The CVs are delayed by this amount of seconds. If you patch {\\t\nclock} as well, the delay is specified in clock tick, so then {\\t\ndelay = 1} means ``delay by one clock tick''.\n", "essential": 0, "ramsize": 12}, {"name": "cvin", "type": "cv", "default": "0", "description": "Continous input CV\n", "essential": 2, "ramsize": 12}, {"name": "numberin", "type": "integer", "default": null, "description": "Discrete input number in the range 0 ... 255\n", "essential": 0, "ramsize": 12}, {"prefix": "gatein", "name": "gatein1 ... gatein8", "count": 8, "start_at": 1, "type": "cv", "default": null, "description": "Input gates\n", "essential": 1, "essential_count": 1, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "If you use this clock input, all time inputs are measured in\nclock ticks instead of seconds.\n", "essential": 0, "ramsize": 30}, {"name": "sample", "type": "gate", "default": null, "description": "If you patch this input, ``triggered'' mode is enabled. In this mode,\nthe virtual tape just records a new CV on each trigger at {\\t sample}.\nSo it just records stepped CVs, no slopes and no CV changes\nbetween the triggers.\n", "essential": 0, "ramsize": 16}, {"name": "timewindow", "type": "cv", "default": "0", "description": "When in triggered mode, this optional parameter helps tackling\na problem that many hardware sequencers show: often their\npitch CV is not at its final destination value at the time their\ngate is being output. Often you see a very short ``slew'' ramp\nof say 5~ms after the gate. During that time the pitch CV moves\nfrom its former to the new value.\n\nNow if you trigger the {\\t cvtape} circuit with the sequencer's\ngate you will essentially sample the {\\it previous} pitch CV\ninstead of the new one. Or maybe something in between.\n\nThe {\\t timewindow} parameter configures a short time window\nafter the trigger to {\\t trigger}. During that time period the\ntape will constantly adapt the last sample to a changed input\nCV. When that time is over, the input is finally frozen on the tape.\n\nThe {\\t timewindow} parameter is in seconds. So when you set {\\t\ntimewindow} to say 0.005 (which means 5~ms), you give the\ninput CV 5~ms time for settling to its final value after a trigger\nto {\\t sample} before freezing it.\n", "essential": 0, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": "off", "description": "Setting {\\t bypass} to {\\t on} copies the input signals directly\nto the outputs, regardless of any other stuff going on.\n", "essential": 0, "ramsize": 12}, {"name": "save", "type": "trigger", "default": null, "description": "Send a trigger here to save the current contents of the\ntape to a file on the SD card. The filename is {\\t tapeXXXX.bin},\nwhere {\\t XXXX} is replaced by the number set by {\\t filenumber}.\n", "essential": 0, "ramsize": 16}, {"name": "load", "type": "trigger", "default": null, "description": "Send a trigger here to load a previously saved file into the\ntape. Use {\\t filenumber} so specify which file to load.\n", "essential": 0, "ramsize": 16}, {"name": "filenumber", "type": "integer", "default": "1", "description": "Number of the file to load or save. The range is 0 - 9999.\nIf {\\t filenumber} is 123, the name on the SD card is\n{\\t tape0123.bin}. These files are shared between all\n{\\t recorder} and {\\t delay} circuits.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "cvout", "type": "cv", "default": null, "description": "Output of the continous input CV\n", "essential": 2, "ramsize": 4}, {"name": "numberout", "type": "integer", "default": null, "description": "Output of the discrete number\n", "essential": 0, "ramsize": 4}, {"prefix": "gateout", "name": "gateout1 ... gateout8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "Output of the gates\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "overflow", "type": "gate", "default": null, "description": "When the internal memory of the tape is exceeded and\ndata got lost, this gate goes to {\\t 1} for 0.5 seconds.\nIf you are suspecting this situation, you can wire this\noutput to an LED and observe the memory status that way.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 138, "ramsize": 1672}, "droid": {"category": "other", "title": " General DROID controls", "description": "This circuit gives access to some general \\droid configuration\nsettings. It does not make sense to create more than one\ninstance of this.\n\nThe {\\t droid} circuit gives you access to miscellaneous functions that affect\nthe system as a whole. The most commonly used functions are that for lowering\nthe brightness of the LEDs on the master, G8 and X7 via {\\t ledbrightness}\nand that of reducing the force feedback power of virtual notches of the\nmotor faders of the M4. This is done with {\\t m4notchpower}.\n\n\\columnbreak", "inputs": [{"name": "ledbrightness", "type": "cv", "default": "1", "description": "Let's you dim all of the 24 LEDs of the master and the G8. This\nis mainly for those who think they are too bright. But since this\nparameter can be CV-controlled, you could of course also do funny\nthings with it. Beware: if you set this to zero, the LEDs will\nbe completely dark. This also includes possible error messages.\n", "essential": 1, "ramsize": 12}, {"prefix": "maxslope", "name": "maxslope1 ... maxslope8", "count": 8, "start_at": 1, "type": "cv", "default": "0.25", "description": "Sets a threshold for a voltage change between two samples until\nthe internal logic of the \\droid outputs assumes that\nthis step is intentional and should not be smoothed out.\nA typical case where you do not want smoothing is the pitch\noutput of a sequencer.\n\nThe default value is {\\t 0.25}. A value of {\\t 0.0} turns\noff smoothing altogether since the slightest voltage change\nis considered an intentional jump.\n", "essential": 1, "essential_count": 8, "ramsize": 12}, {"prefix": "lpfilter", "name": "lpfilter1 ... lpfilter8", "count": 8, "start_at": 1, "type": "fraction", "default": "0.25", "description": "Configures a digital low pass filter on the output in order\nto smooth out digital noise resulting from the \\droid's main\nloop. This loop is running somewhere between 3 and 6 kHz -- depending\non the number of circuits you use.\n\nPer default this filter is set to {\\t 0.25} -- which means a mild\nfiltering -- thus still allowing fast and snappy envelopes and\nother rapidly changing signals while filtering away most of the\ndigital artefacts.\n\nIf you use an output for a slow envelope that is combined with an\naudio path in a way that you hear digital artifacts then increase\nthat value. This is e.g. the case if you modulate a VCA that in\nturn modulates a very low pitched audio wave with very few harmonics\n(such as a sine or triangle wave).\n\nThe maximum value of {\\t 1.0} leads to a very strong filtering -- i.e.\nremoving all fast transients. Snappy envelopes will be smoothed out\nheavily. Square wave LFOs will be converted into lower level almost\nsine waves.\n", "essential": 1, "essential_count": 8, "ramsize": 12}, {"name": "m4faderspeed", "type": "fraction", "default": null, "description": "Set the force / speed of the motor faders. Faster speeds need\nmore electrical power and might wear off the faders faster. Too\nslow speeds might lead to poor operation. This value goes from 0.0\n(slowest possible speed) to 1.0 (maximum speed). If you don't use\nthis parameter, some reasonable default is used that depends on the\nfirmware of the M4 module.\n", "essential": 0, "ramsize": 12}, {"name": "m4notchpower", "type": "fraction", "default": null, "description": "Set the force feedback power of the M4 motor fader units when\nthey operate with virtual notches. The range is from 0 (minimum\nnotch power) to 1 (maximum notch power). Note: 0 does not turn the\nnotches off, there is still some minimal feedback. If you don't use\nthis parameter, the notch force feedback operates at some default\npower, which is dependent on the M4 firmware version.\n", "essential": 0, "ramsize": 12}, {"name": "calibrate", "type": "trigger", "default": null, "description": "Immediately enter the calibration procedure, that's contained\nin the maintainance menu. Skips the menu. After calibration is\ndone, resets.\n", "essential": 0, "ramsize": 16}, {"name": "startx7upgrade", "type": "trigger", "default": null, "description": "Immediately starts the X7 firmware upgrade procedure (which is\nlocated at position 8 of the maintainance menu). After the upgrade\nof the X7 resets the master.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here sends a trigger to the {\\t clear} input of\nall circuits that support this. That brings the state of those\ncircuits to their start state. Circuits that have presets do {\\bf keep}\nthose presets untouched. Just the current state is affected.\n\nThat trigger is {\\bf not} sent to circuits whose {\\t clear} input\nis patched.\n\n{\\it Note:} Just that part of the state is affected that is saved\nto the SD card. For example the \\circuit{algoquencer} does not\nreset to the first step, it just clears it's current pattern.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here sends a trigger to the {\\t clearall} input of\nall circuits that support this. That's like a global factory reset\nfor all of your circuits. Everything is set to its starting state,\nincluding all presets of those circuits.\n\nThat trigger is {\\bf not} sent to circuits whose {\\t clearall} input\nis patched.\n\n{\\it Note:} Just that part of the state is affected that is saved\nto the SD card. For example the \\circuit{algoquencer} does not\nreset to the first step, it just clears it's current pattern.\n", "essential": 0, "ramsize": 16}], "outputs": [], "presets": 0, "manual": 141, "ramsize": 64}, "euklid": {"category": "sequencing", "title": " Euclidean rhythm generator", "description": "This circuit creates trigger patterns according to the\nwell-known {\\it Euclidean rhythms} and is of course\nCV controllable. The pattern is described by three numbers:\n\n\\begin{itemize}\n\\item The number of steps in the pattern\n\\item The number of beats in the pattern\n\\item An offset for shifting the beats forward\n\\end{itemize}\n\nThe number of beats are distributed as evenly as possible in\nthe pattern -- but of course are all placed precisely on clock\nbeats. Here are a few examples of various patterns:\n\n\\bgroup\n\\renewcommand{\\arraystretch}{1.4}\n\\def\\beat{\\mbox{\\hspace{-0.6mm}\\quaver}}\n\\def\\begineuklid{\\vspace{-3mm}\\begin{tabular}{|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|p{0.7mm}|}\\hline}\n\\def\\endeuklid{\\\\ \\hline \\end{tabular}\\vspace{2mm}}\n\nlength: 16, beats: 4, offset: 0\n\n\\begineuklid \\beat &  &  &  & \\beat &  &  &  & \\beat &  &  &  & \\beat &  &  & \\endeuklid\n\nlength: 16, beats: 5, offset: 0\n\n\\begineuklid \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\endeuklid\n\nlength: 16, beats: 5, offset: 1\n\n\\begineuklid  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  &  & \\beat &  & \\endeuklid\n\nlength: 16, beats: 11, offset: 0\n\n\\begineuklid \\beat & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat &  & \\beat & \\beat & \\endeuklid\n\nlength: 13, beats: 5, offset: 0\n\n\\begineuklid \\beat &  & \\beat &  &  & \\beat &  & \\beat &  &  & \\beat &  & \\endeuklid\n\nlength: 13, beats: 5, offset: 1\n\n\\begineuklid  & \\beat &  & \\beat &  &  & \\beat &  & \\beat &  &  & \\beat & \\endeuklid\n\nlength: 4, beats: 2, offset: 1\n\n\\begineuklid  & \\beat &  & \\beat\\endeuklid\n\n\\egroup\n\nHere is an example without CV control:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = 5}    beats   = 5\n\\immediate\\write\\patchexamples{    offset  = 0}    offset  = 0\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nNow let's change that in order to make the beats controllable by the pot\n{\\t P1.1}. Please note how the pot range is being changed from the default 0~\\dots~1\nto the necessary 1~\\dots~16 by using a factor of 15 and an offset of 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = P1.1 * 15 + 1}    beats   = P1.1 * 15 + 1\n\\immediate\\write\\patchexamples{    offset  = 0}    offset  = 0\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nBy the way: Since the default for {\\t length} is {\\t 16} and for {\\t offset}\n{\\t 0} you can drop those two lines if you like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    reset   = G2}    reset   = G2\n\\immediate\\write\\patchexamples{    beats   = P1.1 * 15 + 1}    beats   = P1.1 * 15 + 1\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\n\\subsubsection*{Offbeats}\n\nThe output {\\t offbeats} does the exact opposite of {\\t outputs}:\nit triggers at those clock beats where {\\t output} does not. So\nat any given clock tick exactly either {\\t output} or {\\t offbeats}\ntriggers.\n\n\\subsubsection*{Gate length}\n\nThe length of the output gate is the same as that of the input gate.\nAlso the exact voltage from the input is copied to the output while\nthe current step is active.\n\n\\clearpage", "inputs": [{"name": "clock", "type": "gate", "default": "unpatched", "description": "Patch a clock signal here. It does not need to be steady --\neven if this is the most usual application. Note: this input is classified\nas a gate input, since the length of the gate is being\npreserved when forwarded to {\\t output} and {\\t offbeats}.\n", "essential": 2, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the pattern to the start\n", "essential": 1, "ramsize": 16}, {"name": "outputsignal", "type": "cv", "default": "unpatched", "description": "Usually on active steps {\\t euklid} just lets the original\ninput clock get through to the output. If this parameter is\nused, it will be sent to the output on active steps instead.\nThe easiest application is just setting it to {\\t 1}.\nThe output will then become {\\t 1} the whole time while\nthe current step is active. This is useful if you want to\nuse {\\t euklid} as modulation CV rather than as trigger.\n", "essential": 0, "ramsize": 12}, {"name": "length", "type": "integer", "default": "16", "description": "The length of a pattern. This is interpreted as an integer number,\nwhich must be greater than 0. If it is not then {\\t 1} is assumed.\nIf you CV control the length, use multiplication. The maximum accepted\nlength is 64.\n", "essential": 1, "ramsize": 12}, {"name": "beats", "type": "integer", "default": "5", "description": "The number of active beats that should be distributed amongst\nthe {\\t length} steps. If that number is greater than {\\t length},\nit is capped to that number.\n", "essential": 1, "ramsize": 12}, {"name": "offset", "type": "integer", "default": "0", "description": "rotates or shifts the pattern by that number of steps. This number\ncan be positive or negative.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "output", "type": "gate", "default": null, "description": "Output of the {\\bf beats} in the current pattern.\nThe gate length is directly taken from\nthe input clock -- just as the voltage.\n", "essential": 2, "ramsize": 4}, {"name": "offbeats", "type": "gate", "default": null, "description": "Here those impulses will be output where there is {\\it no}\nbeat in the pattern.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 143, "ramsize": 48}, "explin": {"category": "logic", "title": " Exponential to linear converter", "description": "This circuit converts an exponential input curve into a linear\noutput curve. Image you have an analog envelope outputting an\nexponential curve like the following one:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0, 0.5, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\end{axis}\n\\end{tikzpicture}\n\nThe curve starts at 8 V and reaches 0.5 V at about 500 ms later.\n\nThe following droid patch will convert this into a linear curve:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[explin]}[explin]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    output  = O2}    output  = O2\n\\immediate\\write\\patchexamples{    startvalue = 8V}    startvalue = 8V\n\\immediate\\write\\patchexamples{    endvalue = 0.5V}    endvalue = 0.5V\n\\end{droidini}\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0, 0.5, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\addplot [domain=0:500,color=blue] coordinates { (0,8) (500,0) };\n\\legend{Input,Output}\n\\end{axis}\n\\end{tikzpicture}\n\nWith the values {\\t startvalue} and {\\t endvalue} you configure how\nthis translation is scaled. The {\\t startvalue} selects the voltage\nwhere the exponential input curve and the linear output curve should\nbe the same. If the input is an envelope voltage then {\\t startvalue}\nwould be the start or maximum voltage of that envelope.\n\nA falling exponential curve will never reach 0 in theory. So with {\\t endvalue}\nyou set a value (or voltage) in that you consider the curve to be low\nenough to be inaudible. At that voltage the linear output will exactly be\nzero. This voltage can be used to control the slope of the linear output\ncurve. The following example shows how different values of {\\t endvalue}\naffect the output:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 500, ymin = 0, ymax = 8,\n    ymajorgrids = true,\n    ytick={0.5, 1, 2, 4, 6, 8, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:500,color=blue] coordinates { (0,8) (500,0) };\n\\addplot [domain=0:500,color=green!60!black] coordinates { (0,8) (380,0) };\n\\addplot [domain=0:500,color=red] coordinates { (0,8) (250,0) };\n\\addplot [domain=0:500,color=gray,samples=100] {8 * 0.9945^x};\n\\legend{0.5V,1V,2V}\n\\end{axis}\n\\end{tikzpicture}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Patch an exponential envelope output or a similar signal here. This\nvalue must be positive or otherwise it will be set to {\\t 0.0}.\n", "essential": 2, "ramsize": 12}, {"name": "startvalue", "type": "cv", "default": "1", "description": "The assumed maximum value of the input signal (the start voltage\nfrom where it decays in an exponential way.\n", "essential": 1, "ramsize": 12}, {"name": "endvalue", "type": "cv", "default": "0.01", "description": "The value at which it is assumed to be zero (at which the linear\noutput will be set to zero. This value must be positive. It is forced\nto be $>=$  {\\t 0.001}.\n", "essential": 1, "ramsize": 12}, {"name": "mix", "type": "fraction", "default": "1", "description": "Sets the mix between the ``dry'' and ``wet'' signal: At {\\t 0.0} the\noutput is the same as the input. At {\\t 1.0} the output is the linear\ncurve. At a value in between it is some average. You are even allowed\nto used values $>$ {\\t 1.0}. A value of {\\t 2.0} will overcompensate\nand bend the curve beyond linearity into a curve some modularists would\ncall {\\it logarithmic}.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Here comes the resulting linear output\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 145, "ramsize": 32}, "faderbank": {"category": "ui", "title": " Create multiple virtual faders in M4 controller", "description": "This circuit is very similar to \\circuit{motorfader} but controls up to\n16 faders at once. It's purpose is to reduce the number of {\\t motorfader}\ncircuits in situations where you control banks or arrays of parameters in\na similar way. It does not add any extra functionality to {\\t motorfader}.\n\nThat being said, it is easiest to just show the differences to a single\n{\\t motorfader} circuit. And these are:\n\n\\begin{itemize}\n\\item Instead of {\\t fader} you set {\\t firstfader} to specify which faders\nyou want to control. The number of faders does not need to be set since\nit corresponds to the number of output jacks you use.\n\\item Instead of {\\t output} you have {\\t output1}, {\\t output2} and so on.\nThis determines the number of faders that are controlled by this circuit.\n\\item The parameters {\\t notches} and {\\t ledcolor} are {\\it common}\nfor all controlled faders. They are identical as those in {\\t motorfader}.\n\\item The parameters {\\t ledvalue1}, {\\t ledvalue2}, ... can set the\nbrightness of the individual LEDs below the faders.\n\\item Because of memory limitations you only have 6 presets ({\\t motorfader} has 8).\n\\end{itemize}\n\nHere is an example of a fader bank of the three faders\n3, 4 and 5 (spreading over two M4s). We use a pot to select\none of six presets (from 0 to 5). Turning the pot will immediately\nswitch the preset (and the faders will move accordingly).\nAnd the CVs will be sent to outputs {\\t O1}, {\\t O2} and {\\t O3}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[faderbank]}[faderbank]\n\\immediate\\write\\patchexamples{    preset = P1.1 * 6}    preset = P1.1 * 6\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\end{droidini}", "inputs": [{"name": "firstfader", "type": "integer", "default": "1", "description": "First M4 fader of the virtual fader bank (starting with 1).\n", "essential": 1, "ramsize": 12}, {"name": "notches", "type": "integer", "default": null, "description": "Number of artifical notches. {\\t 0} disables the notches.\n{\\t 1} creates a pitch bend wheel. {\\t 2} creates a binary\nswitch with the output values {\\t 0} and {\\t 1}. Higher\nnumber create that number of notches. E.g. {\\t 8} creates\neight notches and {\\t output} will output one of the\nvalue {\\t 0}, {\\t 1}, ... {\\t 8}.\n\nThe maximum number of notches is {\\t 201}. But if you select\nmore than 25 notches, the force feedback is turned off as the\nnotches would get too small to work.\n", "essential": 1, "ramsize": 12}, {"name": "startvalue", "type": "cv", "default": "0", "description": "This sets the value the faders should get when the circuit\nstarts for the first time or when you send a trigger to {\\t clear}.\n", "essential": 0, "ramsize": 12}, {"name": "ledcolor", "type": "cv", "default": null, "description": "When you use this input, it will set the color of the\nLED below the faders, when the circuit is selected. If the\nLED is off, this setting has now impact.\n", "essential": 0, "ramsize": 12}, {"prefix": "ledvalue", "name": "ledvalue1 ... ledvalue16", "count": 16, "start_at": 1, "type": "cv", "default": null, "description": "When you use this input, it will override the brightness\nof the LEDs below the faders, but just when this circuit\nis selected.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output16", "count": 16, "start_at": 1, "type": "cv", "default": null, "description": "Outputs the current value if the virtual motor faders\nthat these outputs.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "button", "name": "button1 ... button16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "Outputs the current value of the touch buttons of the\nfaders to these output which this circuit is selected.\n", "essential": 0, "essential_count": 0, "ramsize": 4}], "presets": 6, "manual": 147, "ramsize": 616}, "fadermatrix": {"category": "ui", "title": " Matrix of up to 4x4 virtual motor faders", "description": "This circuit is a clever way of controlling a four by four matrix\nof parameters, which allows you to select either a row or a column.\n\nAs an example let's think of a bank of four envelope generators. Each of them\nhas the settings attack, decay, sustain and release (ADSR). That nicely\nforms a 4$\\times$4 matrix:\n\n\\begin{center}\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]\n  \\tikzstyle{every state}=[fill=white,draw=black,text=black]\n\n  \\node[state] (B11) []  {Att 1};\n  \\node[state] (B12) [right of=B11] {Dec 1};\n  \\node[state] (B13) [right of=B12] {Sus 1};\n  \\node[state] (B14) [right of=B13] {Rel 1};\n\n  \\node[state] (B21) [below of=B11]  {Att 2};\n  \\node[state] (B22) [right of=B21] {Dec 2};\n  \\node[state] (B23) [right of=B22] {Sus 2};\n  \\node[state] (B24) [right of=B23] {Rel 2};\n\n  \\node[state] (B31) [below of=B21]  {Att 3};\n  \\node[state] (B32) [right of=B31] {Dec 3};\n  \\node[state] (B33) [right of=B32] {Sus 3};\n  \\node[state] (B34) [right of=B33] {Rel 3};\n\n  \\node[state] (B41) [below of=B31]  {Att 4};\n  \\node[state] (B42) [right of=B41] {Dec 4};\n  \\node[state] (B43) [right of=B42] {Sus 4};\n  \\node[state] (B44) [right of=B43] {Rel 4};\n\n\\end{tikzpicture}\n\\end{center}\n\nThe {\\t fadermatrix} has 16 outputs that map to\nthese matrix positions:\n\n\\begin{center}\n\\begin{tikzpicture}[-,>=stealth',node distance=2.0cm, semithick]\n  \\tikzstyle{every state}=[fill=white,draw=black,text=black]\n\n  \\node[scale=0.8,state] (B11) []             {\\tt output11};\n  \\node[scale=0.8,state] (B12) [right of=B11] {\\tt output12};\n  \\node[scale=0.8,state] (B13) [right of=B12] {\\tt output13};\n  \\node[scale=0.8,state] (B14) [right of=B13] {\\tt output14};\n\n  \\node[scale=0.8,state] (B21) [below of=B11] {\\tt output21};\n  \\node[scale=0.8,state] (B22) [right of=B21] {\\tt output22};\n  \\node[scale=0.8,state] (B23) [right of=B22] {\\tt output23};\n  \\node[scale=0.8,state] (B24) [right of=B23] {\\tt output24};\n\n  \\node[scale=0.8,state] (B31) [below of=B21] {\\tt output31};\n  \\node[scale=0.8,state] (B32) [right of=B31] {\\tt output32};\n  \\node[scale=0.8,state] (B33) [right of=B32] {\\tt output33};\n  \\node[scale=0.8,state] (B34) [right of=B33] {\\tt output34};\n\n  \\node[scale=0.8,state] (B41) [below of=B31] {\\tt output41};\n  \\node[scale=0.8,state] (B42) [right of=B41] {\\tt output42};\n  \\node[scale=0.8,state] (B43) [right of=B42] {\\tt output43};\n  \\node[scale=0.8,state] (B44) [right of=B43] {\\tt output44};\n\n\\end{tikzpicture}\n\\end{center}\n\nNow when you design a patch for controlling these 16 parameters\nwith 4 motor faders you basically have the choice of selecting\n{\\it rows} or {\\it columns}! One way would be to always select\none of the envelopes to be diplayed and edited on your faders,\nfor example the second one:\n\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]\n  \\tikzstyle{every state}=[fill=white,draw=black,text=black]\n  \\tikzstyle{on}=[fill=lightgray]\n  \\tikzstyle{select}=[fill=black,text=white]\n\n  \\node[state] (B11) []  {Att 1};\n  \\node[state] (B12) [right of=B11] {Dec 1};\n  \\node[state] (B13) [right of=B12] {Sus 1};\n  \\node[state] (B14) [right of=B13] {Rel 1};\n\n  \\node[select] (SEL) [left of=B21]  {Select};\n  \\node[state,on] (B21) [below of=B11]  {Att 2};\n  \\node[state,on] (B22) [right of=B21] {Dec 2};\n  \\node[state,on] (B23) [right of=B22] {Sus 2};\n  \\node[state,on] (B24) [right of=B23] {Rel 2};\n\n  \\node[state] (B31) [below of=B21]  {Att 3};\n  \\node[state] (B32) [right of=B31] {Dec 3};\n  \\node[state] (B33) [right of=B32] {Sus 3};\n  \\node[state] (B34) [right of=B33] {Rel 3};\n\n  \\node[state] (B41) [below of=B31]  {Att 4};\n  \\node[state] (B42) [right of=B41] {Dec 4};\n  \\node[state] (B43) [right of=B42] {Sus 4};\n  \\node[state] (B44) [right of=B43] {Rel 4};\n\n  \\path\n        (SEL) edge (B21)\n        (B21) edge (B22)\n        (B22) edge (B23)\n        (B23) edge (B24)\n  ;\n\\end{tikzpicture}\n\nAn alternative would be to have control over all decay parameters\nof the four envelopes -- in order to shape for synth voices at the\nsame time without switching between those:\n\n\\begin{center}\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]\n  \\tikzstyle{every state}=[fill=white,draw=black,text=black]\n  \\tikzstyle{on}=[fill=lightgray]\n  \\tikzstyle{select}=[fill=black,text=white]\n\n  \\node[select] (SEL) [above of=B12]  {Select};\n\n  \\node[state] (B11) []  {Att 1};\n  \\node[state,on] (B12) [right of=B11] {Dec 1};\n  \\node[state] (B13) [right of=B12] {Sus 1};\n  \\node[state] (B14) [right of=B13] {Rel 1};\n\n  \\node[state] (B21) [below of=B11]  {Att 2};\n  \\node[state,on] (B22) [right of=B21] {Dec 2};\n  \\node[state] (B23) [right of=B22] {Sus 2};\n  \\node[state] (B24) [right of=B23] {Rel 2};\n\n  \\node[state] (B31) [below of=B21]  {Att 3};\n  \\node[state,on] (B32) [right of=B31] {Dec 3};\n  \\node[state] (B33) [right of=B32] {Sus 3};\n  \\node[state] (B34) [right of=B33] {Rel 3};\n\n  \\node[state] (B41) [below of=B31]  {Att 4};\n  \\node[state,on] (B42) [right of=B41] {Dec 4};\n  \\node[state] (B43) [right of=B42] {Sus 4};\n  \\node[state] (B44) [right of=B43] {Rel 4};\n\n  \\path\n        (SEL) edge (B12)\n        (B12) edge (B22)\n        (B22) edge (B32)\n        (B32) edge (B42)\n  ;\n\\end{tikzpicture}\n\\end{center}\n\nWith {\\t faderbank} you would have to decide for one of the two\noptions. But with {\\t fadermatrix} you can have both at the same\ntime.\n\nWith the {\\t rowcolumn} input you can select each column\nand each row as follows:\n\n\\begin{center}\n\\begin{tikzpicture}[-,>=stealth',node distance=1.5cm, semithick]\n  \\tikzstyle{every state}=[fill=white,draw=black,text=black]\n  \\tikzstyle{on}=[fill=lightgray]\n  \\tikzstyle{select}=[fill=black,text=white]\n\n  \\node[select] (SEL0)  [left of=B11]  {0};\n  \\node[select] (SEL1)  [left of=B21]  {1};\n  \\node[select] (SEL2)  [left of=B31]  {2};\n  \\node[select] (SEL3)  [left of=B41]  {3};\n  \\node[select] (SEL4)  [above of=B11] {4};\n  \\node[select] (SEL5)  [above of=B12] {5};\n  \\node[select] (SEL6)  [above of=B13] {6};\n  \\node[select] (SEL7)  [above of=B14] {7};\n\n  \\node[state] (B11) []  {Att 1};\n  \\node[state] (B12) [right of=B11] {Dec 1};\n  \\node[state] (B13) [right of=B12] {Sus 1};\n  \\node[state] (B14) [right of=B13] {Rel 1};\n\n  \\node[state] (B21) [below of=B11]  {Att 2};\n  \\node[state] (B22) [right of=B21] {Dec 2};\n  \\node[state] (B23) [right of=B22] {Sus 2};\n  \\node[state] (B24) [right of=B23] {Rel 2};\n\n  \\node[state] (B31) [below of=B21]  {Att 3};\n  \\node[state] (B32) [right of=B31] {Dec 3};\n  \\node[state] (B33) [right of=B32] {Sus 3};\n  \\node[state] (B34) [right of=B33] {Rel 3};\n\n  \\node[state] (B41) [below of=B31] {Att 4};\n  \\node[state] (B42) [right of=B41] {Dec 4};\n  \\node[state] (B43) [right of=B42] {Sus 4};\n  \\node[state] (B44) [right of=B43] {Rel 4};\n\n  \\path\n        (SEL0) edge (B11) (B11) edge (B12) (B12) edge (B13) (B13) edge (B14)\n        (SEL1) edge (B21) (B21) edge (B22) (B22) edge (B23) (B23) edge (B24)\n        (SEL2) edge (B31) (B31) edge (B32) (B32) edge (B33) (B33) edge (B34)\n        (SEL3) edge (B41) (B41) edge (B42) (B42) edge (B43) (B43) edge (B44)\n\t(SEL4) edge (B11) (B11) edge (B21) (B21) edge (B31) (B31) edge (B41)\n\t(SEL5) edge (B12) (B12) edge (B22) (B22) edge (B32) (B32) edge (B42)\n\t(SEL6) edge (B13) (B13) edge (B23) (B23) edge (B33) (B33) edge (B43)\n\t(SEL7) edge (B14) (B14) edge (B24) (B24) edge (B34) (B34) edge (B44)\n  ;\n\\end{tikzpicture}\n\\end{center}\n\nIf you create a {\\t buttongroup} with eight buttons and patch the output\nto the {\\t rowcolumn} input, you have access to all four rows and columns.\nThe nice thing about the {\\t buttongroup} is that it automatically outputs\nthe values from 0 to 7. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.3}    button2 = B1.3\n\\immediate\\write\\patchexamples{    button3 = B1.5}    button3 = B1.5\n\\immediate\\write\\patchexamples{    button4 = B1.7}    button4 = B1.7\n\\immediate\\write\\patchexamples{    button5 = B1.2}    button5 = B1.2\n\\immediate\\write\\patchexamples{    button6 = B1.4}    button6 = B1.4\n\\immediate\\write\\patchexamples{    button7 = B1.6}    button7 = B1.6\n\\immediate\\write\\patchexamples{    button8 = B1.8}    button8 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.3}    led2 = L1.3\n\\immediate\\write\\patchexamples{    led3 = L1.5}    led3 = L1.5\n\\immediate\\write\\patchexamples{    led4 = L1.7}    led4 = L1.7\n\\immediate\\write\\patchexamples{    led5 = L1.2}    led5 = L1.2\n\\immediate\\write\\patchexamples{    led6 = L1.4}    led6 = L1.4\n\\immediate\\write\\patchexamples{    led7 = L1.6}    led7 = L1.6\n\\immediate\\write\\patchexamples{    led8 = L1.8}    led8 = L1.8\n\\immediate\\write\\patchexamples{    output = _ROWCOLUMN}    output = _ROWCOLUMN\n\\end{droidini}\n\nNow we add a {\\t fadermatrix}. We send all 16 outputs to interncal patch cables\nto be picked up later by four {\\t contour} circuits:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fadermatrix]}[fadermatrix]\n\\immediate\\write\\patchexamples{    rowcolumn = _ROWCOLUMN}    rowcolumn = _ROWCOLUMN\n\\immediate\\write\\patchexamples{    output11 = _ATTACK_1}    output11 = _ATTACK_1\n\\immediate\\write\\patchexamples{    output12 = _DECAY_1}    output12 = _DECAY_1\n\\immediate\\write\\patchexamples{    output13 = _SUSTAIN_1}    output13 = _SUSTAIN_1\n\\immediate\\write\\patchexamples{    output14 = _RELEASE_1}    output14 = _RELEASE_1\n\\immediate\\write\\patchexamples{    output21 = _ATTACK_2}    output21 = _ATTACK_2\n\\immediate\\write\\patchexamples{    output22 = _DECAY_2}    output22 = _DECAY_2\n\\immediate\\write\\patchexamples{    output23 = _SUSTAIN_2}    output23 = _SUSTAIN_2\n\\immediate\\write\\patchexamples{    output24 = _RELEASE_2}    output24 = _RELEASE_2\n\\immediate\\write\\patchexamples{    output31 = _ATTACK_3}    output31 = _ATTACK_3\n\\immediate\\write\\patchexamples{    output32 = _DECAY_3}    output32 = _DECAY_3\n\\immediate\\write\\patchexamples{    output33 = _SUSTAIN_3}    output33 = _SUSTAIN_3\n\\immediate\\write\\patchexamples{    output34 = _RELEASE_3}    output34 = _RELEASE_3\n\\immediate\\write\\patchexamples{    output41 = _ATTACK_4}    output41 = _ATTACK_4\n\\immediate\\write\\patchexamples{    output42 = _DECAY_4}    output42 = _DECAY_4\n\\immediate\\write\\patchexamples{    output43 = _SUSTAIN_4}    output43 = _SUSTAIN_4\n\\immediate\\write\\patchexamples{    output44 = _RELEASE_4}    output44 = _RELEASE_4\n\\end{droidini}\n\nAnd here is the example for the first contour (the other three are similar):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate = I1}    gate = I1\n\\immediate\\write\\patchexamples{    attack = _ATTACK_1}    attack = _ATTACK_1\n\\immediate\\write\\patchexamples{    decay = _DECAY_1}    decay = _DECAY_1\n\\immediate\\write\\patchexamples{    sustain = _SUSTAIN_1}    sustain = _SUSTAIN_1\n\\immediate\\write\\patchexamples{    release = _RELEASE_1}    release = _RELEASE_1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nIf you don't want to waste 8 buttons for just switching, you can also\nuse a pot and scale it to the range of 0 ... 7:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    rowcolumn = P1.1 * 7}    rowcolumn = P1.1 * 7\n\\end{droidini}\n\nAnd of course the rotary switch of an S10 would also be a perfect\nmatch, since it outputs exactly the number from 0 to 7.\n\n\\subsubsection*{Notches}\n\nAs discussed in \\circuit{motorfader}, faders can set to have artifical\nnotches. Also in the fader matrix you can set notches. Here the idea\nis that every parameter in the same {\\it column} of the matrix has\nthe same number of notches. Example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    notches3 = 8}    notches3 = 8\n\\end{droidini}\n\nThis sets all four parameters in column 3 to have eight notches.  This affects\nthe four outputs {\\t output13}, {\\t output23}, {\\t output33} and {\\t output43}\nso that they get notches when selected and also change their output behaviour\nto outputting one of the values {\\t 0}, {\\t 1}, {\\t 2} ... {\\t 7}.\n\nAs you can see the matrix always assumes that you edit four similar {\\it\nthings} with four parameters each. Every row of the matrix is one such\nthing. Every column is one parameter.\n\n\\subsubsection*{Smaller matrices}\n\nYou also can create smaller matrices, for example 3$\\times$.\nSimply omit the outputs {\\t output14}, {\\t 24}, {\\t 34}, {\\t 44},\n{\\t 41}, {\\t 42} and {\\t 43} in that case. Also 2$\\times$2 is\npossible.\n\nBecause we always need to be able to swap rows and columns, those number always\nhave to be identical. So you cannot create a 3$\\times$4 matrix, for example.\n\n\\subsubsection*{Larger matrices}\n\nIf you have eight faders, you can create even larger matrices. A 8$\\times$8\nmatrix can be created by four {\\t fadermatrix} circuits. Here you need some\nextra logic. At any time exactly two of the circuits must be selected.\nUse the {\\t select} inputs in combination with {\\t rowcolumn} in order to\nset this up (left as an excercise) ;-)", "inputs": [{"name": "firstfader", "type": "integer", "default": "1", "description": "First M4 fader of the virtual fader matrix (starting with 1).\n", "essential": 1, "ramsize": 12}, {"name": "rowcolumn", "type": "integer", "default": "0", "description": "Currently selected row or column as follows:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{Control output11, output12, output13 and output14}\n\\jacktablerow{1}{Control output21, output22, output23 and output24}\n\\jacktablerow{2}{Control output31, output32, output33 and output34}\n\\jacktablerow{3}{Control output41, output42, output43 and output44}\n\\jacktablerow{4}{Control output11, output21, output31 and output41}\n\\jacktablerow{5}{Control output12, output22, output32 and output42}\n\\jacktablerow{6}{Control output13, output23, output33 and output43}\n\\jacktablerow{7}{Control output14, output24, output34 and output44}\n\\end{tabular}\n\\vskip 2mm\n", "essential": 2, "ramsize": 12}, {"prefix": "notches", "name": "notches1 ... notches4", "count": 4, "start_at": 1, "type": "integer", "default": "0", "description": "Number of artifical notches in the respective column. For example\n{\\t notches2} controls the notches of {\\t output12}, {\\t output22},\n{\\t output32} and {\\t output42}.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{disables the notches}\n\\jacktablerow{1}{creates a pitch bend wheel}\n\\jacktablerow{2}{creates a binary switch}\n\\jacktablerow{3}{creates a switch with four positions}\n\\jacktablerow{8}{creates eight notches}\n\\jacktablerow{25}{creates 25 notches}\n\\end{tabular}\n\nEnabling notches also changes the output value. When you have two or\nmore notches, the output values become discrete. For example with four notches\nthe output will be {\\t 0}, {\\t 1}, {\\t 2} or {\\t 3}.\n\nNote: The maximum number of notches is {\\t 201}. But if you select\nmore than 25 notches, the force feedback is turned off as the\nnotches would get too small to work.\n", "essential": 1, "essential_count": 4, "ramsize": 12}, {"prefix": "startvalue", "name": "startvalue1 ... startvalue4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "These inputs allow to set a defined start value for each column. When\nthe \\droid starts first and there is either no saved state or state saving\nis disabled via {\\t dontsave = 1}, these start values are used. Also a trigger\nto {\\t clear} loads the start avlues. There\nis one start value for each column. All rows share the same start value\nfor a column.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "ledvalue1", "name": "ledvalue11 ... ledvalue14", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "With these inputs you can address the LEDs below the virtual faders of {\\t\noutput11} ... {\\t output14}. As opposed to using direction (e.g. {\\t\nL1.1}), these inputs will only affect the LED if the according output\nis selected.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "ledvalue2", "name": "ledvalue21 ... ledvalue24", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "With these inputs you can address the LEDs below the virtual faders of {\\t\noutput21} ... {\\t output24}. As opposed to using direction (e.g. {\\t\nL1.2}), these inputs will only affect the LED if the according output\nis selected.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "ledvalue3", "name": "ledvalue31 ... ledvalue34", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "With these inputs you can address the LEDs below the virtual faders of {\\t\noutput31} ... {\\t output34}. As opposed to using direction (e.g. {\\t\nL3.2}), these inputs will only affect the LED if the according output\nis selected.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "ledvalue4", "name": "ledvalue41 ... ledvalue44", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "With these inputs you can address the LEDs below the virtual faders of {\\t\noutput41} ... {\\t output44}. As opposed to using direction (e.g. {\\t\nL4.2}), these inputs will only affect the LED if the according output\nis selected.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "ledcolor", "name": "ledcolor1 ... ledcolor4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "Sets the color of the LEDs below the faders if {\\t ledvalueXY} is\nused. There are just four inputs since every column of outputs has\nthe same LED color (in order to identify them). The color works as\nwith the {\\t R} registers for the LEDs on the master module.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "output1", "name": "output11 ... output14", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "Outputs for the CV values of the first row of parmeter.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "output2", "name": "output21 ... output24", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "Outputs for the CV values of the second row of parmeter.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "output3", "name": "output31 ... output34", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "Outputs for the CV values of the third row of parmeter.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "output4", "name": "output41 ... output44", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "Outputs for the CV values of the fourth row of parmeter.\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "button1", "name": "button11 ... button14", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "Give access to the state of the touch button below the faders\nwhen the respective output in the first row is selected.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "button2", "name": "button21 ... button24", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "Give access to the state of the touch button below the faders\nwhen the respective output in the second row is selected.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "button3", "name": "button31 ... button34", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "Give access to the state of the touch button below the faders\nwhen the respective output in the third row is selected.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "button4", "name": "button41 ... button44", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "Give access to the state of the touch button below the faders\nwhen the respective output in the fourth row is selected.\n", "essential": 0, "essential_count": 0, "ramsize": 4}], "presets": 6, "manual": 149, "ramsize": 640}, "firefacecontrol": {"category": "midi", "title": " Control a RME Fireface interface (experimental)", "description": "This experimental circuit allows you to control the most\nimport volumes and mixes of an RME Fireface audio interface.\nIt's also a perfect match for the M4 motor fader units.\nYou need an X7 in order to use this circuit.\n\nPlease note that this circuit is still experimental. Its main\nproblem is that the MIDI implementation of the Fireface is\nmore designed for user interaction via a Mackie Control and not\nfor general automation. This is very sad.\n\nFor example there is a MIDI CC for changing the panning of\na channel. But instead of simply having the CC going from 0\n(left) via 64 (mid) to 127 (right), it uses various CC values\nas {\\it commands} for modifiying the existing panning by\nsome fixed value to the left or to the right. So without\n{\\it knowing} the current setting, it's not possible to send\nthe correct CC commands. And for \\droid there is no way to\nknow, since MIDI is a one way communication.\n\nRME: if you are reading this: please contact me so that we\ncan fix this.", "inputs": [{"prefix": "outputlevel", "name": "outputlevel1 ... outputlevel16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 1, "essential_count": 4, "ramsize": 12}, {"name": "mainoutput", "type": "integer", "default": "1", "description": "", "essential": 2, "ramsize": 12}, {"prefix": "phonesoutput", "name": "phonesoutput1, phonesoutput2", "count": 2, "start_at": 1, "type": "integer", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix1in", "name": "outputmix1in1 ... outputmix1in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 1, "essential_count": 4, "ramsize": 12}, {"prefix": "outputmix2in", "name": "outputmix2in1 ... outputmix2in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 1, "essential_count": 4, "ramsize": 12}, {"prefix": "outputmix3in", "name": "outputmix3in1 ... outputmix3in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 1, "essential_count": 4, "ramsize": 12}, {"prefix": "outputmix4in", "name": "outputmix4in1 ... outputmix4in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 1, "essential_count": 4, "ramsize": 12}, {"prefix": "outputmix5in", "name": "outputmix5in1 ... outputmix5in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix6in", "name": "outputmix6in1 ... outputmix6in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix7in", "name": "outputmix7in1 ... outputmix7in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix8in", "name": "outputmix8in1 ... outputmix8in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix9in", "name": "outputmix9in1 ... outputmix9in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix10in", "name": "outputmix10in1 ... outputmix10in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix11in", "name": "outputmix11in1 ... outputmix11in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix12in", "name": "outputmix12in1 ... outputmix12in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix13in", "name": "outputmix13in1 ... outputmix13in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix14in", "name": "outputmix14in1 ... outputmix14in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix15in", "name": "outputmix15in1 ... outputmix15in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "outputmix16in", "name": "outputmix16in1 ... outputmix16in16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "postfader", "name": "postfader1 ... postfader16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "pan", "name": "pan1 ... pan16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "unmute", "name": "unmute1 ... unmute16", "count": 16, "start_at": 1, "type": "fraction", "default": null, "description": "", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "update", "type": "trigger", "default": null, "description": "", "essential": 0, "ramsize": 16}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}], "outputs": [], "presets": 0, "manual": 154, "ramsize": 1080}, "flipflop": {"category": "clock", "title": " Simple flip flop", "description": "This circuit implements a flip flop that stores one bit, which can\nbe manipulated with various triggers.\n\n\\bigskip\n\nHere is a simple example for a flip flop that toggles at each\ntrigger. Fun fact: this implements a clock divider by two:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[flipflop]}[flipflop]\n\\immediate\\write\\patchexamples{    toggle  = I1}    toggle  = I1\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nAs an alternative you can work with {\\t set} and {\\t reset}\ntriggers:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[flipflop]}[flipflop]\n\\immediate\\write\\patchexamples{    set  = I1}    set  = I1\n\\immediate\\write\\patchexamples{    reset = I2}    reset = I2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nNote: The flip flop does not save its state to the SD card.\nAnd it has no presets. If you need any of these, have a look\nat \\circuit{button}.", "inputs": [{"name": "toggle", "type": "trigger", "default": null, "description": "A trigger here inverts the state of the flip flop. It changes\n{\\t 0} to {\\t 1} and {\\t 1} to {\\t 0}.\n", "essential": 2, "ramsize": 16}, {"name": "set", "type": "trigger", "default": null, "description": "Sets the flip flop to {\\t 1}.\n", "essential": 0, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "Sets the flip flop to {\\t 0}.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "Sets the flip flop to the value defined by {\\t startvalue}.\n", "essential": 0, "ramsize": 16}, {"name": "startvalue", "type": "gate", "default": "0", "description": "The flip flop starts its live with this value. Also {\\t clear}\nwill set the flip flop to this value.\n", "essential": 0, "ramsize": 12}, {"name": "load", "type": "trigger", "default": null, "description": "Loads the value into the flip flop that's defined with {\\t loadvalue}.\n", "essential": 0, "ramsize": 16}, {"name": "loadvalue", "type": "gate", "default": "1", "description": "Value to set the flip flop to, when {\\t load} is triggered.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "gate", "default": null, "description": "Outputs the current value of the flip flop: either {\\t 0} or {\\t 1}.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 156, "ramsize": 40}, "fold": {"category": "pitch", "title": " CV folder -- keep (pitch) CV within certain bounds", "description": "This circuit can keep an incoming CV within defined bounds,\nbut not by limiting to these bounds, but by {\\it folding} it\nin case it exceeds these bounds.\n\nThe main application is keeping the pitch of a voice within a certain range by\noctaving it up and down when necessary. Octaving keeps the actual note value.\nHere is an example for that application:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V # one octave}    foldby = 1V # one octave\n\\immediate\\write\\patchexamples{    minimum = 1.2V}    minimum = 1.2V\n\\immediate\\write\\patchexamples{    maximum = 2.5V}    maximum = 2.5V\n\\end{droidini}\n\nIf the input value at {\\t I1} is going below 1.2~V, 1~V will\nbe added over and over until the output voltage is at least 1.2~V.\nSo the upper example will convert as follows:\n\n\\begin{itemize}\n\\item 0.7~V $\\rightarrow$ 1.7~V\n\\item 2.0~V $\\rightarrow$ 2.0~V\n\\item -4.3~V $\\rightarrow$ 1.7~V\n\\item 4.4~V $\\rightarrow$ 2.4~V\n\\end{itemize}\n\nIf you apply that to a bass voice, you make sure that it never\ngoes to low or too high, which is helpful if that voice is the\nresult of a combination of sequences, random numbers, transpositions\nand other funny generative ideas.\n\nNote: If you do not specify {\\t minimum} or {\\t maximum},\nno folding will take place at that boundary. If you specify\nneither of them, this circuit is completely useless.\n\n\\subsubsection*{Anomalies}\n\nTwo anomalies can happen if the parameters are a bit ``crazy''.\nThis first one happens, when the space between {\\t minimum} and {\\t maximum}\nis less than one {\\t foldby}. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V}    foldby = 1V\n\\immediate\\write\\patchexamples{    minimum = 1.1V}    minimum = 1.1V\n\\immediate\\write\\patchexamples{    maximum = 1.3V}    maximum = 1.3V\n\\end{droidini}\n\nNow if the input voltage is e.g. 1.0~V, it will be folded up to 2.0~V, which\nis then above the maximum range. But it will stay there, since there is no way\nto fold it into the range anyway.\n\nThe second anomaly is if {\\t minimum} is greater than {\\t maximum}. Look:\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    foldby = 1V}    foldby = 1V\n\\immediate\\write\\patchexamples{    minimum = 2.5V}    minimum = 2.5V\n\\immediate\\write\\patchexamples{    maximum = 1.5V}    maximum = 1.5V\n\\end{droidini}\n\nHere any voltage below 2.5~V will be folded up until it is above that value.\nso 2.4~V will be folded to 3.4~V. Well, you could also argue that because\n2.4~V is also above the maximum value it should get folded down instead. While\nthat is true, {\\t fold} behaves asymmetrical here and gives folding up the precedence.\n\nBut why would you set such strange parameters? Well, because they can be CVs\nof course. Try the following patch and send the output {\\t O1} to the pitch\ninput of a voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P1.1}    hz = 2 * P1.1\n\\immediate\\write\\patchexamples{    triangle = _CV}    triangle = _CV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P1.2}    hz = 2 * P1.2\n\\immediate\\write\\patchexamples{    triangle = _MIN}    triangle = _MIN\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P2.1}    hz = 2 * P2.1\n\\immediate\\write\\patchexamples{    triangle = _MAX}    triangle = _MAX\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2 * P2.2}    hz = 2 * P2.2\n\\immediate\\write\\patchexamples{    triangle = _FOLDBY}    triangle = _FOLDBY\n\\immediate\\write\\patchexamples{    level = 2V}    level = 2V\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[fold]}[fold]\n\\immediate\\write\\patchexamples{    input = _CV}    input = _CV\n\\immediate\\write\\patchexamples{    minimum = _MIN}    minimum = _MIN\n\\immediate\\write\\patchexamples{    maximum = _MAX}    maximum = _MAX\n\\immediate\\write\\patchexamples{    foldby = _FOLDBY}    foldby = _FOLDBY\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    rate = O1 * 0.2}    rate = O1 * 0.2\n\\immediate\\write\\patchexamples{    hz = 110}    hz = 110\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\end{droidini}\n\nHere all four inputs are from slowly running LFOs and funny things happen.\nPlay with the four pots and you will get all sorts of very interesting\nrandom patterns.", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Input CV to be folded.\n", "essential": 2, "ramsize": 12}, {"name": "foldby", "type": "cv", "default": "0.1", "description": "Amount to be added or substracted from the input CV if\nit is not within the allowed range. This CV must be positive.\nIf it is negative or zero, no folding will be done.\n", "essential": 1, "ramsize": 12}, {"name": "minimum", "type": "cv", "default": "unpatched", "description": "Lower bound of the allowed range. If unpatched, no lower\nbound will be applied.\n", "essential": 1, "ramsize": 12}, {"name": "maximum", "type": "cv", "default": "unpatched", "description": "Upper bound of the allowed range. If unpatched, no upper\nbound will be applied.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Folded output voltage\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 157, "ramsize": 32}, "fourstatebutton": {"category": "deprecated", "title": " Button switching through 4 states (OBSOLETE)", "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit\n\\circuit{button}.  {\\t button} can do all {\\t fourstatebutton} can do and\nmuch more. So {\\t fourstatebutton} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis circuit converts one of the push buttons of your controllers into\na button that switches through up to four different states. This is very\nsimilar to {\\t togglebutton} but that supports just two states.\n\nThe LED will be off in state 1, 100\\% bright in state 4 and somewhere\nin between in the other two states.\n\nThe use case is to have a way to manually switch through three or four\noptions. The following example implements an octave switch for a VCO. The\nbutton steps you through the sequence 0 $\\rightarrow$ 1 $\\rightarrow$\n2 $\\rightarrow$ 3 $\\rightarrow$ 0 octaves. The pitch is being read from {\\t I1}\nand output again at {\\t O1} -- possibly shifted by up to 3 octaves (3~V).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[fourstatebutton]}[fourstatebutton]\n\\immediate\\write\\patchexamples{    button  = B1.1}    button  = B1.1\n\\immediate\\write\\patchexamples{    led     = L1.1}    led     = L1.1\n\\immediate\\write\\patchexamples{    value1  = I1 + 0V}    value1  = I1 + 0V\n\\immediate\\write\\patchexamples{    value2  = I1 + 1V}    value2  = I1 + 1V\n\\immediate\\write\\patchexamples{    value3  = I1 + 2V}    value3  = I1 + 2V\n\\immediate\\write\\patchexamples{    value4  = I1 + 3V}    value4  = I1 + 3V\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nOf course the values need not be fixed values. The next examples shows\nyou a \\droid patch where the button is used to cycle through four\ndifferent wave forms of an LFO and send that to output {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 2}    hz       = 2\n\\immediate\\write\\patchexamples{    square   = _W1}    square   = _W1\n\\immediate\\write\\patchexamples{    triangle = _W2}    triangle = _W2\n\\immediate\\write\\patchexamples{    sawtooth = _W3}    sawtooth = _W3\n\\immediate\\write\\patchexamples{    sine     = _W4}    sine     = _W4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[fourstatebutton]}[fourstatebutton]\n\\immediate\\write\\patchexamples{    button   = B1.1}    button   = B1.1\n\\immediate\\write\\patchexamples{    led      = L1.1}    led      = L1.1\n\\immediate\\write\\patchexamples{    value1   = _W1}    value1   = _W1\n\\immediate\\write\\patchexamples{    value2   = _W2}    value2   = _W2\n\\immediate\\write\\patchexamples{    value3   = _W3}    value3   = _W3\n\\immediate\\write\\patchexamples{    value4   = _W4}    value4   = _W4\n\\immediate\\write\\patchexamples{    output   = O1}    output   = O1\n\\end{droidini}", "inputs": [{"name": "button", "type": "trigger", "default": null, "description": "The button.\n", "essential": 0, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "A positive trigger here will reset the button to the first state.\n", "essential": 0, "ramsize": 16}, {"prefix": "value", "name": "value1 ... value4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "The values that {\\t output} should get when the four\nvarious states are active.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "startvalue", "type": "integer", "default": null, "description": "By setting this to {\\t 0}, {\\t 1}, {\\t 2} or {\\t 3} you\nset the initial state of the button when the \\droid is powered up to\nstate 1, 2, 3 or 4. It also disabled the automatic saving of the button's\nstate in the \\droid's internal flash memory.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Depending on the current state of the button here the\nvalue of {\\t input1}, {\\t input2}, {\\t input3} or {\\t input4}\nwill be copied.\n", "essential": 0, "ramsize": 4}, {"name": "led", "type": "fraction", "default": null, "description": "The LED in the button\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 159, "ramsize": 40}, "gatetool": {"category": "clock", "title": " Operate on triggers and gates, modify gatelength", "description": "This utility works with triggers, gates and edge-triggers, can\nconvert each type into each other type and can change the\nlength of gates in flexible ways.\n\n{\\t gatetool} has three different types of inputs. Usually you\nwould patch only one of these:\n\n\\begin{itemize}\n\\item {\\t inputgate} expects a gate signal and honors the time span during\nwhich the gate is high. It takes into account the length of the input gate.\n\\item {\\t inputtrigger} expects triggers signals. Here the time span during which\nthe input is high is not relevant. Just the start of the trigger counts. If you patch a\n``normal'' gate signal here, the length of it is ignored (which could be just\nwhat you wanted).\n\\item {\\t inputedge} looks for transitions between low and high or high and\nlow. Such transitions are called ``edge''. Each time the input level swaps is\nconsidered as a trigger. So patching a normal gate signal here will count as\na trigger when the gate goes high and another trigger when it goes low again.\n\\end{itemize}\n\nFor each input gate, trigger or edge, the {\\t gatetool} outputs an\noutput gate {\\it and} an output trigger {\\it and} an output edge:\n\n\\begin{itemize}\n\\item {\\t outputgate} goes high on an input gate, trigger or edge. The length\nof the output gate can be modified in various ways (see below).\n\\item {\\t outputrigger} outputs a short trigger of 10~ms on an input gate, trigger\nor edge.\n\\item {\\t outputedge} toggles between {\\t 0} and {\\t 1} on each input gate, trigger\nor edge.\n\\end{itemize}\n\n\\subsubsection*{Modifying the gate length}\n\nThe length of the output gate on {\\t outputgate} can be specified in various\nways. First let's assume that you use the {\\t inputtrigger} or the {\\t inputedge}\ninput. In this case there is no ``input gate length''. The length\nof the output gate is set by {\\t gatelength}, which is a number in seconds:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputtrigger = I1}    inputtrigger = I1\n\\immediate\\write\\patchexamples{    outputgate = O1}    outputgate = O1\n\\immediate\\write\\patchexamples{    gatelength = 0.5 # 500 ms}    gatelength = 0.5 # 500 ms\n\\end{droidini}\n\nAs an option, you can set the gate length in relation to a reference clock\n(please see page \\pageref{taptempo} for details on using\n{\\t taptempo} inputs).\nAs soon as you patch {\\t taptempo}, the {\\t gatelength} parameter is in\nrelation to one input clock tick (in \\droid language\n{\\t 0.3} is just the same as {\\t 30\\%}):\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputtrigger = I1}    inputtrigger = I1\n\\immediate\\write\\patchexamples{    taptempo = I2 # some steady clock}    taptempo = I2 # some steady clock\n\\immediate\\write\\patchexamples{    gatelength = 0.3 # 30% of one clock tick}    gatelength = 0.3 # 30% of one clock tick\n\\immediate\\write\\patchexamples{    outputgate = O1}    outputgate = O1\n\\end{droidini}\n\nNote: The {\\t taptempo} input has the one and only purpose of setting a time\nreference to {\\t gatelength}.\n\nNow let's assume that you have an input gate signal, that has a specific\nlength and you want to keep that or work on that. For that purpose use\nthe {\\t gateinput} and the {\\t gateoutput}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputgate = I1}    inputgate = I1\n\\immediate\\write\\patchexamples{    outputgate = O1 # keep gate length}    outputgate = O1 # keep gate length\n\\end{droidini}\n\nThis example is not very useful, though, since it just copies the input gate\nto the output without changing the gate length.  Use the {\\t gatelength}\nparameter to switch the behaviour to that of {\\t triggerinput}: the input\ngate length is ignored and overruled by that parameter:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputgate = I1}    inputgate = I1\n\\immediate\\write\\patchexamples{    outputgate = O1}    outputgate = O1\n\\immediate\\write\\patchexamples{    gatelength = 0.5 # 500 ms}    gatelength = 0.5 # 500 ms\n\\end{droidini}\n\nMore interesting is {\\t gatestretch}. This is the first time the length of the\ninput gate is honored and has any relevance: Here you specify a percentage\nby that the gate should be made {\\it longer}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputgate = I1}    inputgate = I1\n\\immediate\\write\\patchexamples{    outputgate = O1}    outputgate = O1\n\\immediate\\write\\patchexamples{    gatestretch = 0.3 # make gate 30% longer}    gatestretch = 0.3 # make gate 30% longer\n\\end{droidini}\n\nFor obvious reasons you cannot make a gate shorter by a percentage since\nnobody -- not even Droid -- can look into the future...\n\nNote: {\\t gatestretch} obviously only makes sense if you don't use {\\t gatelength}!\n\nIf you want to keep the gate length within certain bounds, you can make use of\n{\\t mingatelength} and {\\t maxgatelength}. They set a lower or upper limit\non the length of the output gate. They only are effective when {\\t gatelength}\nis not used. Both parameter are in seconds or -- if {\\t taptempo} is used --\nin fractions of one clock tick.\n\nThe following example forwards the input gates unchanged to the output, but\nmakes sure that the length is never shorter than 10\\% and never longer that 90\\%\nof a clock tick:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputgate = I1}    inputgate = I1\n\\immediate\\write\\patchexamples{    taptempo = I2 # steady clock}    taptempo = I2 # steady clock\n\\immediate\\write\\patchexamples{    outputgate = O1}    outputgate = O1\n\\immediate\\write\\patchexamples{    mingatelength = 0.1}    mingatelength = 0.1\n\\immediate\\write\\patchexamples{    maxgatelength = 0.9}    maxgatelength = 0.9\n\\end{droidini}\n\n\\subsubsection*{Building a clock divider}\n\nThe edge triggers can help you building a clock divider that divides by two.\nOf course you could do that with \\circuit{clocktool}, as well. But this example\nillustrates a bit, how the edge triggers work. Consider the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[gatetool]}[gatetool]\n\\immediate\\write\\patchexamples{    inputtrigger = I1}    inputtrigger = I1\n\\immediate\\write\\patchexamples{    outputedge = O1}    outputedge = O1\n\\end{droidini}\n\nNow for every trigger in {\\t I1}, the edge output {\\it changes} it's level. So\nin order to go from low to high and low again, you need two input triggers.\nThe output signal at {\\t O1} then just outputs one gate signal in that time.\nSo two triggers are converted into one.\n\n\\subsubsection*{Use edges for pinging filters}\n\nAnother application of edges is pinging filters with a {\\it zero length}\nimpulse.  Use the same patch snippet as above and patch {\\t O1} to the input\nof a resonant filter. By just using the edge, you really get exactly {\\it\none} ping. A trigger -- regardless how short -- always has two edges\nand thus pings the filter twice, which can sound unclean.", "inputs": [{"name": "inputgate", "type": "gate", "default": null, "description": "Input gate. Use this if the length of the input gate is relevant.\n", "essential": 2, "ramsize": 12}, {"name": "inputtrigger", "type": "trigger", "default": null, "description": "Input trigger. Use this if the length of the input gate should be\nignored.\n", "essential": 0, "ramsize": 16}, {"name": "inputedge", "type": "gate", "default": null, "description": "Input edge: Use this if every low/high or high/low transition should\ncount as a trigger.\n", "essential": 0, "ramsize": 12}, {"name": "gatelength", "type": "cv", "default": null, "description": "Sets the length of the gate of {\\t outputgate} in seconds. If you\nuse {\\t taptempo} the length is in fractions of a clock tick, instead.\n", "essential": 1, "ramsize": 12}, {"name": "gatestretch", "type": "cv", "default": "0", "description": "Makes the output gate longer than the input gate by the given percentage.\nThis parameter is ignored if {\\t gatelength} is used.\n", "essential": 0, "ramsize": 12}, {"name": "mingatelength", "type": "cv", "default": "0.01", "description": "Defines a minimum length of the output gate in seconds or\nclock ticks.\n", "essential": 0, "ramsize": 12}, {"name": "maxgatelength", "type": "cv", "default": null, "description": "Defines a maximum length of the output gate in seconds or\nclock ticks.\n", "essential": 0, "ramsize": 12}, {"name": "taptempo", "type": "trigger", "default": null, "description": "If you patch a reference clock here, {\\t gatelength}, {\\t mingatelength}\nand {\\t maxgatelength} are fractions of one clock tick, not seconds\nanymore.\nPlease see page \\pageref{taptempo} for details on using\n{\\t taptempo} inputs.\n", "essential": 0, "ramsize": 30}], "outputs": [{"name": "outputgate", "type": "gate", "default": null, "description": "Outputs a gate with controllable length for every gate, trigger or\nedge event.\n", "essential": 2, "ramsize": 4}, {"name": "outputtrigger", "type": "trigger", "default": null, "description": "Outputs a 10~ms trigger for every gate, trigger or edge event.\n", "essential": 0, "ramsize": 8}, {"name": "outputedge", "type": "gate", "default": null, "description": "Toggle between {\\t 0} and {\\t 1} at every gate, trigger or edge event.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 160, "ramsize": 56}, "lfo": {"category": "modulation", "title": " Low frequency oscillator (LFO)", "description": "A flexible low frequency oscillator with seven different waveforms, phase\nmodulation, flexible sync mechanisms, randomization, wave form morphing and\nother interesting features.\n\nPlease note also that this LFO is not intended to be used at audio rate. It can\nprobably operate until roughly 1000-1500 Hz, but will sound ugly, distorted\nand with many digital artefacts -- especially the waveforms with steep edges like\nsquare, ramp and sawtooth. If that's exactly what you intend, then maybe\nyou will have fun anyway.\n\n\\subsubsection*{Waveforms}\n\nHere is the simplest possible patch. In this example the frequency is\nspecified in Hertz (cycles per seconds) and the {\\t triangle} output\nis routed directly to {\\t O1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\nThe resulting output looks like this:\n\n\\newenvironment{lfounipolar}[1]{\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = #1, ymin = 0, ymax = 10,\n    yscale = 0.5,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]}\n{\\end{axis}\n\\end{tikzpicture}}\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,0) (.125,10) (.25,0) (.375,10) (.5,0)\n    (.625,10) (.75,0) (.875,10) (1,0) };\n\\end{lfounipolar}\n\n\\columnbreak\nThis is how the {\\t sawtooth} output looks like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    sawtooth = O1}    sawtooth = O1\n\\end{droidini}\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates { (0,0) (0.25,10) (0.25,0) (0.5, 10) (0.5, 0) (0.75, 10) (0.75, 0) (1.0, 10)  };\n\\end{lfounipolar}\n\nThe {\\t ramp} is similar but falling instead of rising:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates { (0,10) (0.25,0) (0.25,10) (0.5, 0) (0.5, 10) (0.75, 0) (0.75, 10) (1.0, 0)  };\n\\end{lfounipolar}\n\nThe waveforms {\\t \\textcolor{blue}{sine}} and {\\t \\textcolor{magenta}{cosine}}\nare similar but are one quarter cycle (90\\textdegree{}) apart:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue,samples=100] {(sin(x * 360 * 4) + 1) * 5};\n\\addplot [domain=0:1,color=magenta,samples=100] {(cos(x * 360 * 4) + 1) * 5};\n\\end{lfounipolar}\n\n\\columnbreak\n{\\t paraboloid} is {\\it very} similar to sine, but is constructed based\non quadratic equations (which is faster):\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0.0:0.0625,color=blue,samples=20]   {(2-(1-((x-0.0)    * 16))^2) * 5};\n\\addplot [domain=0.0625:0.125,color=blue,samples=20] {(2-(0+((x-0.0625) * 16))^2) * 5};\n\\addplot [domain=0.125:0.1875,color=blue,samples=20] {(0+(1-((x-0.125)  * 16))^2) * 5};\n\\addplot [domain=0.1875:0.25,color=blue,samples=20]  {(0+(0+((x-0.1875) * 16))^2) * 5};\n\\addplot [domain=0.25:0.3125,color=blue,samples=20]  {(2-(1-((x-0.25)   * 16))^2) * 5};\n\\addplot [domain=0.3125:0.375,color=blue,samples=20] {(2-(0+((x-0.3125) * 16))^2) * 5};\n\\addplot [domain=0.375:0.4375,color=blue,samples=20] {(0+(1-((x-0.375)  * 16))^2) * 5};\n\\addplot [domain=0.4375:0.5,color=blue,samples=20]   {(0+(0+((x-0.4375) * 16))^2) * 5};\n\\addplot [domain=0.5:0.5625,color=blue,samples=20]   {(2-(1-((x-0.5)    * 16))^2) * 5};\n\\addplot [domain=0.5625:0.625,color=blue,samples=20] {(2-(0+((x-0.5625) * 16))^2) * 5};\n\\addplot [domain=0.625:0.6875,color=blue,samples=20] {(0+(1-((x-0.625)  * 16))^2) * 5};\n\\addplot [domain=0.6875:0.75,color=blue,samples=20]  {(0+(0+((x-0.6875) * 16))^2) * 5};\n\\addplot [domain=0.75:0.8125,color=blue,samples=20]  {(2-(1-((x-0.75)   * 16))^2) * 5};\n\\addplot [domain=0.8125:0.875,color=blue,samples=20] {(2-(0+((x-0.8125) * 16))^2) * 5};\n\\addplot [domain=0.875:0.9375,color=blue,samples=20] {(0+(1-((x-0.875)  * 16))^2) * 5};\n\\addplot [domain=0.9375:1.0,color=blue,samples=20]   {(0+(0+((x-0.9375) * 16))^2) * 5};\n\\end{lfounipolar}\n\nMaybe the simplest waveform is {\\t square}:\n\n\\begin{lfounipolar}{1}\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,10) (0.125,10) (0.125,0) (0.25, 0) (0.25, 10) (0.375, 10) (0.375, 0) (0.5, 0)\n    (0.5,10) (0.625,10) (0.625,0) (0.75, 0) (0.75, 10) (0.875, 10) (0.875, 0) (1.0, 0)\n\n    };\n\\end{lfounipolar}\n\n\n\\subsubsection*{Bipolar output, Level and Offset}\n\nPlease note that the LFO outputs just positive voltage ranges until you set\n{\\t bipolar = on}. That extends the waveform to negative voltages (while\ndoubling the peak-to-peak voltage):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 4}    hz       = 4\n\\immediate\\write\\patchexamples{    bipolar  = on}    bipolar  = on\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\n\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 1, ymin = -10, ymax = 10,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:1,color=blue]\ncoordinates {\n    (0,-10)\n    (.125,10)\n    (.25,-10)\n    (.375,10)\n    (.5,-10)\n    (.625,10)\n    (.75,-10)\n    (.875,10)\n    (1,-10)\n};\n\\end{axis}\n\\end{tikzpicture}\n\nThe inputs {\\t level} and {\\t offset} can be used to control the voltage range\nof the outputs -- which is here for your convenience and avoids the need for\nadditional circuits for doing this. The following example outputs a sine\nwave at 5 Hz to {O4} that is gently oscillating between 2 V and 3.5V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 5}    hz          = 5\n\\immediate\\write\\patchexamples{    level       = 1.5V}    level       = 1.5V\n\\immediate\\write\\patchexamples{    offset      = 2V}    offset      = 2V\n\\immediate\\write\\patchexamples{    sine        = O4}    sine        = O4\n\\end{droidini}\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 1, ymin = 0, ymax = 4.5,\n    ymajorgrids = true,\n    ytick={0, 1, 2, 3, 4},\n    grid style = dashed,\n]\n\\addplot [domain=0:1,color=blue,samples=100] {0.75 * sin(x * 360 * 5) + 2.75};\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{Frequency control}\n\nThe frequency of the LFO can be controlled in various ways. In the upper\nexamples we used the input {\\t hz}. Here you specify the frequency of\nthe LFO directly in Hz. This is ideal when you want to set a fixed\nfrequency with a discrete number, rather than a control voltage. Here\nis a rectangle LFO running at 1.5 cycles per second:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz         = 1.5}    hz         = 1.5\n\\immediate\\write\\patchexamples{    rectangle  = O3}    rectangle  = O3\n\\end{droidini}\n\nA more eurorack-like way is using the {\\t rate} input, which works on a 1~V /\noctave scheme. One ``octave'' here means that the frequency doubles. Here is an\nexample for creating a triangle LFO running at 4~Hz, since 2~V doubles the base\nfrequency of 1~Hz two times (instead of {\\t 2V} you could also write {\\t 0.2}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    rate     = 2V}    rate     = 2V\n\\immediate\\write\\patchexamples{    bipolar  = on}    bipolar  = on\n\\immediate\\write\\patchexamples{    triangle = O1}    triangle = O1\n\\end{droidini}\n\n\nThe third way is to use {\\it tap tempo} by sending a steady clock into {\\t\ntaptempo}. The LFO then mimics the speed of that input clock. This can\neven be combined with {\\t rate}: If you use both, then first {\\t taptempo}\nis being used to set the speed and then {\\t rate} is used for altering that\nspeed. So sending -1~V into {\\t rate} will create an LFO running at half clock\nspeed (since -1~V pitches down the LFO by one octave).\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    taptempo   = G1 # steady clock here}    taptempo   = G1 # steady clock here\n\\immediate\\write\\patchexamples{    rate       = @1V # run at half clock speed}    rate       = -1V # run at half clock speed\n\\immediate\\write\\patchexamples{    sawtooth   = O2}    sawtooth   = O2\n\\end{droidini}\n\nAnd even {\\t hz} can be used in combination. Now the speed of the taptempo\nis multiplied with the value of {\\t hz}. Otherwise stated: 1~Hz is the reference.\nThe following sets the LFO's frequency to three times the tap tempo:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    taptempo = G1}    taptempo = G1\n\\immediate\\write\\patchexamples{    hz = 3}    hz = 3\n\\immediate\\write\\patchexamples{    sawtooth = O2}    sawtooth = O2\n\\end{droidini}\n\n\\subsubsection*{Hz vs BPM}\n\nSometimes people ask for help converting BPM into Hz or vice versa.  And some\neven express their unhappyness about the fact that the Droid uses Hz\nrather than BPM. Well -- that decision was made because in general I see\nthe LFO rather as an oscillator than as a clock. And for oscillators Hz is\nthe usual way to measure the speed or frequency.\n\nSo when you use an LFO as your master clock, how can you convert specify\nBPM as Hz?  {\\bf Simply divide your BPM by 15} to get the correct value for {\\t\nhz}. So 120~BPM would be {\\t hz = 8}.\n\nThat sounds surprising, since Hz means {\\it oscillations per second} and\nBPM {\\it beats per minute}. The point is: BPM means {\\it beats} per minute,\nnot clock ticks per minute. In a modular environment it is most common to run\nyour clock at \\nth{16} notes. And the ``beat'' in BPM refers to {\\it quarter}\nnotes. For playing one quarter note we need to play four \\nth{16} notes,\nso after dividing by 60 to convert minutes into seconds, we need to multiply\nby 4, to convert quarters into \\nth{16}s.\n\nThat -- of course -- assumes that your master clock is running at \\nth{16}\nnotes, sometimes written as 4~PPQN (4 pulses per quarter note).\n\n\n\n\n\n\n\\subsubsection*{Randomization}\n\nRandomization is an experimental new feature that combines random voltages\nwith an LFO. If you turn this parameter up, then for each ``hill'' of the\noutput waveform has a different height. The parameter {\\t randomize} controls\nhow strong that effect is. With {\\t 0.0} randomization is turned off.\nAt {\\t 1.0} it is at its strongest and the random level of each hill is\nin the range 0.0 \\dots\\ 1.0.\n\nHere is an example of a randomized sine wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz        = 0.5}    hz        = 0.5\n\\immediate\\write\\patchexamples{    randomize = 0.8}    randomize = 0.8\n\\immediate\\write\\patchexamples{    sine      = O1}    sine      = O1\n\\end{droidini}\n\nThe original wave if printed \\textcolor{blue!20!white}{\\bf light} and the\nand the randomized wave at output {\\t O1} is \\textcolor{magenta}{\\bf magenta}:\n\n\n\\begin{lfounipolar}{6}\n\\addplot [domain=0:8,color=blue!20!white,samples=100] {sin(x * 180) + 1) * 5};\n\\addplot [domain=-0.5:1.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 9.5};\n\\addplot [domain=1.5:3.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 4};\n\\addplot [domain=3.5:5.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 6};\n\\addplot [domain=5.5:7.5,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 2};\n\\addplot [domain=7.5:8,color=magenta,samples=100] {(sin(x * 180) + 1) * 0.5 * 7};\n\\end{lfounipolar}\n\nPlease note: If you turn {\\t bipolar} on, then a ``hill'' is considered\nto be something {\\it above} or {\\it below} the zero line. That means that\nnow the sine wave has twice as much hills and the randomization works\ndifferent. Here is an example patch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz        = 0.5}    hz        = 0.5\n\\immediate\\write\\patchexamples{    randomize = 0.8}    randomize = 0.8\n\\immediate\\write\\patchexamples{    sine      = O1}    sine      = O1\n\\immediate\\write\\patchexamples{    bipolar   = 1}    bipolar   = 1\n\\end{droidini}\n\nAnd this is how the output looks like:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (sec)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 6, ymin = -10, ymax = 10,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n]\n\\addplot [domain=0:8,color=blue!20!white,samples=100] {sin(x * 180) * 10};\n\\addplot [domain=0:1,color=magenta,samples=100] {sin(x * 180) * 9.5};\n\\addplot [domain=1:2,color=magenta,samples=100] {sin(x * 180) * 3.5};\n\\addplot [domain=2:3,color=magenta,samples=100] {sin(x * 180) * 4};\n\\addplot [domain=3:4,color=magenta,samples=100] {sin(x * 180) * 2};\n\\addplot [domain=4:5,color=magenta,samples=100] {sin(x * 180) * 6};\n\\addplot [domain=5:6,color=magenta,samples=100] {sin(x * 180) * 7};\n\\addplot [domain=6:7,color=magenta,samples=100] {sin(x * 180) * 2};\n\\addplot [domain=7:8,color=magenta,samples=100] {sin(x * 180) * 8};\n\\end{axis}\n\\end{tikzpicture}\n\nNote: Since not all waveform have there ``hills'' at the same place and the\nstart and end of a hill might even be affected by {\\t skew} or {\\t pulsewidth},\neach waveform output has its own independent randomization. Therefore\n{\\t cosine} is {\\it not} the phase shifted output of {\\t sine} anymore,\nif you use randomization.\n\n\\subsubsection*{Wave form selection and morphing}\n\nAs an alternative to the seven indiviual waveform outputs there is a common\noutput simply called {\\t output}. The waveform can be selected with the\ninput {\\t waveform} and defaults to {\\t 0}, which means {\\it square wave}.\nSo for a simple clock you can write:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    output = G1}    output = G1\n\\end{droidini}\n\nA triangle wave is selected with the code {\\t 2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 2}    hz = 2\n\\immediate\\write\\patchexamples{    output = G1}    output = G1\n\\immediate\\write\\patchexamples{    waveform = 2}    waveform = 2\n\\end{droidini}\n\nHere is the complete list of available waveforms:\n\n\\begin{tabular}{|l|l|} \\hline\n \\t 0 & square  \\\\ \\hline\n \\t 1 & sawtooth \\\\ \\hline\n \\t 2 & triangle \\\\ \\hline\n \\t 3 & ramp \\\\ \\hline\n \\t 4 & paraboloid \\\\ \\hline\n \\t 5 & sine \\\\ \\hline\n \\t 6 & cosine \\\\  \\hline\n\\end{tabular}\n\nIt is allowed to use non-integer values, like {\\t 0.5}. This will create a mixture\nbetween two adjacent waveforms -- while respecting the ratio. For example {\\t 2.1}\nwill select 90\\% triangle and 10\\% ramp. That way you can smoothly morph through\nthe available waveforms. Here is an example. Let's start with {\\t waveform = 0.0},\nwhich gives a plain square wave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 0.0}    waveform = 0.0\n\\end{droidini}\n\nAnd this is what it looks like:\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,10) (0.5,10) (0.5,0) (1.0,0)\n    (1,10) (1.5,10) (1.5,0) (2.0,0)\n    (2,10) (2.5,10) (2.5,0) (3.0,0)\n    (3,10) (3.5,10) (3.5,0) (4.0,0)\n};\n\\end{lfounipolar}\n\nAt {\\t 1.0} we get a saw tooth:\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 1.0}    waveform = 1.0\n\\end{droidini}\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,0) (1,10)\n    (1,0) (2,10)\n    (2,0) (3,10)\n    (3,0) (4,10)\n};\n\\end{lfounipolar}\n\nAnd in between -- at {\\t 0.5} -- we get some\nmixture:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    waveform = 0.5}    waveform = 0.5\n\\end{droidini}\n\n\\begin{lfounipolar}{4}\n\\addplot [domain=0:4,color=blue]\ncoordinates {\n    (0,5.0) (0.25,6.25) (0.5, 7.5) (0.5, 2.5) (0.75, 3.75) (1.0, 5.0)\n    (1,5.0) (1.25,6.25) (1.5, 7.5) (1.5, 2.5) (1.75, 3.75) (2.0, 5.0)\n    (2,5.0) (2.25,6.25) (2.5, 7.5) (2.5, 2.5) (2.75, 3.75) (3.0, 5.0)\n    (3,5.0) (3.25,6.25) (3.5, 7.5) (3.5, 2.5) (3.75, 3.75) (4.0, 5.0)\n};\n\\end{lfounipolar}\n\n\n\n\\pagebreak", "inputs": [{"name": "rate", "type": "cv", "default": "0", "description": "Frequency control: The default frequency of the LFO is 1~Hz\n(one cycle per second). Each volt doubles\nthe frequency. So an input of 1~V (a number of {\\t 0.1}) speeds up\nthe LFO to 2~Hz, 2~V ({\\t 0.2}) create 4~Hz and\nso on. On the other hand negative voltages reduce the speed, so\n-1~V ({\\t -0.1}) will give 0.5~Hz and so on.\n", "essential": 0, "ramsize": 12}, {"name": "taptempo", "type": "trigger", "default": null, "description": "Feed a reference clock here and the LFO will run at the speed of\nthat clock -- albeit optionally modified by {\\t rate} and {\\t hz}.\nPlease see page \\pageref{taptempo} for details on using\n{\\t taptempo} inputs.\n", "essential": 0, "ramsize": 30}, {"name": "hz", "type": "cv", "default": "1", "description": "Set the frequency in Hz directly by setting a number here. Note:\nyou cannot use {\\t hz} at that same time as {\\t taptempo}. But\nboth can be combined with {\\t rate}.\n", "essential": 2, "ramsize": 12}, {"name": "level", "type": "cv", "default": "1", "description": "The maximum positive output level of the LFO. The default of {\\t 1.0}\nmeans a swing between 0~V and 10~V -- unless you enable {\\t bipolar},\nin which case it moves from -10~V to 10~V.\n", "essential": 1, "ramsize": 12}, {"name": "randomize", "type": "fraction", "default": "0", "description": "Randomization is an experimental new feature that combines random\nvoltages with an LFO. If you turn this parameter up, then for each\n{\\it hill} of the LFO's waveform output a new random attenuation is being chosen\nand multiplied with the current level. The result is an output,\nwhere each cycle of the waveform has a different level.\n", "essential": 0, "ramsize": 12}, {"name": "offset", "type": "cv", "default": "0", "description": "The output of the LFO is shifted by that voltage right before\nthe output. This is the same as adding or mixing a\nfixed voltage to the output. Not very fancy, but practical if\nyou want to output a modulation voltage within a certain range.\n", "essential": 0, "ramsize": 12}, {"name": "bipolar", "type": "gate", "default": "0", "description": "If this switch is set to {\\t on}, then the LFO will output a full\nswing from -{\\t level} to +{\\t level}. When set to {\\t off} it will swing\nbetween 0V and +{\\t level}.\n", "essential": 1, "ramsize": 12}, {"name": "phase", "type": "fraction", "default": "0", "description": "Shift the LFOs phase by this value. A value of {\\t 0.0} leaves the LFO\nrun in its normal phase. {\\t 0.5} will shift bei $180^\\circ$.\nAnd {\\t 1.0} will shift by a complete phase of $360^\\circ$, which\nis the same as {\\t 0.0}.\n", "essential": 0, "ramsize": 12}, {"name": "pulsewidth", "type": "bipolar", "default": "0.5", "description": "This sets the pulse width of the square LFO and only affects the\noutput {\\t square}. It ranges from {\\t 0.0} to {\\t 1.0}. Please note that\na pulse width of exactly 0.0 or 1.0 will make the output stick\nto the respective lower or upper level.\n", "essential": 0, "ramsize": 12}, {"name": "skew", "type": "bipolar", "default": "0.5", "description": "Modifies the symmetry of the triangle output by shifting the\n``peak'' of the triangle left and right. The default of {\\t 0.5}\ncreates a symmetric waveform. Smaller values speed up the rising\npart of the triangle and create more and more a ramp like waveform\nuntil a skew of {\\t 0.0} creates an exact ramp -- just the same as\nthe {\\t ramp} output. A skew of {\\t 1.0} create a sawtooth waveform.\n", "essential": 0, "ramsize": 12}, {"name": "sync", "type": "trigger", "default": null, "description": "A positive trigger edge at this input will reset the LFO. It will\nforce to restart the waveform at its ``beginning''. By using the\ninput {\\t syncphase} you can change that behaviour.\n", "essential": 0, "ramsize": 16}, {"name": "syncphase", "type": "fraction", "default": "0", "description": "This input changes the behaviour of the {\\t sync} input. I changes\nthe phase the waveform restarts at when it receives a sync trigger.\nE.g. by setting this to {\\t 0.5} a sync trigger will restart the waveform\nright at its middle. This is an interesting feature that cannot be\nfound in analog LFOs since it would be very hard to build in actual\ncircuits.\n", "essential": 0, "ramsize": 12}, {"name": "waveform", "type": "cv", "default": "0", "description": "If you use {\\t output} -- rather than the individual waveform outputs like\n{\\t square}, {\\t saw} and so on -- this input selects the Wave form. An integer\nnumber from {\\t 0} to {\\t 6} selects one of the seven available waveforms. Any number\nin between selects a mixture of the two neighboring waveforms. That way you can smoothly\nmorph through all the available waveforms. The codes for the waveforms are:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{square}\n\\jacktablerow{1}{sawtooth}\n\\jacktablerow{2}{triangle}\n\\jacktablerow{3}{ramp}\n\\jacktablerow{4}{paraboloid}\n\\jacktablerow{5}{sine}\n\\jacktablerow{6}{cosine}\n\\end{tabular}\n\\medskip\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Main output of the LFO.\n", "essential": 0, "ramsize": 4}, {"name": "square", "type": "cv", "default": null, "description": "A square waveform -- modified by {\\t pulsewidth}.\n", "essential": 2, "ramsize": 4}, {"name": "sawtooth", "type": "cv", "default": null, "description": "Outputs a sawtooth waveform -- i.e. a rising ramp\n", "essential": 1, "ramsize": 4}, {"name": "triangle", "type": "cv", "default": null, "description": "Outputs a triangle waveform -- modified by {\\t skew}.\n", "essential": 1, "ramsize": 4}, {"name": "ramp", "type": "cv", "default": null, "description": "Outputs a falling ramp -- like a sawtooth that is mirrored. Note:\nif the LFO is set to bipolar then this is the negation of {\\t sawtooth}.\nIf it is set to unipolar then this is not the case. The waveform\nwill be positive then!\n", "essential": 1, "ramsize": 4}, {"name": "paraboloid", "type": "cv", "default": null, "description": "An experimental waveform that looks very similar to a sine\nwave but is derived from a triangle by computing the square\nof each waypoint's distance to {\\t level}.\n", "essential": 0, "ramsize": 4}, {"name": "sine", "type": "cv", "default": null, "description": "A sine waveform.\n", "essential": 1, "ramsize": 4}, {"name": "cosine", "type": "cv", "default": null, "description": "A sine waveform shifted by $90^\\circ$. This output is for your\nconvenience and avoids needing two LFO circuits in cases where you\nwant to make quadrature applications. Please note that $180^\\circ$\nand $270^\\circ$ can easily be achieved by negating the outputs {\\t sine}\nand {\\t cosine} at a later stage.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 163, "ramsize": 216}, "logic": {"category": "logic", "title": " Logic operations utility", "description": "Utility circuit for logic operations on gate signals. It can do\noperations like AND, OR, NAND, NOR, etc.\n\n\\subsubsection*{Basic operation}\n\nIn this example we do an {\\t and} operation.\n{\\t O1} will output 1 ({\\t on}) if all of {\\t I1}, {\\t I2}\nand {\\t I3} see {\\t on} (voltage above 1~V):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    and     = O1}    and     = O1\n\\end{droidini}\n\nHere is how to do a logic negate of a signal:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    negated = O1}    negated = O1\n\\end{droidini}\n\nIf you do not like the 1~V threshold, you can change it:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input     = I1}    input     = I1\n\\immediate\\write\\patchexamples{    negated   = O1}    negated   = O1\n\\immediate\\write\\patchexamples{    threshold = 5V}    threshold = 5V\n\\end{droidini}\n\n\\subsubsection*{Doing logic without this circuit}\n\nPlease note, that many times when you think you need the logic circuit\nyou can do the same much simpler. Here is an example, where you use\na toggle button to switch on a clock, which is sent to output {\\t O1}.\nThe idea is to make an AND combination of the clock signal and the\nbutton state:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz     = 2}    hz     = 2\n\\immediate\\write\\patchexamples{    square = _LFO}    square = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[logic]}[logic]\n\\immediate\\write\\patchexamples{    input1 = L1.1}    input1 = L1.1\n\\immediate\\write\\patchexamples{    input2 = _LFO}    input2 = _LFO\n\\immediate\\write\\patchexamples{    and    = O1}    and    = O1\n\\end{droidini}\n\nWhile this works pretty well, here is a solution that makes use of the\nfact, that the {\\it multiplication} of two gate signals is in fact\na kind of AND combination, since $A \\times B$ is just 1, if $A$ {\\it and}\n$B$ are 1 and 0 otherwise:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz     = 2}    hz     = 2\n\\immediate\\write\\patchexamples{    square = _LFO}    square = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input  = _LFO * L1.1}    input  = _LFO * L1.1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nYou even can avoid the Copy-circuit if you make use of the {\\t level} input\nof the LFO, since setting the level to 0 disables it:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button  = B1.1}    button  = B1.1\n\\immediate\\write\\patchexamples{    led     = L1.1}    led     = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz      = 2}    hz      = 2\n\\immediate\\write\\patchexamples{    square  = _LFO}    square  = _LFO\n\\immediate\\write\\patchexamples{    level   = L1.1}    level   = L1.1\n\\end{droidini}\n\n\\columnbreak\n\nAnother nice solution is to make use of {\\t offvalue} and {\\t onvalue} of\nthe {\\t button} circuit. {\\t offvalue} is 0 per default, so we just need to\ndefine {\\t onvalue}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz       = 2}    hz       = 2\n\\immediate\\write\\patchexamples{    square   = _LFO}    square   = _LFO\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button   = B1.1}    button   = B1.1\n\\immediate\\write\\patchexamples{    led      = L1.1}    led      = L1.1\n\\immediate\\write\\patchexamples{    onvalue  = _LFO}    onvalue  = _LFO\n\\end{droidini}\n\nIf you need to combine two gates in order to create a common gate\npattern, you can use {\\it addition} -- which is very similar to\na logic OR combination. The following example creates two overlayed\neuclidean rhythms:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    length = 16}    length = 16\n\\immediate\\write\\patchexamples{    beats  = 3}    beats  = 3\n\\immediate\\write\\patchexamples{    output = _E1}    output = _E1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    length = 13}    length = 13\n\\immediate\\write\\patchexamples{    beats  = 2}    beats  = 2\n\\immediate\\write\\patchexamples{    output = _E2}    output = _E2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[copy]}[copy]\n\\immediate\\write\\patchexamples{    input  = _E1 + _E2}    input  = _E1 + _E2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNote: When both {\\t \\_E1} and {\\t \\_E2} are 1 at the same\ntime, the sum is 2, of course. This does not matter, since the\noutput voltage is capped at 10~V ({\\t 1.0}) anyway.\n\n\\clearpage", "inputs": [{"prefix": "input", "name": "input1 ... input8", "count": 8, "start_at": 1, "type": "gate", "default": "unpatched", "description": "\\nth1 ... \\nth8 input. Note: this input is declared as a \\gatesymbol gate input, but\nin fact you can use it as a CV input in combination with various or random values set\nfor the {\\t threshold}.\n", "essential": 2, "essential_count": 2, "ramsize": 12}, {"name": "threshold", "type": "cv", "default": "0.1", "description": "Input values at, or above this threshold value, are considered high or {\\t on}.\nThe default is {\\t 0.1} which corresponds to an input voltage of 1~V. You can get\ninteresting results when both the inputs are variable CVs (like from LFOs) and this\nthreshold is being modulated as well.\n", "essential": 0, "ramsize": 12}, {"name": "lowvalue", "type": "cv", "default": "0", "description": "Output value that is output for logic low, false or {\\t off}.\n", "essential": 0, "ramsize": 12}, {"name": "highvalue", "type": "cv", "default": "1", "description": "Output value that is output for a logic high, true or {\\t on}.\n", "essential": 0, "ramsize": 12}, {"name": "countvalue", "type": "cv", "default": "0.1", "description": "Value added to the {\\t count} output for each input with a high level\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "and", "type": "cv", "default": null, "description": "A logic AND operation on all patched inputs:\nThis output is set to {\\t highvalue} if all inputs are high (i.e. at least\n{\\t threshold}), else {\\t lowvalue}\n", "essential": 1, "ramsize": 4}, {"name": "or", "type": "cv", "default": null, "description": "A logic OR operation on all patched inputs:\nThis output is set to {\\t highvalue} if at least one of the inputs is high\n", "essential": 1, "ramsize": 4}, {"name": "xor", "type": "cv", "default": null, "description": "Exclusive OR: This is high, if the number of high inputs is odd! This means\nthat any change in one of the inputs will also change the output.\n", "essential": 0, "ramsize": 4}, {"name": "nand", "type": "cv", "default": null, "description": "Like AND but the outcome is negated.\n", "essential": 0, "ramsize": 4}, {"name": "nor", "type": "cv", "default": null, "description": "Like OR but the outcome is negated.\n", "essential": 0, "ramsize": 4}, {"name": "negated", "type": "cv", "default": null, "description": "Logical negate of {\\t input1} (which can abbreviated as {\\t input}). Note:\nThe inputs {\\t input2} ... {\\t input7} are ignored here. Another note:\nIf you use {\\t input1} anyway, {\\t negated} always outputs exactly the\nsame as {\\t nand} and {\\t nor}. It's just more convenient to write and easier\nto understand. Hence a dedicated output for a logic negate.\n", "essential": 1, "ramsize": 4}, {"name": "count", "type": "integer", "default": null, "description": "Adds {\\t countvalue} to this output for each input that is high.\n", "essential": 1, "ramsize": 4}, {"name": "countlow", "type": "cv", "default": null, "description": "Adds {\\t countvalue} to this output for each input that is low.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 169, "ramsize": 56}, "math": {"category": "logic", "title": " Math utility circuit", "description": "This circuit provides mathematic operations. Some of these use {\\t input1}\n{\\it and} {\\t input2} -- such as {\\t sum} or {\\t product}.  Other ones just use\n{\\t input1} (which can be abbreviated as {\\t input}) -- such as {\\t negation}\nor {\\t reciprocal}.\n\nExample for computing the quotient $\\frac{\\t I1}{\\t I2}$:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input1   = I1}    input1   = I1\n\\immediate\\write\\patchexamples{    input2   = I2}    input2   = I2\n\\immediate\\write\\patchexamples{    quotient = O1}    quotient = O1\n\\end{droidini}\n\nExample for computing the square root of {\\t I1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    root    = O1}    root    = O1\n\\end{droidini}\n\nNote: As long as you do not send a value directly to an output like {\\t O1},\nthe range of the value is not limited by this circuit. You can generate almost arbitrary\nsmall or large positive and negative numbers. When you send a value to\nan output, it will be truncated into the range -1 ... +1 (which corresonds\nto -10~V ... +10~V).\n\n\\subsubsection*{Unused inputs}\n\nWhen you don't use both inputs for an operation that usually needs to values,\nthe omitted input will make the operation ``neutral''. For example in the\nmultiplication an omitted input will be treated as {\\t 1.0} where as in the sum\nit defaults to {\\t 0.0}. This is useful when you want to temporarily\ndisable a line in your patch. Consider the following patch, which multiplies\nthe incoming CV from {\\t I1} with the pot value of {\\t P1.2} and outputs\nit to {\\t O1}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = P1.2}    input2 = P1.2\n\\immediate\\write\\patchexamples{    product = O1}    product = O1\n\\end{droidini}\n\nIf you now remove the line with {\\t input2}, the output\nwill simply copy the input, not set it to 0:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[math]}[math]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    # input2 = P1.2}    # input2 = P1.2\n\\immediate\\write\\patchexamples{    product = O1 # will be set to I1, not 0}    product = O1 # will be set to I1, not 0\n\\end{droidini}", "inputs": [{"prefix": "input", "name": "input1, input2", "count": 2, "start_at": 1, "type": "cv", "default": null, "description": "The two inputs\n", "essential": 2, "essential_count": 2, "ramsize": 12}], "outputs": [{"name": "sum", "type": "cv", "default": null, "description": "${\\t input1} + {\\t input2}$\n", "essential": 1, "ramsize": 4}, {"name": "difference", "type": "cv", "default": null, "description": "${\\t input1} - {\\t input2}$\n", "essential": 1, "ramsize": 4}, {"name": "product", "type": "cv", "default": null, "description": "${\\t input1} \\times {\\t input2}$\n", "essential": 1, "ramsize": 4}, {"name": "quotient", "type": "cv", "default": null, "description": "${\\t input1}\\ /\\ {\\t input2}$. If {\\t input2} is zero, a very\nlarge number will be returned, while the correct sign is being\nkept. This is mathematically not correct but more useful than any\nother possible result.\n", "essential": 1, "ramsize": 4}, {"name": "modulo", "type": "cv", "default": null, "description": "{\\t input1} modulo {\\t input2}. This needs some explanation: With\nthis operation you can ``fold'' the value from {\\t input1} into the\nrange 0 ... {\\t input2}. For example if {\\t input2} is 1~V, the\noutput will convert 1.234~V to 0.234~V, -2.1~V to 0.9~V and 0.5~V\nto 0.5~V. If {\\t input2} is zero or negative, the output will be zero.\n", "essential": 0, "ramsize": 4}, {"name": "power", "type": "cv", "default": null, "description": "{\\t input1} to the power of {\\t input2}. Please note that the\npower has several cases where it is not defined when either\nthe base or the exponent is zero or less than zero. In order to\nbe as useful for your music making as possible the {\\t math} circuit behaves\nin the following way:\n\n\\begin{itemize}\n\\item If ${\\t input1} < 0$, {\\t input2} is rounded to the nearest integer.\n\\item If ${\\t input1} = 0$ and ${\\t input2} < 0$, a very large number is output.\n\n\\end{itemize}\n", "essential": 0, "ramsize": 4}, {"name": "average", "type": "cv", "default": null, "description": "The average of {\\t input1} and {\\t input2}\n", "essential": 0, "ramsize": 4}, {"name": "maximum", "type": "cv", "default": null, "description": "The maximum of {\\t input1} and {\\t input2}\n", "essential": 0, "ramsize": 4}, {"name": "minimum", "type": "cv", "default": null, "description": "The minimum of {\\t input1} and {\\t input2}\n", "essential": 0, "ramsize": 4}, {"name": "negation", "type": "cv", "default": null, "description": "$- {\\t input1}$\n", "essential": 0, "ramsize": 4}, {"name": "reciprocal", "type": "cv", "default": null, "description": "$1\\ /\\ {\\t input1}$. If {\\t input1} is zero, a very large number\nis being output, while the sign is being kept.\n", "essential": 0, "ramsize": 4}, {"name": "amount", "type": "cv", "default": null, "description": "The absolute value of {\\t input1}\n(i.e. $-  {\\t input1}$ if ${\\t input1} < 0$, else {\\t input1})\n", "essential": 0, "ramsize": 4}, {"name": "sine", "type": "cv", "default": null, "description": "The sine of {\\t input1} in a way, the input range of 0.0 \\dots\\ 1.0\ngoes exactly through one wave cycle. Or more mathematically expressed:\n$sin(2\\pi \\times {\\t input1})$.\n", "essential": 0, "ramsize": 4}, {"name": "cosine", "type": "cv", "default": null, "description": "The cosine of {\\t input1} in a way, the input range of 0.0 \\dots\\ 1.0\ngoes exactly through one wave cycle. Or more mathematically expressed:\n$cos(2\\pi \\times {\\t input1})$.\n", "essential": 0, "ramsize": 4}, {"name": "square", "type": "cv", "default": null, "description": "${\\t input1}^2$\n", "essential": 0, "ramsize": 4}, {"name": "root", "type": "cv", "default": null, "description": "$\\sqrt{\\t input1}$. Please note that you cannot compute the square\nroot of a negative number. In order to output something useful anyway,\nthe result will be $- \\sqrt{- {\\t input1}}$, if ${\\t input1} < 0$.\n", "essential": 0, "ramsize": 4}, {"name": "logarithm", "type": "cv", "default": null, "description": "The natural logarithm of {\\t input1}: $ln\\ _{{\\t input1}}$. The\nlogarithm is only defined for positive numbers. {\\t mathcircuit}\nbehaves like this:\n\n\\begin{itemize}\n\\item If ${\\t input1} = 0$, a negative very large number is output.\n\\item If ${\\t input2} < 0$, $- ln\\ _{- {\\t input1}}$ is output.\n\\end{itemize}\n", "essential": 0, "ramsize": 4}, {"name": "round", "type": "cv", "default": null, "description": "The integer number nearest to {\\t input1}\n", "essential": 0, "ramsize": 4}, {"name": "floor", "type": "cv", "default": null, "description": "The largest integer number that is not greater than {\\t input1}\n", "essential": 0, "ramsize": 4}, {"name": "ceil", "type": "cv", "default": null, "description": "The smallest integer number that is not less than {\\t input1}\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 172, "ramsize": 64}, "matrixmixer": {"category": "cv", "title": " Matrix mixer for CVs", "description": "This circuit is a 4$\\times$4 matrix mixer with four inputs and four outputs\nthat is operated by push buttons. Each of the 16 matrix nodes has a toggle\nbutton for adding or removing one specific input to or from one specific\noutput. The mixing is always done with unity gain. This means that each\noutput is the sum of all inputs that are enabled on its path.\n\nThe following picture shows a matrix with the four inputs {\\t I1} \\dots\\ {\\t I4}\nand the four outputs {\\t O1} \\dots\\ {\\t O4}. As you can see\nthe button 23 mixes input 2 to output 3.\n\nIf you have not pushed any buttons yet, the mixer enables four buttons\nin a diagonal so that inputs {\\t I1} is connected to output {\\t O1}\nand so on:\n\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.8cm,\n                    semithick]\n  \\tikzstyle{every state}=[fill=lightgray,draw=none,text=white]\n  \\tikzstyle{on}=[fill=black,draw=black,text=white]\n  \\tikzstyle{jacks}=[fill=white,draw=black,text=black]\n\n  \\node[state,jacks] (I1)       {\\t I1};\n  \\node[state,on] (B11) [right of=I1]  {11};\n  \\node[state] (B12) [right of=B11] {12};\n  \\node[state] (B13) [right of=B12] {13};\n  \\node[state] (B14) [right of=B13] {14};\n\n  \\node[state,jacks] (I2) [below of=I1]  {\\t I2};\n  \\node[state] (B21) [right of=I2]  {21};\n  \\node[state,on] (B22) [right of=B21] {22};\n  \\node[state] (B23) [right of=B22] {23};\n  \\node[state] (B24) [right of=B23] {24};\n\n  \\node[state,jacks] (I3) [below of=I2]  {\\t I3};\n  \\node[state] (B31) [right of=I3]  {31};\n  \\node[state] (B32) [right of=B31] {32};\n  \\node[state,on] (B33) [right of=B32] {33};\n  \\node[state] (B34) [right of=B33] {34};\n\n  \\node[state,jacks] (I4) [below of=I3]  {\\t I4};\n  \\node[state] (B41) [right of=I4]  {41};\n  \\node[state] (B42) [right of=B41] {42};\n  \\node[state] (B43) [right of=B42] {43};\n  \\node[state,on] (B44) [right of=B43] {44};\n\n  \\node[state,jacks] (O1) [below of=B41] {\\t O1};\n  \\node[state,jacks] (O2) [below of=B42] {\\t O2};\n  \\node[state,jacks] (O3) [below of=B43] {\\t O3};\n  \\node[state,jacks] (O4) [below of=B44] {\\t O4};\n\n  \\path\n        (I1)  edge node {} (B11)\n        (B11) edge node {} (B12)\n        (B12) edge node {} (B13)\n        (B13) edge node {} (B14)\n\n        (B11) edge node {} (B21)\n        (B12) edge node {} (B22)\n        (B13) edge node {} (B23)\n        (B14) edge node {} (B24)\n\n        (I2)  edge node {} (B21)\n        (B21) edge node {} (B22)\n        (B22) edge node {} (B23)\n        (B23) edge node {} (B24)\n\n        (B21) edge node {} (B31)\n        (B22) edge node {} (B32)\n        (B23) edge node {} (B33)\n        (B24) edge node {} (B34)\n\n        (I3)  edge node {} (B31)\n        (B31) edge node {} (B32)\n        (B32) edge node {} (B33)\n        (B33) edge node {} (B34)\n\n        (B31) edge node {} (B41)\n        (B32) edge node {} (B42)\n        (B33) edge node {} (B43)\n        (B34) edge node {} (B44)\n\n        (I4)  edge node {} (B41)\n        (B41) edge node {} (B42)\n        (B42) edge node {} (B43)\n        (B43) edge node {} (B44)\n\n        (B41) edge node {} (O1)\n        (B42) edge node {} (O2)\n        (B43) edge node {} (O3)\n        (B44) edge node {} (O4)\n\n\n        ;\n\\end{tikzpicture}\n\nAs an alternative operation, instead of summing the enabled signals you\ncan compute the {\\it maximum} signal. This is useful when combining\nenvelope signals -- e.g. from different rhythmic patterns.\nAdding envelope signals would either make them ``too loud'' or even\ndistort them.\n\nThe current state of the sixteen buttons is saved in the \\droid's\ninternal flash memory.\n\nOf course it is possible to use a smaller part of the matrix, e.g.  just\n3$\\times$2, simply by not patching the according inputs, outputs and buttons.\nHere is an example of a 3$\\times$2 mixer:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[matrixmixer]}[matrixmixer]\n\\immediate\\write\\patchexamples{    input1   = I1}    input1   = I1\n\\immediate\\write\\patchexamples{    input2   = I2}    input2   = I2\n\\immediate\\write\\patchexamples{    input3   = I3}    input3   = I3\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    button11 = B1.1}    button11 = B1.1\n\\immediate\\write\\patchexamples{    button12 = B1.2}    button12 = B1.2\n\\immediate\\write\\patchexamples{    button21 = B2.1}    button21 = B2.1\n\\immediate\\write\\patchexamples{    button22 = B1.3}    button22 = B1.3\n\\immediate\\write\\patchexamples{    button31 = B1.4}    button31 = B1.4\n\\immediate\\write\\patchexamples{    button32 = B2.3}    button32 = B2.3\n\\immediate\\write\\patchexamples{    led11    = L1.1}    led11    = L1.1\n\\immediate\\write\\patchexamples{    led12    = L1.2}    led12    = L1.2\n\\immediate\\write\\patchexamples{    led21    = L2.1}    led21    = L2.1\n\\immediate\\write\\patchexamples{    led22    = L1.3}    led22    = L1.3\n\\immediate\\write\\patchexamples{    led31    = L1.4}    led31    = L1.4\n\\immediate\\write\\patchexamples{    led32    = L2.3}    led32    = L2.3\n\\end{droidini}\n\nThis matrix looks like this:\n\n\\begin{center}\n\n\\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.8cm,\n                    semithick]\n  \\tikzstyle{every state}=[fill=lightgray,draw=none,text=white]\n  \\tikzstyle{on}=[fill=black,draw=black,text=white]\n  \\tikzstyle{jacks}=[fill=white,draw=black,text=black]\n\n  \\node[state,jacks] (I1)       {\\t I1};\n  \\node[state,on] (B11) [right of=I1]  {11};\n  \\node[state] (B12) [right of=B11] {12};\n\n  \\node[state,jacks] (I2) [below of=I1]  {\\t I2};\n  \\node[state] (B21) [right of=I2]  {21};\n  \\node[state,on] (B22) [right of=B21] {22};\n\n  \\node[state,jacks] (I3) [below of=I2]  {\\t I3};\n  \\node[state] (B31) [right of=I3]  {31};\n  \\node[state] (B32) [right of=B31] {32};\n\n  \\node[state,jacks] (O1) [below of=B31] {\\t O1};\n  \\node[state,jacks] (O2) [below of=B32] {\\t O2};\n\n  \\path\n        (I1)  edge node {} (B11)\n        (B11) edge node {} (B12)\n\n        (B11) edge node {} (B21)\n        (B12) edge node {} (B22)\n\n        (I2)  edge node {} (B21)\n        (B21) edge node {} (B22)\n\n        (B21) edge node {} (B31)\n        (B22) edge node {} (B32)\n\n        (I3)  edge node {} (B31)\n        (B31) edge node {} (B32)\n\n        (B31)  edge node {} (O1)\n        (B32) edge node {} (O2)\n        ;\n\\end{tikzpicture}\n\\end{center}\n\n\\subsubsection*{Mixers with more inputs / outputs}\n\nThe four auxiliary inputs {\\t auxin1} \\dots\\ {\\t auxin4} can be\nused to create matrix mixers with more than four inputs. You\ncan create a mixer with 8 inputs and 4 outputs by sending the\nfour outputs of one matrix mixer into the four auxiliary inputs\nof a second one.\n\nIf you want to create a mixer with more than 4 {\\it outputs} then\nsimply use several mixers and feed the same inputs to all of them.", "inputs": [{"prefix": "input", "name": "input1 ... input4", "count": 4, "start_at": 1, "type": "cv", "default": "0", "description": "The up to four CV inputs that you want to mix\n", "essential": 2, "essential_count": 4, "ramsize": 12}, {"prefix": "auxin", "name": "auxin1 ... auxin4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "These auxiliary inputs will be mixed directly into the four\noutputs {\\t output1} \\dots\\ {\\t output4} and are used for\ncascading several matrix mixers into one with more than four\ninputs.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "mixmax", "type": "fraction", "default": "0", "description": "If this is {\\t 0.0}, normal mixing is done (the\nenabled inputs CVs will be added). At a value of {\\t 1.0}\ninstead each outputs is the maximum of the enabled inputs.\nAny number in between will create a weighted average between\nthese two values.\n", "essential": 0, "ramsize": 12}, {"name": "startvalue", "type": "integer", "default": "1", "description": "This input selects in which state the matrix begins\nlife. Also a trigger to {\\t clear} will create that starting state.\nThe following three configurations can be selected with {\\t startvalue}:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{All buttons are cleared.}\n\\jacktablerow{1}{The buttons on the diagonal are active.}\n\\jacktablerow{2}{All buttons are set.}\n\\end{tabular}\n\nWhen set to 1, {\\t input1} is sent to {\\t output1}, {\\t input2}\nto {\\t output2} and so on.\n", "essential": 0, "ramsize": 12}, {"prefix": "button1", "name": "button11 ... button14", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "These four buttons decide, to which of the four outputs {\\t input1}\nis being mixed.\n", "essential": 2, "essential_count": 4, "ramsize": 16}, {"prefix": "button2", "name": "button21 ... button24", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "These four buttons decide, to which of the four outputs {\\t input2}\nis being mixed.\n", "essential": 2, "essential_count": 4, "ramsize": 16}, {"prefix": "button3", "name": "button31 ... button34", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "These four buttons decide, to which of the four outputs {\\t input3}\nis being mixed.\n", "essential": 2, "essential_count": 4, "ramsize": 16}, {"prefix": "button4", "name": "button41 ... button44", "count": 4, "start_at": 1, "type": "gate", "default": null, "description": "These four buttons decide, to which of the four outputs {\\t input4}\nis being mixed.\n", "essential": 2, "essential_count": 4, "ramsize": 16}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output4", "count": 4, "start_at": 1, "type": "cv", "default": null, "description": "The four outputs\n", "essential": 2, "essential_count": 4, "ramsize": 4}, {"prefix": "led1", "name": "led11 ... led14", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "The LEDs in the buttons {\\t button11} \\dots {\\t button14}\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "led2", "name": "led21 ... led24", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "The LEDs in the buttons {\\t button21} \\dots {\\t button24}\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "led3", "name": "led31 ... led34", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "The LEDs in the buttons {\\t button31} \\dots {\\t button34}\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "led4", "name": "led41 ... led44", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "The LEDs in the buttons {\\t button41} \\dots {\\t button44}\n", "essential": 0, "essential_count": 0, "ramsize": 4}], "presets": 16, "manual": 174, "ramsize": 168}, "midifileplayer": {"category": "midi", "title": " MIDI file player", "description": "This circuit can read MIDI files from your Micro SD card and\n``play'' them by creating respective CVs for gate, pitch, velocity,\npitch bend and other outputs, which you can then route to synth voices\nin your modular -- or do other crazy stuff with that information.\n\nMIDI files are organized in tracks. Each circuit of this type can play\njust {\\it one track} at a time. If you want to play more tracks, use\nmore {\\t midifileplayer} circuits in parallel.\n\nJust as MIDI streams, MIDI files contain {\\it channel} information for\neach note and each controller event. These channels are currently completely\nignored. If you think you can convince me that this is bad and that you\nhave a useful interpretation of the channels within the scope of the\nMIDI file player, please let me know.\n\nSome limitations of the current implementation are:\n\n\\begin{itemize}\n\\item Just one track can be played at a time.\n\\item The maximum length of a track is 6000 bytes. Longer tracks cannot be\nloaded. Sorry. But this is quite long and is enough for approximately 1500 note events. Note: The size of the total file can be as large as you\nlike.\n\\item The channel information is ignored.\n\\item Some meta events such as program change, all notes off, etc. are not yet recognized. Many of them just make sense in MIDI streams, not in files, anyway.\n\\end{itemize}\n\nFeatures of the current implementation:\n\\begin{itemize}\n\\item Up to eight voices in parallel with flexible voice allocation algorithms\n\\item Support for velocity, pitch bend, mod wheel, and global volume\n\\item You can output the original MIDI clock from the file.\n\\item You can adjust the tempo continuously.\n\\item You can use external clocking (ignoring the tempo of the file).\n\\end{itemize}\n\n\\subsubsection*{Getting started}\n\nHere is the simplest possible example: Copy your MIDI file to the SD card\nand name it {\\t midi1.mid}. And here is the patch that plays the first\ntrack with a single voice:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\end{droidini}\n\nNow patch {\\t O1} to the 1V/Oct of a synth voice and {\\t O2} to its\ngate. This voice should then play the notes from the first track\nof the file.\n\nThe playback starts immediately when the DROID starts. Per default\nthe track is looped. You can restart the playback with the {\\t reset}\ninput. And the other way round: you get a trigger at {\\t endoftrack}\nwhen the playback of the track has finished.\n\n\\subsubsection*{Selecting file and track}\n\nYou can have more than one MIDI file on your SD card. The MIDI files on\nthe card must be named {\\t midi1.mid}, {\\t midi2.mid}, and so on. Gaps\nare allowed. You can have up to 9999 MIDI files that way. The last\none would have the name {\\t midi9999.mid}. Don't use leading zeroes!\nThe file {\\t midi0001.mid} cannot be played!\n\nYou can then select one of these files with the {\\t file} parameter,\nso e.g. {\\t file = 17} would play {\\t midi17.mid}. If you omit that, {\\t\nmidi1.mid} will be played. If no such file is present on the card, nothing\nwill be played.\n\nA MIDI file can contain several tracks. The {\\t track} parameter specifies\nthe number of the track in the file you want to play. Hereby only the non-empty\ntracks will be counted. This is important since many MIDI files have tracks\nthat just contain meta information and no note events.\n\nIf you omit the track number, the first non-empty track will be played.\nIf your track number is out of range, the last track in the file will be\nselected.\n\nThe parameters {\\t file} and {\\t track} are -- of course -- CV controllable.\nSo you can switch between files and tracks by means of buttons,\nswitches, external CV, you name it. Whenever the file or track changes,\n\\droid loads the selected track from the SD card into its memory. This is\nalso the case when the \\droid starts. Also a track change restarts playback.\n\nNote: loading a track from the SD card might take a couple of milliseconds.\nDuring that time \\droid won't run as usual. All inputs will be ignored\nand all outputs freeze. So switching at a high rate might lead to unexpected\nresults. If you need to have a playback started in perfect timing, use\nthe {\\t reset} input as an exact trigger. If you do not want to use a\ntrigger but rather a play/stop gate, you can use the {\\t speed} input for\nthat. Setting the speed to {\\t 0} stops playback and {\\t 1} starts it\nimmediately.\n\n\\subsubsection*{Polyphonic tracks}\n\nMIDI streams and files consist of {\\it note on} and {\\it note off} events.\nSo there is no length parameter in a note. It just contains the note number\n(in semitones) and a velocity. If the track contains situations where\na new note starts while another one is still on, the track is polyphonic, as\nyou need more than one synth voice to play correctly.\n\nThe MIDI file player allows you to define up to {\\it eight} voices\nfor playing notes. Each voice consists of a {\\t pitch}$X$ and a\n{\\t gate}$X$ output (and an optional {\\t velocity}$X$ output).\nBy patching these outputs the player knows how many voices are available.\n\nIf the number of simultaneous notes exceeds the number of attached voices,\nsome notes have to be cut off or completely omitted. You can flexibly change\nthe behaviour in such a situation. See the description of the parameter\n{\\t dropnotes} for details.\n\nHere is an example for playing with up to three voices:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    file = 2}    file = 2\n\\immediate\\write\\patchexamples{    track = 1}    track = 1\n\\immediate\\write\\patchexamples{    pitch1 = O1}    pitch1 = O1\n\\immediate\\write\\patchexamples{    pitch2 = O2}    pitch2 = O2\n\\immediate\\write\\patchexamples{    pitch3 = O3}    pitch3 = O3\n\\immediate\\write\\patchexamples{    gate1 = G1}    gate1 = G1\n\\immediate\\write\\patchexamples{    gate2 = G2}    gate2 = G2\n\\immediate\\write\\patchexamples{    gate3 = G3}    gate3 = G3\n\\end{droidini}\n\n\n\\subsubsection*{Speed and Clocking}\n\nA MIDI file contains absolute timing information of when to exactly play\nwhich note. For that purpose every note event in the file has a relative\n{\\it time stamp}, measured in {\\it ticks}. The player honors this information\nand plays the tracks exactly in their original speed... unless... you change\nit of course.\n\nTo do so you have two options. The first one is the {\\t speed} parameter.\nAt {\\t 1.0} you get the original playing speed. {\\t 0.5} will play at\nhalf the speed and {\\t 2.0} at the double speed. This can be mapped\nto a pot, of course (here I chose a range from 0 to 2):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    speed = P1.1 * 2}    speed = P1.1 * 2\n\\end{droidini}\n\nTurning the pot totally CCW will completely freeze the playback.\n\nIf you need the internal clock of the MIDI player in order to\nsynchronize with the rest of your patch, you can get two\nclocks running at different resolutions at the\ntwo outputs {\\t clockout} and {\\t midiclock}. See their descriptions\nbelow for details.\n\nThe second option is clocking the player externally. In that case the tempo\ninformation from the MIDI file is ignored. External clocking allows you to\nsynchronize the MIDI playback with the rest of your patch, which may contain\nadditional sequencers and stuff.  Patch your external clock into the {\\t clock}\ninput. Each clock will then play a \\nth{16} note's time equivalent of content:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\end{droidini}\n\nNote: this does {\\it not} mean that the notes are quantized to \\nth{16}\nnotes. You still have the complete resolution.\n\n\\subsubsection*{Other controls and parameters}\n\nMIDI files may contain information about pitch bend, a global volume (CC 7),\nthe mod wheel (CC 1) and velocity (per note). These are all available as CV\noutputs.  See the table of outputs for details. Most other CCs are currently\nnot available since they are very rarely used in MIDI files. Future versions\nof the MIDI file player might give access to these.\n\n\n\\subsubsection*{Error handling}\n\nWhen working with files, errors can happen. The MIDI file\nmight be missing, corrupted, whatever. In order to make life easier\nfor you, the MIDI file player can show you an error status at the\noutput {\\t error}. Write the error to an {\\t R} register that is free,\nthat will make one of the LEDs lit up and show an error color.\n\nThe following patch shows the errors at the LED of input 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midifileplayer]}[midifileplayer]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\immediate\\write\\patchexamples{    error = R1}    error = R1\n\\end{droidini}\n\nPlease see the table of outputs below for the various\nerrors and their color codes.\n\n\n\\clearpage", "inputs": [{"name": "file", "type": "integer", "default": "1", "description": "Number of the MIDI file to play. {\\t 7} will select {\\t midi7.mid}.\n", "essential": 2, "ramsize": 12}, {"name": "track", "type": "integer", "default": "1", "description": "Number of the track in the file to play, starting at 1. Empty\ntracks do not count. Any number smaller than 1 will be interpreted\nas one. If the number is too big, the last track in the file\nis played.\n", "essential": 0, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "Patch an external clock here and the MIDI file will be played\naccording to that clock. In order to be modular-friendly, this\nis {\\it not} a MIDI clock but one counting the sixteenth, which\nis typically the step resolution of analog sequencers. This clock\nis then internally multiplied in order to create the necessary\nresolution. Note: The input {\\t speed} has no effect when using\nan external clock.\n", "essential": 1, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here sets the play back position to the start.\n", "essential": 0, "ramsize": 16}, {"name": "loop", "type": "gate", "default": "1", "description": "When loop mode is active (set to {\\t 1}), the track will start\nover again immediately when it has reached its end. This is the\ndefault. Otherwise playback stops at the end of the track.\n", "essential": 0, "ramsize": 12}, {"name": "end", "type": "integer", "default": "unpatched", "description": "If you set this value, it defines the playing end of the track. This\nis set in quarters as counted from the start. Setting the end beyond the\nend of the track will insert some pause.\n", "essential": 0, "ramsize": 12}, {"name": "speed", "type": "cv", "default": "1", "description": "Change the relative speed of the playback with this setting. At {\\t 1}\nthe speed is unchanged. {\\t 1.5} makes the speed 50\\% faster,\n{\\t 0.5} plays at half speed. At {\\t 0} the playing is completely\nfrozen. Note: {\\t speed} is being ignored when using the input\n{\\t clock}.\n", "essential": 0, "ramsize": 12}, {"name": "channel", "type": "integer", "default": "unpatched", "description": "Only execute / play commands from a certain MIDI channel.\nThere are 16 MIDI channels. It ranges from {\\t 1}\nto {\\t 16}.\n", "essential": 1, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "If set to {\\t 1}, all pitch outputs will go to the CV\nselected for {\\t tuningpitch} (which defaults to 2~V),\nand all\ngate outputs will play gates at 120 BPM. This helps getting\nall attached voices tuned when working with many voices.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0.2", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "Transposes all output pitches by this value by adding\nthe value. So in order to transpose one octave\ndown, set this input to {\\t -1V} or {\\t -0.1}. Changes in the\ntransposition are immediately reflected, even for currently\nalready active notes.\n", "essential": 0, "ramsize": 12}, {"name": "holdvelocity", "type": "gate", "default": "0", "description": "If this is set to {\\t 1}, the velocity output for a voice\nwill not be affected by note off events. It's just altered\nat the beginning of new notes.\nThe velocity is kept after the note ends.\nThis way during the release phase of an envelope triggered\nby the gate, the original velocity still lasts on. In most cases\nthe note off velocity is set to 0, which would\nimmediately cut off the release phase when the velocity is patched\ninto a VCA.\n", "essential": 0, "ramsize": 12}, {"name": "pitchbendrange", "type": "voltperoctave", "default": "$\\frac{1}{6}$V", "description": "Sets the value to the desired maximum that {\\t pitchbend}\nshould output, and likewise it's negative counterpart at its minimum\nvalue. At the middle position it always outputs 0. This defaults\nto $\\frac{2}{12}$~V, which corresponds to one whole tone. Note:\nsetting this to a negative value is allowed and will invert\npitch bend.\n", "essential": 0, "ramsize": 12}, {"name": "bendpitch", "type": "gate", "default": "1", "description": "When set to {\\t 1} (which is the default), the pitch bend\nwill directly be applied to all output pitches. Alternatively\nyou can set it to {\\t 0} and use the output {\\t pitchbend},\nfor using it elsewhere.\n", "essential": 0, "ramsize": 12}, {"name": "roundrobin", "type": "gate", "default": "0", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t output1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophonic. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n", "essential": 0, "ramsize": 12}, {"name": "voiceallocation", "type": "integer", "default": "0", "description": "When the MIDI stream, at any given time, needs to play more notes\nthan you have voices assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{The oldest note will be cancelled (default)}\n\\jacktablerow{1}{The new note will not be played and simply be omitted}\n\\jacktablerow{2}{The lowest note will be cancelled}\n\\jacktablerow{3}{The highest note will be cancelled}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "notegap", "type": "cv", "default": "0", "description": "When your MIDI devices plays a note so ``long'' that it lasts\nexactly until the next note begins -- or if due to a lack of\nused pitch outputs one currently played note has to be replaced\nwith a new one, the {\\t gate} output will have no time to go\nlow for a sufficient time between the two notes. In effect it\nwon't trigger any envelope for the new note but will play ``legato''.\n\nIf you don't like this, you can use {\\t notegap}. This input specifies\na number of {\\bf milliseconds} that the gate will be forced down\nbefore the new note begins. This has the drawback of introducing some\nlatency, of course! So I suggest that you start with {\\t notegap =\n1} and then check out if your envelope is fast enough to trigger.\nIf not, increase the value.\n\nIf you are using \\droid's own {\\t contour} circuit or trigger something\nelse internally in your patch, you can use {\\t notegap = 0.1}. That is\nsufficient and introduces barely any latency.\nA value of {\\t 0.0} keeps the default of the legato mode.\n\nNote: the {\\t notegap} parameter does not affect the {\\t trigger}\noutputs.\n", "essential": 0, "ramsize": 12}, {"prefix": "ccnumber", "name": "ccnumber1 ... ccnumber4", "count": 4, "start_at": 1, "type": "integer", "default": "0", "description": "You can {\\it listen} to up to four CCs (control changes). For example\nif you are interested in the current value of CC\\#17, set\n{\\t ccnumber1 = 17} and use the output {\\t cc1} for getting the value\nof CC 17.\n", "essential": 1, "essential_count": 2, "ramsize": 12}, {"name": "lowestnote", "type": "integer", "default": "0", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"name": "highestnote", "type": "integer", "default": "127", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. The ``Notegates'' are not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"prefix": "note", "name": "note1 ... note16", "count": 16, "start_at": 1, "type": "integer", "default": "unpatched", "description": "Selects up to 16 individual notes for which you can get a\ndedicated gate signal. Per default these values are set to\n{\\t 0} for {\\t note1} (meaning C-2), {\\t 1} for {\\t note2}\n(meaning C$\\sharp$-2) and so on. For each of these notes\nyou get a corresponding gate output (see {\\t notegate1}, {\\t notegate2}, etc.).\nThese gates are high as long as the selected notes are being hold.\nOne application is to use just one {\\t midifileplayer} or {\\t midiin}\ncircuit for sequencing up to 16 drum voices. Another application is\nto use a MIDI keyboard or controller as a button expander -- just\nlike a P2B8 or B32.\n", "essential": 0, "essential_count": 0, "ramsize": 12}], "outputs": [{"name": "clockout", "type": "trigger", "default": null, "description": "Outputs a steady clock of 1 tick per \\nth{16} note.\n", "essential": 0, "ramsize": 8}, {"name": "midiclock", "type": "trigger", "default": null, "description": "Outputs a steady MIDI clock, i.e. 24 ticks per quarter note\nof the tune. This is 6 times faster than {\\t clock}.\n", "essential": 0, "ramsize": 8}, {"name": "endoftrack", "type": "trigger", "default": null, "description": "Outputs a trigger when the end of the track is reached.\n", "essential": 0, "ramsize": 8}, {"name": "error", "type": "cv", "default": null, "description": "This output will be set to a value other than zero in case\nof an error while loading and parsing the MIDI file. This is\nintended for wiring it to one of the {\\t R} registers. Here\ndifferent errors will be displayed as different colors. Here\nis the list of all possible values of {\\t error}:\n\n\\begin{tabular}{|l|l|}\\hline\n\\jacktablerow{0}{black -- Everything is fine.}\n\\jacktablerow{-1}{white -- The SD card or MIDI file is missing.}\n\\jacktablerow{1}{magenta -- The file is corrupted, garbled or no MIDI file.}\n\\jacktablerow{0.75}{orange -- The file does not contain any non-empty track.}\n\\jacktablerow{0.25}{cyan -- the track is too long (max 6000 bytes are allowed).}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 4}, {"prefix": "pitch", "name": "pitch1 ... pitch8", "count": 8, "start_at": 1, "type": "voltperoctave", "default": null, "description": "Pitch outputs. Since MIDI tracks can be polyphonic -- i.e. play\nseveral notes at the same time -- you can assign up to eight outputs\nhere. The notes will be distributed to the defined outputs\naccording to the settings {\\t roundrobin} and {\\t voiceallocation}.\n", "essential": 2, "essential_count": 1, "ramsize": 4}, {"prefix": "velocity", "name": "velocity1 ... velocity8", "count": 8, "start_at": 1, "type": "fraction", "default": null, "description": "For each voice there is an optional velocity output, which\ntranslates the MIDI velocity into values from 0 to 1.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "pressure", "name": "pressure1 ... pressure8", "count": 8, "start_at": 1, "type": "fraction", "default": null, "description": "MIDI provides two different messages for sending \"after-touch\"\ninformation, i.e. information about how strong a key is pressed\ndown after the initial hit. Some keyboards just have one pressure\nsensor in total and send the current maximum pressure information\nof all keys in one message (``channel pressure''). Others have\none pressure sensor per key and send ``polyphonic key pressure''\nmessages. This circuit maps both to a {\\t pressure} output\nper note that is being played. So if your keyboard (or sequencer\nor DAW or whatever) sends polyphonic key pressure events and\nyou use multiple {\\t pitch}{\\it X} outputs, wire the individual\n{\\t pressure}{\\it X} outputs to wherever you like. Otherwise\nyou can simply use {\\t pressure1} for all notes (which can\nbe abbreviated with {\\t pressure}), since it is the same for\nall note outputs anyway. {\\t pressure} outputs a value from\n0 to 1.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "gate", "name": "gate1 ... gate8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "Gate outputs for the up to eight simultaneous note outputs.\n", "essential": 2, "essential_count": 1, "ramsize": 4}, {"prefix": "cc", "name": "cc1 ... cc4", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "Outputs the current value of the four CC number that are defined\nwith the inputs {\\t ccnumber1} ... {\\t ccnumber4}. CCs have a\nrange from 0 to 127, but this is converted in the range 0.0 .. 1.0\nhere, in order to make it easier to use that as a CV. If you need\nthe raw number, multiply the output with 127. Note: as long as no CC\nmessage with the selected number happened, this output will be set\nto 0.\n", "essential": 1, "essential_count": 2, "ramsize": 4}, {"prefix": "notegate", "name": "notegate1 ... notegate16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "Outputs a high gate whenever the corresponding note (which is\nselected by {\\t note1} through {\\t note16}) is currently being played.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "pitchbend", "type": "cv", "default": null, "description": "Outputs the current pitch bend value as a bipolar voltage.\nThe range can be set with {\\t pitchbendrange}.\n", "essential": 0, "ramsize": 4}, {"name": "programchange", "type": "trigger", "default": null, "description": "Sends a trigger whenever a {\\it MIDI program change} message\narrives. Just before sending the trigger sets {\\t program} to\nthe new program number (something from 0 to 127). Note: This\ntrigger is also being output when the program change messages\nsends the same program number as previously, i.e. if there\nis no actual {\\it change}.\n", "essential": 0, "ramsize": 8}, {"name": "program", "type": "integer", "default": null, "description": "The number of the last program change. This starts at {\\t 0}.\n", "essential": 0, "ramsize": 4}, {"name": "bank", "type": "integer", "default": null, "description": "Outputs the number of the currently selected bank -- from\n0 to 16384. MIDI defines the MSB of the bank to be changed\nwith CC\\#0 and the LSB with CC\\#32. That means if you just\nuse CC\\#0, you will only be able to select the banks 0, 128,\n256, and so on. As long as no bank select CC has been received,\n{\\t bank} will output 0.\n", "essential": 0, "ramsize": 4}, {"name": "modwheel", "type": "fraction", "default": null, "description": "Output the current state of the mod wheel level -- within\nthe range from {\\t 0.0} to {\\t 1.0}. The mod wheel is changed\nby MIDI control change 1.\n", "essential": 0, "ramsize": 4}, {"name": "volume", "type": "fraction", "default": null, "description": "Outputs the current global volume as set by MIDI control change 7.\n", "essential": 0, "ramsize": 4}, {"name": "portamento", "type": "gate", "default": null, "description": "This output gives you access to the current state of\nthe ``portamento pedal'' (MIDI CC 65). You can use it to\nenable an external slew circuit for creating portamento\neffects.\n", "essential": 0, "ramsize": 4}, {"name": "soft", "type": "gate", "default": null, "description": "This output gives you access to the current state of\nthe ``soft pedal'' (MIDI CC 67). It is {\\t 1} while the pedal\nis hold and {\\t 0} otherwise.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 177, "ramsize": 6376}, "midiin": {"category": "midi", "title": " MIDI to CV converter", "description": "This circuit converts incoming MIDI data into CV, gate and trigger signals.\nIt needs the {\\bf X7} expander in order to work (see page \\pageref{x7} for\ngeneral information about the X7).\n\nThere are various useful applications of this circuit, some of which are:\n\\begin{itemize}\n\\item Attaching an external keyboard to your modular.\n\\item Using an external hardware sequencer for playing melodies and beats in your modular.\n\\item Use an external MIDI controller to influence your \\droid patch.\n\\item Use your phone or tablet as a MIDI controller to influence your patch (via USB).\n\\item Connect two DROIDs (both with X7) and exchange real time data.\n\\end{itemize}\n\nThe X7 MIDI implementation is very comprehensive and gives you convenient\naccess to most of the MIDI features. Please refer to the table of\ninputs and outputs for details. Here are just some very basic examples:\n\n\\subsubsection*{Basic operation}\n\nThe basic operation is quite simple. Per default {\\t midiin} listens on the\n3.5~mm TRS jack of the X7. The following example controls one synth voice\nby converting MIDI note on / note off messages into CV / gate signals:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    pitch = O1}    pitch = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\end{droidini}\n\nIt's really as simple as that! Connect your MIDI keyboard or sequencer\nwith the X7 MIDI input, wire {\\t O1} to the 1V/Oct input of a synth voice\nand {\\t O2} to its gate input and enjoy your music!\n\nWhen you add {\\t usb = 1} you can get a MIDI stream via the USB-C port\non the X7 instead of the TRS jack.\n\n\\subsubsection*{Polyphonic patches}\n\nDo you have more than one synth voice to control? Then you can play\nseveral notes at the same time by using up to {\\it eight} {\\t pitch} and {\\t gate} outputs.\nHere is an example with three voices, which uses a G8 expander\nfor the gates:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    pitch1 = O1}    pitch1 = O1\n\\immediate\\write\\patchexamples{    pitch2 = O2}    pitch2 = O2\n\\immediate\\write\\patchexamples{    pitch3 = O3}    pitch3 = O3\n\\immediate\\write\\patchexamples{    gate1 = G1}    gate1 = G1\n\\immediate\\write\\patchexamples{    gate2 = G2}    gate2 = G2\n\\immediate\\write\\patchexamples{    gate3 = G3}    gate3 = G3\n\\end{droidini}\n\nHere the parameters {\\t roundrobin} and {\\t voiceallocation} are interesting.\n{\\t roundrobin} influences which of the three outputs should be used for the\nnext note, in situations where more than one is free.  {\\t voiceallocation},\nin contrast, controls what should happen if the MIDI stream wants to play\nmore simultaneous notes than you have setup in {\\t midiin}.  The default\nis to cancel the oldest currently playing note, but you can change that\nbehaviour in various ways.\n\n\\subsubsection*{Sequencing drums and triggers}\n\nWhen you use a MIDI sequencer for triggering drums, often each drum voice\n(bass drum, snare drum, etc.) is triggered by a certain note, for example\nC-2 for the bass drum, C$\\sharp$-2 for the snare drum and so on. In this\ncase it is more convenient to use the {\\t notegate} outputs. Check the\nfollowing example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    note2 = 25}    note2 = 25\n\\immediate\\write\\patchexamples{    notegate1 = O1}    notegate1 = O1\n\\immediate\\write\\patchexamples{    notegate2 = O2}    notegate2 = O2\n\\end{droidini}\n\nNow whenever note 24 is played by the sequencer, {\\t notegate1} will trigger.\nThe note numbers range from 0 to 127, with 0 being the lowest note and 127 the\nhighest. The MIDI standard specifies that note 0 is usually C-2 (two octaves\nbelow C0). So note {\\t 24} would be C0 and note {\\t 25} C$\\sharp$0.\n\nAnother application of note gates is to use keys on a MIDI keyboard or touch\npads of a MIDI controller as buttons in your \\droid patch! In fact the {\\t\nbutton} circuit can be wired to such note gates. It's just that you don't\nhave a corresponding LED.  But you can use the \\droid's own LEDs for that.\n\nThe following example uses the note 24 in order to toggle a (virtual) button\nand use the first input LED of the master as LED for the button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    notegate1 = _NOTE24}    notegate1 = _NOTE24\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = _NOTE24}    button = _NOTE24\n\\immediate\\write\\patchexamples{    led = R1}    led = R1\n\\immediate\\write\\patchexamples{    output = _SOMETHING # ...}    output = _SOMETHING # ...\n\\end{droidini}\n\nPlease note: {\\t midiout} has similar {\\t note1} ... {\\t note8} inputs.\nBut there the pitches are specified in 1V/Oct. So don't mix them up!\n\n\n\\subsubsection*{Start, Stop and Clock}\n\nMIDI sequencers usually send a steady MIDI clock at 24 PPQ, which means\n24 pulses per quarter note, which in turn means 6 pulses per \\nth{16} note,\nwhich is the typical clock speed for modular systems. But also 48~PPQ and\n96~PPQ are possible.\n\nYou get easy access to the clock by various clock outputs running at\ndifferent speeds. The jack labelled just {\\t clock} outputs the \\nth{16}\nnote clock. The following example just sends that clock to the O1 output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    clock = O1}    clock = O1\n\\end{droidini}\n\nHereby it is assumed that the MIDI clock is running at 24~PPQ. If its running\nfaster, simply use one of the other clock outputs, which divides down the\nclock. Or use \\circuit{clocktool} for dividing yourself.\n\nAlso the START and STOP messages of MIDI sequencers are accessible, either\nas two separate triggers, or as a running state. For example you can use\nthe {\\t start} output as a reset signal for some \\droid circuit:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    start = _RESET}    start = _RESET\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = _RESET}    reset = _RESET\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\\subsubsection*{Getting CCs}\n\nMIDI does not only transport note events but also {\\it controllers}. Most\nof these are continuous values, much like CVs. {\\t midiin} gives you access\nto the current value of a couple of standard controllers like {\\t volume}\nand {\\t modwheel} with dedicated outputs. And in addition up to four custom\nCCs can be output. All such controllers are converted into values from 0\nto 1 (or 0~V to 10~V if you output them directly):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    volume = O1}    volume = O1\n\\immediate\\write\\patchexamples{    modwheel = O2}    modwheel = O2\n\\immediate\\write\\patchexamples{    ccnumber1 = 10 # get update from CC#10}    ccnumber1 = 10 # get update from CC#10\n\\immediate\\write\\patchexamples{    cc1 = O3 # send current CC value to O3}    cc1 = O3 # send current CC value to O3\n\\end{droidini}\n\n\\subsubsection*{Using multiple midiins}\n\nYou are not restricted to one {\\t midiin} circuit but can use up to {\\bf 32}\nof these in your patch. There are different reasons why multiple ones can\nbe useful, e.g.:\n\n\\begin{itemize}\n\\item You want to control different voices from different MIDI channels\n\\item You want to fetch more than four CCs.\n\\end{itemize}\n\nAll {\\t midiin} circuits will get their own copy of the MIDI data stream\nand can do their own things with it. You might want to use {\\t channel =\n...} in order to just get only the events of a specific MIDI channel.\n\n\\subsubsection*{Pedals}\n\nThe MIDI standard defines five different types of food pedals. The state\nof these -- up or down -- is transmitted by means of five different control\nchanges (CCs). {\\t midiin} automatically interpretes them corresponding to\ntheir intended meaning as follows:\n\n\\begin{itemize}\n\\item {\\it Damper pedal} (CC 64): While down, notes still linger on, even if\n  they end. Internally, the ``note off'' event of all notes will be delayed\n  until the pedal is up. This pedal is sometimes also called ``sustain pedal'',\n  since it makes notes sustain.\n\n\\item {\\it Portamento pedal} (CC 65): Sets the {\\t portamento} output\n  to {\\t 1} while down. You can use that output for enabling a slew\n  limiter with the circuit \\circuit{slew}.\n\n\\item {\\it Sostenuto pedal} (CC 66): Sostenuto is the smarter version\n  of sustain. Such a pedal is found as the middle of three pedals on grand\n  pianos. When it {\\it goes} down, all notes that are {\\it currently played}\n  are sustained as long as the pedal is held. But {\\it new} notes, that start\n  during that period, at {\\it not} sustained. That's the difference. The {\\t\n  midiin} circuit automatically makes CC 66 behave in exactly that way. That,\n  of course, just makes sense in a polyphonic patch, where you have enough\n  voice that can play the sustained notes.\n\n\\item {\\it Soft pedal} (CC 67): Sets the {\\t soft} output to {\\t 1} while held.\n\n\\item {\\it Legato pedal} (CC 68):\n  While down, ties consequtive notes together by keeping {\\t gate} at {\\t 1} between\n  notes.\n\n\n\\end{itemize}\n\n\n\n\\clearpage", "inputs": [{"name": "usb", "type": "gate", "default": "0", "description": "Selects the physical port to receive MIDI data.  The default\nis {\\t usb = 0}, which selects the TRS (3.5mm stereo jack) port of\nthe X7. Set {\\t usb = 1} for receiving data from the USB-C port.\n", "essential": 0, "ramsize": 12}, {"name": "initialrunning", "type": "integer", "default": "2", "description": "This parameter sets which ``running'' state is assumed when your\n\\droid starts. The idea behind this parameter is, that at this point\nof time you cannot know the real running state of the MIDI stream,\nsince e.g. the \\droid might have started after the sequencer at the\nsending end of the line.\n\nYou have three ways to set this: start in stopped state, start\nin running state and an inbetween ``automatic'' mode. In the\nauto mode, you start in stopped state but automatically switch\nto running as soon as a note on event is received. At that moment\na MIDI START event is simulated.\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{Start stopped state}\n\\jacktablerow{1}{Start in running state}\n\\jacktablerow{2}{Automatic: start in stopped state, switch to running on first ``note on''}\n\\end{tabular}\n\nNote: as this parameter is just read once the absolute system start,\nyou cannot assign a dynamic CV input or control here.\n", "essential": 0, "ramsize": 12}, {"name": "systemreset", "type": "trigger", "default": null, "description": "A trigger here resets the whole MIDI state of this circuit.\nIt does the same as a MIDI RESET message: It stops all\nplaying note, resets the controllers, the states of the\npedals and so on.\n", "essential": 0, "ramsize": 16}, {"name": "channel", "type": "integer", "default": "unpatched", "description": "Only execute / play commands from a certain MIDI channel.\nThere are 16 MIDI channels. It ranges from {\\t 1}\nto {\\t 16}.\n", "essential": 1, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "If set to {\\t 1}, all pitch outputs will go to the CV\nselected for {\\t tuningpitch} (which defaults to 2~V),\nand all\ngate outputs will play gates at 120 BPM. This helps getting\nall attached voices tuned when working with many voices.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0.2", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "Transposes all output pitches by this value by adding\nthe value. So in order to transpose one octave\ndown, set this input to {\\t -1V} or {\\t -0.1}. Changes in the\ntransposition are immediately reflected, even for currently\nalready active notes.\n", "essential": 0, "ramsize": 12}, {"name": "holdvelocity", "type": "gate", "default": "0", "description": "If this is set to {\\t 1}, the velocity output for a voice\nwill not be affected by note off events. It's just altered\nat the beginning of new notes.\nThe velocity is kept after the note ends.\nThis way during the release phase of an envelope triggered\nby the gate, the original velocity still lasts on. In most cases\nthe note off velocity is set to 0, which would\nimmediately cut off the release phase when the velocity is patched\ninto a VCA.\n", "essential": 0, "ramsize": 12}, {"name": "pitchbendrange", "type": "voltperoctave", "default": "$\\frac{1}{6}$V", "description": "Sets the value to the desired maximum that {\\t pitchbend}\nshould output, and likewise it's negative counterpart at its minimum\nvalue. At the middle position it always outputs 0. This defaults\nto $\\frac{2}{12}$~V, which corresponds to one whole tone. Note:\nsetting this to a negative value is allowed and will invert\npitch bend.\n", "essential": 0, "ramsize": 12}, {"name": "bendpitch", "type": "gate", "default": "1", "description": "When set to {\\t 1} (which is the default), the pitch bend\nwill directly be applied to all output pitches. Alternatively\nyou can set it to {\\t 0} and use the output {\\t pitchbend},\nfor using it elsewhere.\n", "essential": 0, "ramsize": 12}, {"name": "roundrobin", "type": "gate", "default": "0", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t output1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophonic. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n", "essential": 0, "ramsize": 12}, {"name": "voiceallocation", "type": "integer", "default": "0", "description": "When the MIDI stream, at any given time, needs to play more notes\nthan you have voices assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{The oldest note will be cancelled (default)}\n\\jacktablerow{1}{The new note will not be played and simply be omitted}\n\\jacktablerow{2}{The lowest note will be cancelled}\n\\jacktablerow{3}{The highest note will be cancelled}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "notegap", "type": "cv", "default": "0", "description": "When your MIDI devices plays a note so ``long'' that it lasts\nexactly until the next note begins -- or if due to a lack of\nused pitch outputs one currently played note has to be replaced\nwith a new one, the {\\t gate} output will have no time to go\nlow for a sufficient time between the two notes. In effect it\nwon't trigger any envelope for the new note but will play ``legato''.\n\nIf you don't like this, you can use {\\t notegap}. This input specifies\na number of {\\bf milliseconds} that the gate will be forced down\nbefore the new note begins. This has the drawback of introducing some\nlatency, of course! So I suggest that you start with {\\t notegap =\n1} and then check out if your envelope is fast enough to trigger.\nIf not, increase the value.\n\nIf you are using \\droid's own {\\t contour} circuit or trigger something\nelse internally in your patch, you can use {\\t notegap = 0.1}. That is\nsufficient and introduces barely any latency.\nA value of {\\t 0.0} keeps the default of the legato mode.\n\nNote: the {\\t notegap} parameter does not affect the {\\t trigger}\noutputs.\n", "essential": 0, "ramsize": 12}, {"prefix": "ccnumber", "name": "ccnumber1 ... ccnumber4", "count": 4, "start_at": 1, "type": "integer", "default": "0", "description": "You can {\\it listen} to up to four CCs (control changes). For example\nif you are interested in the current value of CC\\#17, set\n{\\t ccnumber1 = 17} and use the output {\\t cc1} for getting the value\nof CC 17.\n", "essential": 1, "essential_count": 2, "ramsize": 12}, {"name": "lowestnote", "type": "integer", "default": "0", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"name": "highestnote", "type": "integer", "default": "127", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. The ``Notegates'' are not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"prefix": "note", "name": "note1 ... note16", "count": 16, "start_at": 1, "type": "integer", "default": "unpatched", "description": "Selects up to 16 individual notes for which you can get a\ndedicated gate signal. Per default these values are set to\n{\\t 0} for {\\t note1} (meaning C-2), {\\t 1} for {\\t note2}\n(meaning C$\\sharp$-2) and so on. For each of these notes\nyou get a corresponding gate output (see {\\t notegate1}, {\\t notegate2}, etc.).\nThese gates are high as long as the selected notes are being hold.\nOne application is to use just one {\\t midifileplayer} or {\\t midiin}\ncircuit for sequencing up to 16 drum voices. Another application is\nto use a MIDI keyboard or controller as a button expander -- just\nlike a P2B8 or B32.\n", "essential": 0, "essential_count": 0, "ramsize": 12}], "outputs": [{"name": "clock", "type": "trigger", "default": null, "description": "If the MIDI sender sends a MIDI clock, you get a \\nth{16}\nnote clock output here. This is the same as the {\\t clock16} jack\nand just a convenient abbreviation.\n", "essential": 1, "ramsize": 8}, {"name": "clock8", "type": "trigger", "default": null, "description": "Gets an \\nth8 clock here (like {\\t clock} divided by 2)\n", "essential": 0, "ramsize": 8}, {"name": "clock8t", "type": "trigger", "default": null, "description": "Gets a \\nth8 triplets clock here. This is faster than\n{\\t clock8} but slower than {\\t clock}.\n", "essential": 0, "ramsize": 8}, {"name": "clock16", "type": "trigger", "default": null, "description": "The same as {\\t clock}: a clock running at \\nth{16} notes.\n", "essential": 0, "ramsize": 8}, {"name": "clock4", "type": "trigger", "default": null, "description": "A clock at the speed of quarter notes.\n", "essential": 0, "ramsize": 8}, {"name": "midiclock", "type": "trigger", "default": null, "description": "Here you get the original MIDI clock. This is 6 times\nfaster than {\\t clock} and 24 times faster than {\\t clock4}. This\nis because the MIDI clock is specified to run at 24 PPQ, i.e.\n24 pulses per quarter note.\n", "essential": 0, "ramsize": 8}, {"name": "start", "type": "trigger", "default": null, "description": "This jack sends a trigger when a MIDI START message arrives.\n", "essential": 1, "ramsize": 8}, {"name": "continue", "type": "trigger", "default": null, "description": "This jack sends a trigger when a MIDI CONTINUE message arrives.\n", "essential": 0, "ramsize": 8}, {"name": "stop", "type": "trigger", "default": null, "description": "This jack sends a trigger when a MIDI STOP message arrives.\n", "essential": 1, "ramsize": 8}, {"name": "running", "type": "gate", "default": null, "description": "This jack remembers the current running state according to\nprevious START and STOP messages.\n", "essential": 1, "ramsize": 4}, {"name": "active", "type": "gate", "default": null, "description": "If the sending device supports {\\t active sensing}, this output\nis high as long as a device is connected. Otherwise its high if\nat least one MIDI message has been received.\n", "essential": 0, "ramsize": 4}, {"prefix": "pitch", "name": "pitch1 ... pitch8", "count": 8, "start_at": 1, "type": "voltperoctave", "default": null, "description": "Pitch outputs. Since MIDI tracks can be polyphonic -- i.e. play\nseveral notes at the same time -- you can assign up to eight outputs\nhere. The notes will be distributed to the defined outputs\naccording to the settings {\\t roundrobin} and {\\t voiceallocation}.\n", "essential": 2, "essential_count": 1, "ramsize": 4}, {"prefix": "velocity", "name": "velocity1 ... velocity8", "count": 8, "start_at": 1, "type": "fraction", "default": null, "description": "For each voice there is an optional velocity output, which\ntranslates the MIDI velocity into values from 0 to 1.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "pressure", "name": "pressure1 ... pressure8", "count": 8, "start_at": 1, "type": "fraction", "default": null, "description": "MIDI provides two different messages for sending \"after-touch\"\ninformation, i.e. information about how strong a key is pressed\ndown after the initial hit. Some keyboards just have one pressure\nsensor in total and send the current maximum pressure information\nof all keys in one message (``channel pressure''). Others have\none pressure sensor per key and send ``polyphonic key pressure''\nmessages. This circuit maps both to a {\\t pressure} output\nper note that is being played. So if your keyboard (or sequencer\nor DAW or whatever) sends polyphonic key pressure events and\nyou use multiple {\\t pitch}{\\it X} outputs, wire the individual\n{\\t pressure}{\\it X} outputs to wherever you like. Otherwise\nyou can simply use {\\t pressure1} for all notes (which can\nbe abbreviated with {\\t pressure}), since it is the same for\nall note outputs anyway. {\\t pressure} outputs a value from\n0 to 1.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"prefix": "gate", "name": "gate1 ... gate8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "Gate outputs for the up to eight simultaneous note outputs.\n", "essential": 2, "essential_count": 1, "ramsize": 4}, {"prefix": "cc", "name": "cc1 ... cc4", "count": 4, "start_at": 1, "type": "fraction", "default": null, "description": "Outputs the current value of the four CC number that are defined\nwith the inputs {\\t ccnumber1} ... {\\t ccnumber4}. CCs have a\nrange from 0 to 127, but this is converted in the range 0.0 .. 1.0\nhere, in order to make it easier to use that as a CV. If you need\nthe raw number, multiply the output with 127. Note: as long as no CC\nmessage with the selected number happened, this output will be set\nto 0.\n", "essential": 1, "essential_count": 2, "ramsize": 4}, {"prefix": "notegate", "name": "notegate1 ... notegate16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "Outputs a high gate whenever the corresponding note (which is\nselected by {\\t note1} through {\\t note16}) is currently being played.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "pitchbend", "type": "cv", "default": null, "description": "Outputs the current pitch bend value as a bipolar voltage.\nThe range can be set with {\\t pitchbendrange}.\n", "essential": 0, "ramsize": 4}, {"name": "programchange", "type": "trigger", "default": null, "description": "Sends a trigger whenever a {\\it MIDI program change} message\narrives. Just before sending the trigger sets {\\t program} to\nthe new program number (something from 0 to 127). Note: This\ntrigger is also being output when the program change messages\nsends the same program number as previously, i.e. if there\nis no actual {\\it change}.\n", "essential": 0, "ramsize": 8}, {"name": "program", "type": "integer", "default": null, "description": "The number of the last program change. This starts at {\\t 0}.\n", "essential": 0, "ramsize": 4}, {"name": "bank", "type": "integer", "default": null, "description": "Outputs the number of the currently selected bank -- from\n0 to 16384. MIDI defines the MSB of the bank to be changed\nwith CC\\#0 and the LSB with CC\\#32. That means if you just\nuse CC\\#0, you will only be able to select the banks 0, 128,\n256, and so on. As long as no bank select CC has been received,\n{\\t bank} will output 0.\n", "essential": 0, "ramsize": 4}, {"name": "modwheel", "type": "fraction", "default": null, "description": "Output the current state of the mod wheel level -- within\nthe range from {\\t 0.0} to {\\t 1.0}. The mod wheel is changed\nby MIDI control change 1.\n", "essential": 0, "ramsize": 4}, {"name": "volume", "type": "fraction", "default": null, "description": "Outputs the current global volume as set by MIDI control change 7.\n", "essential": 0, "ramsize": 4}, {"name": "portamento", "type": "gate", "default": null, "description": "This output gives you access to the current state of\nthe ``portamento pedal'' (MIDI CC 65). You can use it to\nenable an external slew circuit for creating portamento\neffects.\n", "essential": 0, "ramsize": 4}, {"name": "soft", "type": "gate", "default": null, "description": "This output gives you access to the current state of\nthe ``soft pedal'' (MIDI CC 67). It is {\\t 1} while the pedal\nis hold and {\\t 0} otherwise.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 183, "ramsize": 528}, "midiout": {"category": "midi", "title": " CV to MIDI converter", "description": "This circuit allows you to ``play'' notes via MIDI on an external hardware\nor software synth. You also can send all sorts of other MIDI events. You\nneed the X7 expander for that to work (see page \\pageref{x7}).\n\nThe MIDI implementation of {\\t midiout} is very comprehensive. Please look\nat the table of input jacks for all features. Here I just want to show some\nbasic examples to get you started quickly. Fun fact: This is the only\ncircuit that does not have any outputs, because all output is done via MIDI!\n\n\\subsubsection*{Basic operation}\n\nEasy things should be easy and complex things should be possible.\nSo we start with the easy things. Here is a patch that converts a\nCV / gate input from {\\t I1} / {\\t I2} into a stream of MIDI notes\nand sends them out via the 3.5~mm TRS jack on MIDI channel 1:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\end{droidini}\n\nEvery time the gate input at {\\t I2} goes from off to on, the current pitch\n(1V/Oct) is read from {\\t I1}. Then one MIDI ``note on'' event is being\ncreated. The ``velocity'' of that note is set to the default value of 1.0,\nwhich is the maximum (every MIDI note event has a velocity, which is meant\nto reflect the speed at which the key of the keyboard has been pressed).\n\nYou can specify any velocity you like with the jack {\\t velocity}. Let's\nrandomize that. Since the velocity jack is just read just at the note\nstarts, we don't need a sample and hold here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    minimum = 0.5 # minimum allowed velocity}    minimum = 0.5 # minimum allowed velocity\n\\immediate\\write\\patchexamples{    maximum = 1.0 # maximum allowed velocity}    maximum = 1.0 # maximum allowed velocity\n\\immediate\\write\\patchexamples{    output = _VELOCITY}    output = _VELOCITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    velocity = _VELOCITY}    velocity = _VELOCITY\n\\end{droidini}\n\nNote: the range of the velocity goes from 0.0 to 1.0 -- just as all other\nparameters in {\\t midiout} do. Internally MIDI uses the integer numbers\n0 to 127.\n\n\\subsubsection*{Output selection}\n\nYou can send your MIDI stream either via the 3.5~mm TRS jack of the X7 (TRS\nstands for ``tip ring sleeve'' -- the structure of the stereo 3.5 mm plug)\nor via the USB-C port. This is controlled by the parameters {\\t usb} and {\\t trs}.\n\nPer default the stream is sent via TRS. As soon as you use either {\\t usb}\nor {\\t trs} you set this explicitely. Here is a complete table of all\npossible usages of these inputs (empty cells mean that the parameter is\nnot used):\n\n\n\\begin{tabular}{|l|l|p{43mm}|} \\hline\n\\t         & \\t         & Uses TRS only (default) \\\\ \\hline\n\\t usb = 1 & \\t         & Uses USB only \\\\ \\hline\n\\t usb = 0 & \\t         & Uses TRS only (default) \\\\ \\hline\n\\t         & \\t trs = 1 & Uses TRS only (default) \\\\ \\hline\n\\t         & \\t trs = 0 & Uses USB only \\\\ \\hline\n\\t usb = 0 & \\t trs = 1 & Uses TRS only (default) \\\\ \\hline\n\\t usb = 1 & \\t trs = 0 & Uses USB only \\\\ \\hline\n\\t usb = 1 & \\t trs = 1 & Uses both TRS and USB \\\\ \\hline\n\\t usb = 0 & \\t trs = 0 & Mute! does not send MIDI. \\\\ \\hline\n\\end{tabular}\n\n{\\bf Note}: MIDI via USB has a much higher data rate then via TRS. If you\nuse both USB and TRS at the same time, USB will run at the same (lower)\ndata rate as TRS. This might lead to fewer updates for CCs and similar. The\nreason is that the {\\t midiout} circuit does not make a separate book keeping\nfor USB and TRS but creates just one common MIDI data stream. If that's an\nissue for you, duplicate your {\\t midiout} circuit and create one instance\nfor TRS and one for USB. Then they create two separate MIDI streams that are\noptimized for the specific maximum data rates of their output ports.\n\n\n\\subsubsection*{Polyphonic patches}\n\nOne great motivation for doing CV to MIDI at all is playing polyphonic\nmusic on hardware synths, because polyphony in Eurorack is quite costly and\nvery time and space consuming. One {\\t midiout} circuit can play up to eight notes\nat the same time and if that's not enough, add a second {\\t midiout}\ncircuit. For each simultaneous note add one pair of {\\t pitch} and {\\t gate}\njacks:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch1 = I1}    pitch1 = I1\n\\immediate\\write\\patchexamples{    pitch2 = I2}    pitch2 = I2\n\\immediate\\write\\patchexamples{    pitch3 = I3}    pitch3 = I3\n\\immediate\\write\\patchexamples{    gate1 = I5}    gate1 = I5\n\\immediate\\write\\patchexamples{    gate2 = I6}    gate2 = I6\n\\immediate\\write\\patchexamples{    gate3 = I7}    gate3 = I7\n\\end{droidini}\n\nIf you work with velocity, each voice has its own velocity input:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch1 = I1}    pitch1 = I1\n\\immediate\\write\\patchexamples{    pitch2 = I2}    pitch2 = I2\n\\immediate\\write\\patchexamples{    pitch3 = I3}    pitch3 = I3\n\\immediate\\write\\patchexamples{    gate1 = I5}    gate1 = I5\n\\immediate\\write\\patchexamples{    gate2 = I6}    gate2 = I6\n\\immediate\\write\\patchexamples{    gate3 = I7}    gate3 = I7\n\\immediate\\write\\patchexamples{    velocity1 = 0.6}    velocity1 = 0.6\n\\immediate\\write\\patchexamples{    velocity2 = 0.8}    velocity2 = 0.8\n\\immediate\\write\\patchexamples{    velocity3 = 1.0}    velocity3 = 1.0\n\\end{droidini}\n\n\\subsubsection*{CC and other controllers}\n\nThere are several continuous values that you can change over time.\nThe following example lets you control the MIDI CC number 17\nvia input {\\t I3} (at a range from 0~V to 10~V) and the\nvolume and modulation wheel with two pots:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    ccnumber1 = 17}    ccnumber1 = 17\n\\immediate\\write\\patchexamples{    cc1 = I3}    cc1 = I3\n\\immediate\\write\\patchexamples{    volume = P1.1}    volume = P1.1\n\\immediate\\write\\patchexamples{    modwheel = P1.2}    modwheel = P1.2\n\\end{droidini}\n\n\\subsubsection*{Note gates}\n\nNote gates are a convenient way to directly trigger certain\nnotes. Here you select up to eight notes and get one dedicated\ntrigger for each. You select the note number with {\\t note1}, {\\t note2}, etc.\nThese are MIDI note numbers from 0 to 127, where 0 is\nusually a C-2 (and 24 a C0). When you send a trigger into the\ncorresponding {\\t notegate} input, that note will be played.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    note1 = 24}    note1 = 24\n\\immediate\\write\\patchexamples{    note2 = 25}    note2 = 25\n\\immediate\\write\\patchexamples{    notegate1 = I1}    notegate1 = I1\n\\immediate\\write\\patchexamples{    notegate2 = I2}    notegate2 = I2\n\\end{droidini}\n\nThis is sometimes convenient when triggering drum voices.\n\n\\subsubsection*{Creating a MIDI clock}\n\nIf you want to simulate a MIDI sequencer, you need to provide\na MIDI clock. This can be injected into the output either by sending a\nmodular clock that is running on \\nth{16} notes into {\\t clock}, or a raw\nMIDI clock into {\\t midiclock}.\n\nExample: You want your clock to run at 120 BPM. BPM means beats per minute.\nAnd a beat is ment to be a quarter note. 120 quarter notes a minute means\ntwo quarter notes a second and that means eight \\nth{16} notes a second,\nhence our clock needs to run at 8~Hz.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 8 # 120 BPM}    hz = 8 # 120 BPM\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\end{droidini}\n\nNote: The input jack {\\t clock} receives \\nth{16} clocks. The actual MIDI\nclock is derived from that by multiplying it by 6. This means that the\ncircuit interpolates the clock by measuring its speed and introducing five\nartifical clocks ticks inbetween the original ticks. While this works\nreasonably well for a steady clock, changes in clocks speed cannot be picked\nup very fast.\n\nSo if you work with a clock that can change the speed, better use the jack {\\t\nmidiclock} instead and directly supply the MIDI clock (at a six times higher\nspeed). Here is the same example but now we directly create the MIDI clock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 48 # 120 BPM MIDI clock}    hz = 48 # 120 BPM MIDI clock\n\\immediate\\write\\patchexamples{    square = _MIDICLOCK}    square = _MIDICLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    midiclock = _MIDICLOCK}    midiclock = _MIDICLOCK\n\\end{droidini}\n\n\\subsubsection*{Start, Stop, Reset}\n\nMIDI sequencers also output ``start'' and ``stop'' messages.\nYou can send them either via triggers into {\\t start} and {\\t stop}\nor use the input {\\t running} for both. When running goes high,\na ``start'' message is sent, when it goes low a ``stop'' message.\n\n\\subsubsection*{Pitch tracking}\n\nPitch tracking is an advanced feature that works in monophonic\nsetups. Here {\\t midiout} watches the input pitch all the time and\nadapts the pitch of the currently played note via MID pitchbend events\nin order to reflect the pitch changes. See the documentation of\nthe {\\t pitchtracking} jack for details.\n\n\\subsubsection*{Pitch stabilization}\n\nMIDI output appears simple to implement, but isn't when you look\nat the details. One tricky problem is that many modules that output\npitch information are not very precise in timing. Sequencers often\nneed a couple of milliseconds for the pitch CV to reach its final\nvalue and stabilize after the gate is being output.\n\nThe following diagram shows a gate signal going high (blue) and a\npitch signal with a small ramp reaching its final destination\nshortly afterwards (red):\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 60, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    legend style={at={(0.99,0.38)}},\n]\n\\addplot [color=red]\ncoordinates { (0, 5.5) (20, 5.5) (23, 8.2) (60, 8.2) };\n\\addplot [color=blue]\ncoordinates { (0,0) (20,0) (20, 5) (30, 5) (30, 0) (60, 0) };\n\\legend{Pitch,Gate}\n\\end{axis}\n\\end{tikzpicture}\n\nI've seen a very similar situation indeed when I attached\nan oscilloscope to the output of a very famous Eurorack sequencer.\n\nNow when you would issue ``note on'' right at the beginning of the gate,\nyou would obviously output the wrong pitch. What you need to do is to first\n{\\it wait} for some time. You need to {\\it delay} the note event until the\npitch is stable. Of course this introduces some undesirable latency, so\nit is crucial to keep that as short as possible.\n\nThe {\\t midiout} circuit has two methods for doing this. The first one\nis enabled per default and called {\\t pitchstabilization}. Here, as soon\nas the gate goes high, it watches how {\\t pitch} evolves\nover time. And it delays the ``note on'' as long as the pitch is still {\\it\nmoving}. When it has stabilized -- i.e. on the same level for at least some\nvery short time -- the note event is issued immediately. This keeps the\nlatency at a minimum.\n\nIf that does not work out well for you, you can deactivate this algorithm.\nOne reason could be that your pitch {\\it never} stabilizes, since it is\nsome ever evolving random data:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    pitchstabilization = 0}    pitchstabilization = 0\n\\end{droidini}\n\nThe second method is introducing a fixed delay of the gate signal with\nthe input {\\t triggerdelay}. Using that parameter automatically disables\npitch stabilization:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    triggerdelay = 3.5 # delay gate by 3.5 ms}    triggerdelay = 3.5 # delay gate by 3.5 ms\n\\end{droidini}\n\nNow the gate is delayed {\\it exactly} 3.5~ms every time. You need to try out\nvarious useful values yourself. The best value depends on your sequencer\n(or whatever other source you are using).\n\nYou can also activate both methods at once. This makes sense in situations,\nwhere the pitch is stable for a very short time after the gate but afterwards\nbegins to move, like in the following diagram:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time (ms)$,\n    ylabel = {$Volts$},\n    xmin = 0, xmax = 60, ymin = -2, ymax = 12,\n    ymajorgrids = true,\n    ytick={-10, -5, 0, 5, 10},\n    grid style = dashed,\n    legend style={at={(0.99,0.38)}},\n]\n\\addplot [color=red]\ncoordinates { (0, 5.5) (22, 5.5) (25, 8.2) (60, 8.2) };\n\\addplot [color=blue]\ncoordinates { (0,0) (20,0) (20, 5) (30, 5) (30, 0) (60, 0) };\n\\legend{Pitch,Gate}\n\\end{axis}\n\\end{tikzpicture}\n\nAs you can see, now after the gate comes high the pitch lingers on\nfor 2~ms at its old value until the ramp starts. Here set the\n{\\t triggerdelay} to 2 and explicitly set {\\t pitchstabilization = 1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = I1}    pitch = I1\n\\immediate\\write\\patchexamples{    gate = I2}    gate = I2\n\\immediate\\write\\patchexamples{    triggerdelay = 2}    triggerdelay = 2\n\\immediate\\write\\patchexamples{    pitchstabilization = 1}    pitchstabilization = 1\n\\end{droidini}\n\n\\subsubsection*{Sending notes by number}\n\nIf you are familiar with MIDI, you sometimes might want to send\na certain note {\\it number} rather than a pitch. MIDI knows\nnotes from 0 (C-2) to 127. To do this, divide your number\nby {\\t 120} before sending it to {\\t pitch}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiout]}[midiout]\n\\immediate\\write\\patchexamples{    pitch = _SOMENUMBER / 120}    pitch = _SOMENUMBER / 120\n\\immediate\\write\\patchexamples{    gate = _SOMEGATE}    gate = _SOMEGATE\n\\end{droidini}\n\nWhy not 127? Because the pitch input counts notes by semitones.\nAnd one semitone in modular is $\\frac{1}{12}$~V, which in Droid\nmeans $\\frac{1}{120}$. Dividing by 127 will be slightly off\nand send wrong note numbers.", "inputs": [{"name": "channel", "type": "integer", "default": "1", "description": "Selects the MIDI channel to send the events on. Default is to send on\nchannel 1. There are 16 channels. Make sure that the receiving device\nlistens to this (or to all) channels.\n", "essential": 0, "ramsize": 12}, {"name": "usb", "type": "gate", "default": "0", "description": "Set {\\t usb = 1} if you want to send the MIDI output to the USB-C port.\nYou can set {\\t trs = 1}, as well, for sending the data to both outputs.\nIf you don't use {\\t usb} nor {\\t trs}, the output will be sent to the\nTRS output only.\n", "essential": 0, "ramsize": 12}, {"name": "trs", "type": "gate", "default": "1", "description": "This controls wether the MIDI data is sent via the TRS output of the X7.\nIf you just want the TRS output, you don't need this, because that is\nthe default. If you want the output both on USB and TRS, you need to\nset {\\t usb = 1} and {\\t trs = 1} at the same time.\n", "essential": 0, "ramsize": 12}, {"prefix": "pitch", "name": "pitch1 ... pitch8", "count": 8, "start_at": 1, "type": "voltperoctave", "default": "0", "description": "Pitch of the notes to be played in modular style (1~V/octave).\nThe range is from -2~V (MIDI note 0, usually C-2) to 8.583~V\n(MIDI note 127, usually G9). You can use up to eight pitch inputs\nfor playing up to eight notes in parallel. {\\t pitch1} can\nbe abbreviated with just {\\t pitch}.\n", "essential": 2, "essential_count": 1, "ramsize": 12}, {"prefix": "gate", "name": "gate1 ... gate8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "A positive edge into the gate jacks trigger note on messages\n(starts the note at the pitch set by the corresponding {\\t pitch} input).\nA negative edge ends the currently played note.\n", "essential": 2, "essential_count": 1, "ramsize": 12}, {"prefix": "velocity", "name": "velocity1 ... velocity8", "count": 8, "start_at": 1, "type": "fraction", "default": "1", "description": "The velocities for the up to eight notes. The velocity value is\njust picked up at the start of the note (at the positive edge of\nthe corresponding {\\t gate} inputs. It ranges from 0.0 to 1.0.\nA value of 0.0 is practically the same as ``note off''. The\ndefault velocity is 1.0.\n", "essential": 1, "essential_count": 1, "ramsize": 12}, {"prefix": "noteoffvelocity", "name": "noteoffvelocity1 ... noteoffvelocity8", "count": 8, "start_at": 1, "type": "fraction", "default": "unpatched", "description": "MIDI also sends a velocity at the {\\it end} of a note. The idea\nis to model the speed with which a key is being {\\it released}.\nThis is rarely used. If you don't use these jacks, the\nvelocity for ``note off'' events is the same as that for ``note on''\nevents.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "pressure", "name": "pressure1 ... pressure8", "count": 8, "start_at": 1, "type": "fraction", "default": "unpatched", "description": "Sends key pressure events for individually played notes via\nthe MIDI event ``polyphonic key pressure'' (this is not a CC!).\nThese values are not processed at the time of note on/off events but\nall the time and can also change while a note is already being\nplayed. This corresponds to ``aftertouch'' key pressure on keyboards\nthat have a pressure sensor {\\it per key}.\n\nIf nothing is patched here, no pressure events are sent.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "channelpressure", "type": "fraction", "default": "unpatched", "description": "Whenever this CV changes, sends a MIDI channel pressure event,\nalso known as ``aftertouch''. This corresponds to keyboards that\njust have one global pressure sensor and not one per key.\n\nIf nothing is patched here, no channel pressure events are sent.\n", "essential": 0, "ramsize": 12}, {"name": "pitchstabilization", "type": "gate", "default": "1", "description": "Enables or disables pitch stabilization. It is on per default\nand can be disabled by setting this jack to 0. Pitch stabilization\nfixes timing issues where the input pitch needs some time for\nreaching the target pitch after a gate.\n", "essential": 0, "ramsize": 12}, {"name": "triggerdelay", "type": "cv", "default": "0", "description": "Introduces a delay between in the incoming gate signal (just the\npositive edge) and the ``note on'' event. This can tackle the\nproblem when your pitch input (sequencer etc.) needs some time\nafter the gate in order to reach and stabilize the target pitch.\nThe delay is specified in milliseconds, so a typical useful value would\nbe 5 (5~ms). This is an alternative to the automatic\n{\\t pitchstabilization}. Note: {\\t triggerdelay} disables\n{\\t pitchstabilization}, as long as that is not set to {\\t 1}\nexplicitly. If both are used at the same time, the {\\t triggerdelay}\nhappens {\\it before} the pitch stabilization. So it is a {\\it minimum}\ndelay.\n", "essential": 0, "ramsize": 12}, {"name": "lowestnote", "type": "integer", "default": "0", "description": "With this input you can restrict the notes being played by setting\na lower bound. In MIDI the notes range from 0 (C-2) to 127 (G9).\nBy setting {\\t lowestnote} to 24 (C0), all notes below this note are simply\nignored. This allows for example for a keyboard split by using\na second circuit with a {\\t highestnote} of 23. Note gates\nare not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"name": "highestnote", "type": "integer", "default": "127", "description": "Sets an upper limit to the note being played, similar to\n{\\t lowestnote}. Note gates are not being affected by this bound.\n", "essential": 0, "ramsize": 12}, {"prefix": "notegate", "name": "notegate1 ... notegate16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "You can define up to 16 notes that can be directly controlled\nwith a dedicated gate. This is convenient for playing drum sounds\ndirectly from triggers and also for using DROID controllers as\nMIDI controllers. A trigger or gate to {\\t notegate1} will directly\nplay the note whose pitch is set by {\\t note1}.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "note", "name": "note1 ... note16", "count": 16, "start_at": 1, "type": "integer", "default": "unpatched", "description": "MIDI notes to played via {\\t notegate}. The range is from\n0 to 127.  Per default the notes are set to the MIDI notes 0, 1, 2\n... 15.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "notegatevelocity", "name": "notegatevelocity1 ... notegatevelocity16", "count": 16, "start_at": 1, "type": "fraction", "default": "1", "description": "Here you can set the velocities use by the notegates.\nIn order to keep it simple, this velocity is used for note on\n{\\it and} note off events (nobody cares about the note off\nvelocity anyway). If you do not use these jacks, the note\ngates will always use the maximum velocity.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "modwheel", "type": "fraction", "default": "0", "description": "Sets the current value of the modulation wheel. Any change\nhere sends a midi CC\\#1 with a new value for the modulation wheel.\nThe input range is 0.0 ... 1.0 and will be converted into the\nMIDI range of 0 ... 127. Note: in future we might support\nCC\\#33, which is the LSB value of CC\\#1 and increases the resolution\nfrom 128 to 16384 different values, at the cost -- however -- of\ntwo additional bytes being sent.\n", "essential": 0, "ramsize": 12}, {"name": "volume", "type": "fraction", "default": "1", "description": "Sets the volume of the target device. This is done by sending the\nMIDI CC\\#7 (VOLUME MSB) and MIDI CC\\#39 (VOLUME LSB). Using these\ntwo CCs enables a 14 bit high resolution 16384 levels (not just 127).\nSome devices to not react to CC\\#39 and simply ignore the LSB (least\nsignificant byte). The volume CV ranges from 0.0 (silent) to 1.0\n(the default).\n", "essential": 0, "ramsize": 12}, {"name": "pitchbend", "type": "cv", "default": "0", "description": "Bends the pitches of {\\it all} currently played notes up\nand down by a range that is configured or elsewhere defined\nby the device that plays our stuff. The range of this CV is\n-1.0 ... 1.0 for covering the maximum pitch bend range. Most\ntimes that range is two semitones up and down. This\nCV does {\\it not} behave in a 1V/oct way!\n", "essential": 0, "ramsize": 12}, {"name": "pitchtracking", "type": "integer", "default": "0", "description": "Pitch tracking is an advanced feature that allows you to track\ncontinuous changes in the incoming pitch CV {\\it while the note\nis already playing}. It does this by listening to the input CV\nand converting any change into a MIDI ``pitch bend'' change.\n\nThis feature has two limitations:\nFirst, there is just one global pitch bend value per channel, not\none per note. So this feature only works in a monophonic situation.\nOnly the value of {\\t pitch1} is being tracked.\nWhen you play more than one note per channel, funny things might\nprobably happen.\nAlso The maximum range is limited by the pitch bend range of\nyour target device. That is usually preset to 2 semitones up and\ndown. If you can increase it, please also adapt {\\t pitchbandrange}\nso this circuit knows about it.\n\nPitch tracking has two levels: {\\t pitchbandrange = 1} will\nalter the pitch of the current note within the maximum range\nof pitch bend and will clip any further changes.\n{\\t pitchbendrange = 2}, in contrast, plays a new note if the\ncurrent range is exceeded. Depending on your sound settings\nthis ``dent'' might be audible or not.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{pitch tracking is off}\n\\jacktablerow{1}{just use MIDI pitch bend}\n\\jacktablerow{2}{use new note on larger changes}\n\\end{tabular}\n\nNote: When you use pitch tracking at the same time as\n{\\t pitchbend}, both pitch alterations will add up.\n", "essential": 0, "ramsize": 12}, {"name": "pitchbendrange", "type": "voltperoctave", "default": "$\\frac{1}{6}$V", "description": "Defines the range of the effect of pitch bend at the target\ndevice on a 1V/oct base. Note: You cannot {\\it change} that actual\nrange here. You just can make sure that this circuit has the correct\nassumption of that range.\n\nIf your target device has a configuration for extending the range,\nand you have set that for example to 1 octave, set {\\t pitchbendrange} to 1~V.\nThis allows {\\t pitchtracking} to correctly adapt in-note pitch\nchanges. Note: This has {\\it no} effect on the {\\t pitchbend} CV.\n", "essential": 0, "ramsize": 12}, {"prefix": "ccnumber", "name": "ccnumber1 ... ccnumber8", "count": 8, "start_at": 1, "type": "integer", "default": "0", "description": "Specifies up to eight different CC numbers that can be continuously\nupdated via the corresponding {\\t cc1} through {\\t cc8} inputs.\nThe value needs to be an integer number from {\\t 0} to {\\t 127}.\n", "essential": 1, "essential_count": 2, "ramsize": 12}, {"prefix": "cc", "name": "cc1 ... cc8", "count": 8, "start_at": 1, "type": "fraction", "default": "unpatched", "description": "The current value of the CCs that are specified with {\\t ccnumber1}\nthrough {\\t ccnumber8}. The range is always from 0.0 to 1.0 (which is\nmapped to the number 0 to 127 on the MIDI wire).\n\nIf you don't patch anything here, no CC events will be sent, of course.\n", "essential": 1, "essential_count": 2, "ramsize": 12}, {"prefix": "cctrigger", "name": "cctrigger1 ... cctrigger8", "count": 8, "start_at": 1, "type": "trigger", "default": null, "description": "Usually {\\t midiout} will send out a new CC event every time the\ninput value of a CC has changed (with some rate limit in order not to\nto flood the MIDI stream).\n\nWhen you use these inputs, an alternative method is enabled. Now\nCC events are created whenever a trigger arrives here. No more\nupdates will be sent automatically.\n\nThis is useful for target devices that use CCs just as {\\it messages},\ni.e. as one time events and not for updating a continous value.\n", "essential": 0, "essential_count": 0, "ramsize": 16}, {"name": "updateccs", "type": "trigger", "default": null, "description": "A trigger here sends an update for all CCs that you have in\nuse (used {\\t cc}X inputs).  Normally an update is just sent once\ninitially and then when the input CV at one of the {\\t cc} inputs\nchanges its value. With the trigger you can force updates. This\nmight be neccessary if the receiving device has lost memory of the\ncurrent states of the CCs (e.g. due to a power cycle).\n\nNote: Other than the {\\t cctrigger}X inputs, this trigger does\n{\\it not} change the way the CC inputs work. It is just a\nhint for \\droid that forces one additonal update.\n", "essential": 0, "ramsize": 16}, {"name": "delayinitialccs", "type": "cv", "default": "1", "description": "When the Droid starts it needs a short time until the X7\nis operating and your PC / DAW is able to receive the MIDI events\nvia USB. Initial CC updates during that short time period might\nget lost and you are missing the correct CC states (which are\nupdated later only on changes).\n\nIn order to avoid that, the Droid wait a short time after\nstarting before it sends the first CC events. That delay can\nbe tuned here. It is a time in seconds.\n", "essential": 0, "ramsize": 12}, {"name": "bank", "type": "integer", "default": "unpatched", "description": "Selects the current ``bank''.\nSome MIDI devices have more than 128 programs (i.e., patches,\ninstruments, preset, etc). A MIDI Program Change message supports\nswitching between only 128 programs. So, ``Bank Select''\n(sometimes also called bank switch) is sometimes used to allow switching\nbetween groups of 128 programs. Bank select uses the MIDI CCs \\#0 (MSB)\nand \\#32 (LSB) together to form a number of 16384 different banks. The\ninput value thus ranges from 1 to 16384.\nMost devices, however, restrict themselves to just 128 banks and just\nuse the MSB (CC\\#0). If that is the case, you need to set\n{\\t bank} to {\\t 128} for bank 2, {\\t 256} for bank 3 and so on. This\ncan be done by simply multiplying the actual bank number with 128.\n", "essential": 0, "ramsize": 12}, {"name": "program", "type": "integer", "default": "unpatched", "description": "Select the current ``program''. This is a number from {\\t 1} to {\\t 128}.\n", "essential": 0, "ramsize": 12}, {"name": "programchange", "type": "trigger", "default": null, "description": "A trigger here will send out a ``program change'' MIDI message even\nif the value of {\\t bank} or {\\t program} has not changed.\n", "essential": 0, "ramsize": 16}, {"name": "start", "type": "trigger", "default": null, "description": "If you send a trigger here, the MIDI message START will be emitted.\nDon't use this jack if you also use {\\t running}. Note: START/STOP\nmessages are not bound to a specific channel.\n", "essential": 0, "ramsize": 16}, {"name": "stop", "type": "trigger", "default": null, "description": "If you send a trigger here, the MIDI message STOP will be emitted.\nDon't use this jack if you also use {\\t running}. Note: START/STOP\nmessages are not bound to a specific channel.\n", "essential": 0, "ramsize": 16}, {"name": "running", "type": "gate", "default": null, "description": "This is an alternative to the jacks {\\t start} and {\\t stop}. It combines\nboth into one ``running'' state. When this gate input goes high,\na START message is sent, when it goes low a STOP message. So you can\nwork with a state rather than with state changes. Note: START/STOP\nmessages are not bound to a specific channel.\n", "essential": 1, "ramsize": 12}, {"name": "systemreset", "type": "trigger", "default": null, "description": "A trigger here will send the MIDI real-time message ``RESET'',\nthat is supposed to bring the device into some start state.\n", "essential": 0, "ramsize": 16}, {"name": "allnotesoff", "type": "trigger", "default": null, "description": "A trigger here will send the MIDI CC\\#123 ``ALL NOTES OFF'', which\nis essentially the same as releasing all currently held keys.\n", "essential": 0, "ramsize": 16}, {"name": "allsoundoff", "type": "trigger", "default": null, "description": "A trigger here will send the MIDI CC\\#120 ``ALL SOUND OFF'', which\nis supposed to make the device silent as soon as possible.\n", "essential": 0, "ramsize": 16}, {"name": "damper", "type": "gate", "default": "0", "description": "This gate input simulates a hold or damper pedal. This is done\nvia the CC\\#64. If the gate goes to high, a value of 127 is being\nsent, when it goes back to low, a value of 0. When the damper pedal\nis pressed, the device is supposed to hold all currently played\nnotes and not react to any subsequent ``NOTE OFF'' {\\it of those\nnotes} as long as the pedal is held. When the pedal is released,\nall notes that had been held be the pedal should be released.\n", "essential": 0, "ramsize": 12}, {"name": "portamento", "type": "gate", "default": "0", "description": "Controls the portamento pedal. The receiver is meant to activate\nsome kind of glide effect as long as this gate is high.\n", "essential": 0, "ramsize": 12}, {"name": "sostenuto", "type": "gate", "default": "0", "description": "This enables the sustain pedal. This is similar to but not exactly\nthe same as the damper pedal as it just holds notes that are pressed\nwhile the pedal goes down.\n", "essential": 0, "ramsize": 12}, {"name": "soft", "type": "gate", "default": "0", "description": "Controls the soft pedal. The receiving synth voice is meant to\nplay notes softer while this pedal is hold down.\n", "essential": 0, "ramsize": 12}, {"name": "legato", "type": "gate", "default": "0", "description": "Controls the legato pedal, which ties subsequent notes together.\n", "essential": 0, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "If you feed a steady clock here, a MIDI clock signal will be\nderived from this and sent through the output wire. The {\\it MIDI beat\nclock} or simply {\\it MIDI clock} is defined to send pulses at 24~PPQN:\n24 pulses per quarter note. One quarter note has four \\nth{16}s, so\nthe MIDI clock is running at 6 pulses per \\nth{16} note, and in the modular\nenvironment it is very common to work with \\nth{16} pulses as a master\nclock. So this {\\t clock} jack is meant to retrieve a modular master clock,\nmultiplies this by 6 and creates a MIDI clock from it.\n", "essential": 1, "ramsize": 30}, {"name": "midiclock", "type": "trigger", "default": null, "description": "This is an alternative to {\\t clock}: don't use both at the same\ntime. Here you can directly send the MIDI clock in 24~PPQN.\n", "essential": 0, "ramsize": 16}, {"name": "activesensing", "type": "gate", "default": "1", "description": "This is a switch that disables or enabled {\\t active sensing}. This\nis a MIDI feature where a MIDI sender emits one message of the type\n``active sensing'' every 300~ms. The receiver can use this in order\nto detect if we are still connected and active and also immediately\nreset (und turn all sound off) if these messages stop. Active sensing\nis enabled per default. You can disable it here by setting {\\t\nactivesensing = 0}.\n", "essential": 0, "ramsize": 12}, {"name": "updaterate", "type": "cv", "default": "50", "description": "Specifies the maximum rate at which continuous controllers like\nthe CCs, volume, pitchbend and channelpressure are updated. This\nlimitation is necessary in order not to flood the MIDI interface\nwith too many updates because of just minimal changes. This\nrate is specified in update per second and the default is 50.\nA zero or negative value will completely stop all updates.\n\nNote: depending on how many events are happening on your channel,\nfewer updates might be possible. MIDI over a classical cable is limited\nto 3125 bytes per second. Events typically need 1, 2 or 3 bytes each.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}], "outputs": [], "presets": 0, "manual": 190, "ramsize": 656}, "midithrough": {"category": "midi", "title": " MIDI routing through X7", "description": "Use this circuit for forwarding MIDI data from an input to an output. Here is\nan example:\n\n\\columnbreak\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midithrough]}[midithrough]\n\\immediate\\write\\patchexamples{    fromusb = 1 # TRUE, hence USB port for input}    fromusb = 1 # TRUE, hence USB port for input\n\\immediate\\write\\patchexamples{    tousb = 0 # FALSE, hence TRS jack for output}    tousb = 0 # FALSE, hence TRS jack for output\n\\end{droidini}\n\nThis will forward MIDI events from the USB port to the TRS output. Note:\nAll \\circuit{midiin} and \\circuit{midiout} circuits still work, so the\noutput stream on the TRS jack will both contain the original events from\nMIDI-USB and the events you create with your {\\t midiout} circuits.\n\nNotes:\n\\begin{itemize}\n\\item As of now, Sysex messages are not forwarded. Sorry for that. If that's\nbecoming important we might add this feature.\n\\item If you forward from USB to TRS make sure that you do not send more\nthan 3125 bytes per second. TRS cannot output faster. It's limited by the\nMIDI standard. If you send MIDI data faster, some events will get lost.\n\\end{itemize}", "inputs": [{"name": "fromusb", "type": "gate", "default": "0", "description": "Set this to {\\t 0} if you want to receive data from the\nTRS/DIN jack and {\\t 1} if you want to receive via USB.\n", "essential": 1, "ramsize": 12}, {"name": "tousb", "type": "gate", "default": "0", "description": "Set this to {\\t 0} if you want to send data to the\nTRS/DIN jack and {\\t 1} if you want to send via USB.\n", "essential": 1, "ramsize": 12}], "outputs": [], "presets": 0, "manual": 199, "ramsize": 208}, "minifonion": {"category": "pitch", "title": " Musical quantizer", "description": "This circuit is a very musical quantizer that gently moves any input CV\n(pitch information on a 1V/oct base) into selected notes of a musical scale.\nTypically the input CV is coming from a random source, LFO, melody generator\nor sequencer.\n\nIn fact the Minifonion is very similar to each of the the three quantizer\nchannels in the Audiophile Circuit League {\\it Sinfonion} -- just without\nthe user interface and more flexible. It has Sinfonion compatible CVs for\nthe root note and the scale selection so it can easily be combined with it\nas long as you control the Sinfonion via CV and stick to the first mode. But\nof course you do not need a Sinfonion in order to use this circuit!\n\nIf you want to mimick a Sinfonion with the \\droid you might also be interested\nin the circuits \\circuit{arpeggio} and \\circuit{chord}.\n\nHere is the simplest possible application -- a quantization of some (random)\ninput pitch at {\\t I1} to the seven notes of a C lydian major scale.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\end{droidini}\n\nNow let's change the root note to D (2 semitones above C) and\nthe scale to natural minor, so that we now quantize to a\nD minor scale:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    root   = 2}    root   = 2\n\\immediate\\write\\patchexamples{    degree = 7}    degree = 7\n\\end{droidini}\n\nAnd here is the table of all 12 scales of the Minifonion. These\nare exactly the same scales as those in the first mode (called {\\it Chords})\nof the Sinfonion:\n\n\\begin{center}\n\\begin{tabular}{|r|l|l|} \\hline\n{\\t degree} & \\footnotesize Abbr. & Scale \\\\ \\hline\n\\t  0 & lyd & Lydian major scale (it has a $\\sharp 4$) \\\\ \\hline\n\\t  1 & maj & Normal major scale (ionian)     \\\\ \\hline\n\\t  2 & X$^7$ & Mixolydian (dominant seven chords) \\\\ \\hline\n\\t  3 & sus & mixolydian with \\nth3/\\nth4 swapped \\\\ \\hline\n\\t  4 & alt & Altered scale \\\\ \\hline\n\\t  5 & hm$^5$ & Harmonic minor scale from the \\nth5 \\\\ \\hline\n\\t  6 & dor & Dorian minor (minor with $\\sharp 13$) \\\\ \\hline\n\\t  7 & min & Natural minor (aeolian) \\\\ \\hline\n\\t  8 & hm & Harmonic minor ($\\flat 6$ but $\\sharp 7$) \\\\ \\hline\n\\t  9 & phr & Phrygian minor scale (with $\\flat 9$) \\\\ \\hline\n\\t 10 & dim & Diminished scale (whole/half tone) \\\\ \\hline\n\\t 11 & aug & Augmented scale (just whole tones) \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\nIf you are a Sinfonion user, please note that the inputs {\\t root} and {\\t\ndegree} of the Minifonion are {\\it not} based on semitones like the Sinfonion,\nbut simply expect whole numbers like {\\t 0}, {\\t 1}, {\\t 2} and so on (which\ncorresponds to the CVs 0V, 10V, 20V, etc.). So if you want those CV inputs\nto be compatible, you have to multiply the values with the factor of 120\nbefore sending them to the Minifonion:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[minifonion]}[minifonion]\n\\immediate\\write\\patchexamples{    input  = I1}    input  = I1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    root   = I2 * 120 # base on semitones}    root   = I2 * 120 # base on semitones\n\\immediate\\write\\patchexamples{    degree = I3 * 120 # base on semitones}    degree = I3 * 120 # base on semitones\n\\end{droidini}\n\n\\clearpage", "inputs": [{"name": "input", "type": "voltperoctave", "default": "0", "description": "Patch the unquantized input voltage here\n", "essential": 2, "ramsize": 12}, {"name": "trigger", "type": "trigger", "default": null, "description": "This jack is optional. If you patch it, the Minifonion will\nwork in triggered mode. Here the output pitch is always frozen until the\nnext trigger happens.\n", "essential": 1, "ramsize": 16}, {"name": "bypass", "type": "gate", "default": "off", "description": "If you set this gate input to {\\t 1} then quantization is bypassed\nand the input voltage is directly copied to the output.\n", "essential": 1, "ramsize": 12}, {"name": "noteshift", "type": "integer", "default": "0", "description": "Shifts the output note {\\bf after} the quantization by this\nnumber of {\\it scale} notes up or down (if negative). So the output\nnote still is part of the scale but may be a note that is none\nof the selected ones. {\\t noteshift} is applied when quantization\ntakes places, so it also is sensible to the {\\t trigger} input.\n", "essential": 0, "ramsize": 12}, {"name": "selectnoteshift", "type": "integer", "default": "0", "description": "Shifts the output note {\\bf after} the quantization by this\nnumber of {\\it selected} scale notes up or down (if negative).\nIf you use {\\t noteshift} at the same time, {\\it first} {\\t\nselectnoteshift} is applied, then {\\t noteshift}.\n{\\t selectnoteshift} is applied when quantization\ntakes places, so it also is sensible to the {\\t trigger} input.\n", "essential": 0, "ramsize": 12}, {"name": "root", "type": "integer", "default": "0", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{C}\n\\jacktablerow{1}{C\\sharp}\n\\jacktablerow{2}{D}\n\\jacktablerow{3}{D\\sharp}\n\\jacktablerow{4}{E}\n\\jacktablerow{5}{F}\n\\jacktablerow{6}{F\\sharp}\n\\jacktablerow{7}{G}\n\\jacktablerow{8}{G\\sharp}\n\\jacktablerow{9}{A}\n\\jacktablerow{10}{A\\sharp}\n\\jacktablerow{11}{B}\n\\jacktablerow{12}{C}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "degree", "type": "integer", "default": "0", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{lyd -- Lydian major scale (it has a $\\sharp 4$)}\n\\jacktablerow{1}{maj -- Normal major scale (ionian)}\n\\jacktablerow{2}{X$^7$ -- Mixolydian (dominant seven chords)}\n\\jacktablerow{3}{sus -- mixolydian with \\nth3/\\nth4 swapped}\n\\jacktablerow{4}{alt -- Altered scale}\n\\jacktablerow{5}{hm$^5$ -- Harmonic minor scale from the \\nth5}\n\\jacktablerow{6}{dor -- Dorian minor (minor with $\\sharp 13$)}\n\\jacktablerow{7}{min -- Natural minor (aeolian)}\n\\jacktablerow{8}{hm -- Harmonic minor ($\\flat 6$ but $\\sharp 7$)}\n\\jacktablerow{9}{phr -- Phrygian minor scale (with $\\flat 9$)}\n\\jacktablerow{10}{dim -- Diminished scale (whole/half tone)}\n\\jacktablerow{11}{aug -- Augmented scale (just whole tones)}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "select1", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n", "essential": 1, "ramsize": 12}, {"name": "select3", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{3}.\n", "essential": 1, "ramsize": 12}, {"name": "select5", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{5}.\n", "essential": 1, "ramsize": 12}, {"name": "select7", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{7}.\n", "essential": 1, "ramsize": 12}, {"name": "select9", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n", "essential": 1, "ramsize": 12}, {"name": "select11", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n", "essential": 1, "ramsize": 12}, {"name": "select13", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n", "essential": 1, "ramsize": 12}, {"name": "selectfill1", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill2", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill3", "type": "gate", "default": "off", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill4", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill5", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "voltperoctave", "default": null, "description": "Here comes your quantized output voltage\n", "essential": 2, "ramsize": 4}, {"name": "notechange", "type": "trigger", "default": null, "description": "Whenever the quantization changes to a new note a trigger\nwith the duration 10~ms is output here. No trigger is\noutput in bypass mode.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 200, "ramsize": 88}, "mixer": {"category": "cv", "title": " CV mixer", "description": "The main task of this circuit is simply adding up to eight inputs. Furthermore\nit can do simple operations like minimum, maximum and average. Please note that\nsince every input can always be offset and attenuated, it's like a mixer\nwith a CV controlled level and CV controlled offset per input channel.\n\nMinimal example, mixing together two inputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nSince every input can add an offset, mixing four inputs can be\ndone with two lines if you like:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[mixer]}[mixer]\n\\immediate\\write\\patchexamples{    input1 = I1 + I2}    input1 = I1 + I2\n\\immediate\\write\\patchexamples{    input2 = I3 + I4}    input2 = I3 + I4\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nPlease note that an unpatched input is (sometimes) not the same as an input where {0.0}\nis being sent. The difference arises if you use {\\t minimum}, {\\t maximum} and {\\t average}, since\nthese just consider the patched inputs.\n\nIf eight inputs are not enough then you can simply create a mesh by mixing together the\noutputs of several submixers.", "inputs": [{"prefix": "input", "name": "input1 ... input8", "count": 8, "start_at": 1, "type": "cv", "default": "0", "description": "\\nth1 ... \\nth 8 mixing input\n", "essential": 2, "essential_count": 2, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Sum of all patched inputs\n", "essential": 2, "ramsize": 4}, {"name": "maximum", "type": "cv", "default": null, "description": "Maximum of all patched inputs of this circuit. This can e.g. be used for mixing together the\nenvelopes from several sequencer tracks without making them ``louder''\nor distorting them when two sequencers play a note at the same time.\n", "essential": 0, "ramsize": 4}, {"name": "minimum", "type": "cv", "default": null, "description": "Minimum of all patched inputs of this circuit.\n", "essential": 0, "ramsize": 4}, {"name": "average", "type": "cv", "default": null, "description": "Average of all patched inputs of this circuit.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 204, "ramsize": 40}, "motoquencer": {"category": "sequencing", "title": " Motor fader sequencer", "description": "This circuit allows you to build simple but also very complex performance\nsequencers based on motorized faders. It supports up to 32 steps and up to\neight M4 controllers with up to 32 faders. The list of features is long and\ndiverse and aims at supporting creative live performances.\n\nYou probably will fail to map all existing inputs to controls, so better\ndon't try and rather experiment with just a fraction of those at a time.\n\n\\subsubsection*{Basic minimal example}\n\nDespite all the features, this sequencer is easy to get started with.\nHere is the smallest possible example. You always need a clock\ninput. Here I get it from input {\\t I1}.  You need to have at least one M4\nunit attached to your \\droid (and declared with {\\t [m4]} in your patch).\nThe motor sequencer automatically configures all your available faders\n(up to 32) for the sequencer (you can change that with {\\t firstfader}\nand {\\t numfaders}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O2}    gate = O2\n\\end{droidini}\n\nAs soon as your clock starts, you get a sequence with one step per available\nfader (which is four if you have just one {\\t [m4]} declared). The faders select\nnotes from a C lydian scale in two octaves. You will feel 15 notches. They\ncorrespond to the 15 notes in this range.  The touch buttons below the faders\nswitch on/off the gates.\n\nThe pitch is output at {\\t O1} and the gate at {\\t O2}. Well -- this\nwouldn't have needed expensive motor faders, but it works and shows a minimal\napplication of {\\t motoquencer}.\n\n\\subsubsection*{Switching pages}\n\nYour sequence can have more steps than you have faders. This is done by\nswitching {\\it pages}. In the following example we assume that you have\njust one M4 but want a sequencer with 16 steps. Use the {\\t page} input in\norder to set the current page (group of 4 steps) that you want to see and\nedit with your faders. These pages have the numbers {\\t 0}, {\\t 1}, {\\t 2}\nand {\\t 3}. That number can nicely be output by a \\circuit{buttongroup} on a P2B8.\nHere is a fully functional example of a 16 step sequencer with just four\nfaders:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{    output = _PAGE}    output = _PAGE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 20 * P1.1}    hz = 20 * P1.1\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    page = _PAGE}    page = _PAGE\n\\immediate\\write\\patchexamples{    numsteps = 16}    numsteps = 16\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O5}    gate = O5\n\\end{droidini}\n\n\\subsubsection*{Repeats, Ratchets and Randomize}\n\nIn the upper examples we just had two parameters per step of the sequence:\nThe pitch / CV and the gate. There are some more. Altogether every step\nhas the following eight parameters:\n\n\\begin{tabular}{|l|l|} \\hline\n\\t 0 & pitch / CV          \\\\ \\hline\n\\t 1 & randomize CV        \\\\ \\hline\n\\t 2 & gate propability    \\\\ \\hline\n\\t 3 & repeats (up to 16)  \\\\ \\hline\n\\t 4 & gate pattern        \\\\ \\hline\n\\t 5 & ratchets (up to 8)  \\\\ \\hline\n\\t 6 & gate                \\\\ \\hline\n\\t 7 & skip                \\\\ \\hline\n\\end{tabular}\n\nEach of these parameters has a number from {\\t 0} to {\\t 7} and you can set\nthe input {\\t fadermode} to one of these in order to switch the faders to\ncontrol that parameter. Here are some details about the various parameters:\n\n{\\bf Pitch / CV} is the output pitch of each step. With the inputs {\\t cvbase}\nand {\\t cvrange} you can define a voltage range for those CVs. Per default,\nthe CV is quantized to a musical scale, but you can change that with {\\t\nquantize} (see below).\n\n{\\bf Randomize CV} is a number from 0 (fader at the bottom) to 7 (fader at\nthe top). 0 means randomization is off. The other 7 steps will increasingly\nmodify the step's CV by adding a different random offset each time the step\nis played.  At position 7 (the maximum), the offset is up to {\\t cvrange},\nso if your CV is at maximum, this could double up your CV range.\n\n{\\bf Gate propability} also has 8 settings. Here the maximum (fader at top\nposition) is the default and means: this step is always played, if the gate\nis on. The other seven settings will reduce the propability of this step\nbeing played. The lowest setting still leaves a small chance. Turn off the gate\nto silence a step completely.\n\nBut this propability is not simply a random chance. It has several very\nmusical settings as you can see from the following table. Here you\nsee the eight fader positions and their meaning -- 8 being the top\nposition and 1 the bottom position:\n\n\\begin{tabular}{|l|l|r|} \\hline\nPos.       & Meaning  &       \\\\ \\hline\n8 (top)    & played always                & 100\\% \\\\ \\hline\n7          & random chance of 50\\%        & 50\\% \\\\ \\hline\n6          & played every {\\it even} turn & 50\\% \\\\ \\hline\n5          & played every {\\it odd} turn  & 50\\% \\\\ \\hline\n4          & random chance of 25\\%        & 25\\% \\\\ \\hline\n3          & played every \\nth4 turn      & 25\\% \\\\ \\hline\n2          & random chance of 12\\%      & 12\\% \\\\ \\hline\n1          & played if last random was positive & -- \\\\ \\hline\n\\end{tabular}\n\nThe LEDs below the faders indicate the current setting with different\ncolor and blink codes:\n\n\\begin{itemize}\n\\item Gates that are played always are blue with a constant light.\n\\item Random gates for 50\\%, 25\\% and 12\\% are in the same blue but\nblink in various speeds.\n\\item Gates of setting 1 (conditional random) are blinking fast.\n\\item Gates depending on the turn (3, 5 and 6) are in cyan color and light\n{\\it steadily} in the bars (turns) where they are {\\it on} and blink in the other\nbars.\n\\end{itemize}\n\nThe position 6 and 5 are very musical and can transform a pattern of length\n8 into an effective melody of 16 steps.  A step in position 6 is just played\nevery second run of the whole sequence. Position 5 is just the same but\nstarts with the first run and will then be played on run 3, 5, and so on.\n\nPosition 4 is similar, but these steps will just be played every fourth\nsequence run, so you can use it for playing things like a pickup or break\nor the like. These ``run counters'' are reset by the {\\t reset} input.\n\nThe bottom position of 1 is an addition for the true random positions 7,\n4 and 2: A step in position 1 is played, whenever the {\\it most recent}\nrandom decision of positions 7, 4 and 2 was {\\it positive}. It allows you\nto create groups of notes that are either played completely or not at all:\nSet the first step of these to a random propability of 50, 25 or 12\\%. And\nthe remaining notes to position 1. Now whenever fate decides that the first\nnote is being played, so will all remaining ones. These steps do not need\nto be subsequent. You can have wholes.\n\n{\\bf Repeats} changes the number of clock cycles one step will last. It is a\nnumber from 1 (fader at the bottom) to 16 (fader at the top). This setting\nchanges the total duration of one sequence cycle. If you set repeats to\n2 for one of 16 steps, your sequence will last 17 clock cycles.\n\nThe {\\bf Gate pattern} decides how gates are played when {\\it repeats} is 2\nor larger. There are four gate patterns, which you can feel in the fader. In\nthe first setting (fader down) just the first repetition of the step is\n``played'' (i.e.  a gate signal sent). Setting 2 will play one gate per\nrepetition. Setting 3 plays one long gate. And setting 4 is like 3 but lets\nthe gate open when the step ends. This ties this step to the next one. And\nthis setting also has an effect when {\\t repeats} is just 1.\n\n{\\bf Ratches} can be set from 1 (normal) to 8. It divides the clock cycle of\nthe step into equal time intervals in which the step is repeated. If you set\nratchets to 2, for example, you will get two notes played at double time.\nRatchets do {\\it not} change the duration of the sequence.\n\nThe remaining two settings are usually set with the touch buttons, but you\ncan also use the faders.\n\n{\\bf Gate} decides wether the step is ``played''. If it is played, its CV\nwill be sent to the {\\t cv} output and the {\\t gate} signal is set to high\nfor half a clock cycle (you can change all this, no worries).\n\nSteps with {\\bf Skip} enabled will be skipped. This shortens the duration\nof the sequence. Note: if {\\it all} steps are set to skip, the sequencer\nrepeats playing the most recent step over and over.\n\nSo let's now make an example where we use a button group for setting {\\t\nfadermode}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    button5 = B1.5}    button5 = B1.5\n\\immediate\\write\\patchexamples{    button6 = B1.6}    button6 = B1.6\n\\immediate\\write\\patchexamples{    button7 = B1.7}    button7 = B1.7\n\\immediate\\write\\patchexamples{    button8 = B1.8}    button8 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{    led5 = L1.5}    led5 = L1.5\n\\immediate\\write\\patchexamples{    led6 = L1.6}    led6 = L1.6\n\\immediate\\write\\patchexamples{    led7 = L1.7}    led7 = L1.7\n\\immediate\\write\\patchexamples{    led8 = L1.8}    led8 = L1.8\n\\immediate\\write\\patchexamples{    output = _FADERMODE}    output = _FADERMODE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 20 * P1.1}    hz = 20 * P1.1\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    fadermode = _FADERMODE}    fadermode = _FADERMODE\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O5}    gate = O5\n\\end{droidini}\n\n\\subsubsection*{Button mode}\n\nVery similar to the faders, also the touch buttons have modes. These can be\nswitched with {\\t buttonmode} and here are the possible settings:\n\n\\begin{tabular}{|l|l|} \\hline\n\\t 0 & gates \\\\ \\hline\n\\t 1 & start / end \\\\ \\hline\n\\t 2 & gate pattern \\\\ \\hline\n\\t 3 & skip \\\\ \\hline\n\\end{tabular}\n\nThree of these settings you already know from the {\\t fadermode}.\nWhen the buttons are set to {\\t gate pattern}, you cycle through\nthe four steps each time you touch the button (and the LED cycles\nthrough four colors).\n\nFun fact: You can set {\\t fadermode = 6} and {\\t buttonmode = 0}.\nThat way, both the button and the fader control the gates. Try\nthis out and touch the buttons: the fader will move automatically.\n\nThe mode ``start / end'' cannot be set with the faders. They set a sub range\nof the sequence to be played. Here is what it means:\n\n\n\\subsubsection*{Start and end}\n\nUsually your sequence is played from the first to the last step.  But you\ncan change this by setting a start step and an end step.  This can either\nbe done manually (with {\\t buttonmode = 1} or with the inputs {\\t startstep}\nand {\\t endstep}.\n\nIn {\\t buttonmode = 1}, the start step has a green LED and the end step a\nred one. Both start and end can be at the same step (creating a one step\nsequence). The LED will then blink between red and green.\n\nTouching a button changes the {\\bf end} step.  You can set the start step\nby first setting an end step and {\\bf holding} that button and then -- with\na second finger -- press another step. That will be the start step.\n\nIf the start step is after the end step, the play order is reversed.\n\n\n\\subsubsection*{Quantization, root and scale}\n\nPer default, the CVs are quantized to the notes of a lydian C major scale,\nas is the default for many other circuits, as well. This means that the\nfaders have one artifical notch for each scale note. You can {\\it feel}\nthe notes. This makes it easy to change the note in exact steps without\nany display.\n\nAs with many other pitch-aware circuits, like for example \\circuit{minifonion}\nor \\circuit{chords}, you can use {\\t root} and {\\t degree} for changing\nthe scale. See in the table of inputs below for the different possible scales.\nNote: {\\t root} has no effect on the lower CV boundary. It's just\nfor the selection of the allowed notes. Use {\\t cvbase} for setting that.\n\nFurthermore, there are the inputs {\\t select1}, {\\t select3}, ... You can\nuse them to further restrict the possible notes -- or even add notes that\nare not contained in the scale. Refer to the \\circuit{minifonion} circuit\nfor a broader discussion of these inputs.\n\nNote: If you have set a melody with the faders and reduce the number of allowed\nnotes afterwards, the faders will possibly move to new positions. But as long\nas you don't touch them, they will internally ``remember'' their original\nnote. If you later re-add the missing notes, the faders will move back and\nyour original melody is restored.\n\nWith the input {\\t quantize} you can switch off the musical mode.  {\\t quantize\n= 0} disables quantiziation and the faders create a continous CV (the internal\nresolution is 127 steps, just like in a MIDI CC). And {\\t quantize = 1}\nwill quantize to semitones ($\\frac{1}{12}$~V steps).\n\nNote: The maximum number of notches is {\\t 201}. But if you select more than\n25 notches, the force feedback is turned off as the notches would get too\nsmall to work. This number of 25 ``real'' notches nicely matches the 25\npossible semitones of two octaves. If you increase that range, the notches\nare switched off.\n\n\\subsubsection*{Direction, ping pong, movement patterns}\n\nThe Motoquencer has quite a bunch of interesting features for changing\nthe order in which steps are being played. Some of them, like the playing\ndirection or ``ping pong'', are the usual suspects and common among sequencers.\nThe ``playing patterns'' and ``forms'' go beyond this and create interesting\ncreative possibilities.\n\n{\\t direction} defaults to {\\t 0}, which means ``forwards''. Set this\nto {\\t 1} (e.g. with a toggle button) to run the sequence backwards.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    direction = 1 # backwards}    direction = 1 # backwards\n\\end{droidini}\n\n{\\t pingpong} is another switch. Setting it to {\\t 1} enables ``ping\npong mode''. Here the direction switches back and forth. Depending on {\\t\ndirection}, the sequence starts at the start step or the end step, moves\ntowards the other end and then turns around in order to come back. Note:\nSince the steps at the turning points are played just once, a sequence of\n8 steps in ping pong mode has a duration of 14, not 16.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    pingpong = 1 # enable ping pong}    pingpong = 1 # enable ping pong\n\\end{droidini}\n\n{\\t pattern} changes the way how the sequencer steps through the sequence.\nPattern {\\t 1} for example goes always two steps forwards (according to\n{\\t direction} and {\\t pingpong}) and then one step backwards.  Assuming {\\t\ndirection = 0} and {\\t pingpong = 0}, the step order would be 1, 2, 3, 2,\n3, 4, 3, 4, 5, 4, 5, 6 and so on. The available patterns are much the same\nas in the \\circuit{arpeggio} circuit with the addition of pattern {\\t 6},\nwhich goes forwards in small random steps.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    pattern = 3 # set pattern 3}    pattern = 3 # set pattern 3\n\\end{droidini}\n\n\\subsubsection*{Forms like AAAB}\n\nAlready confused? Then you probably won't like the ``Forms'' feature!\nHere we create longer sequences by first dividing the steps into\ntwo (or three parts), and then playing these parts in certain orders.\n\nThe most useful form (except the trivial {\\t 0}) is probably {\\t 1}, which is\nAAAB. Here the steps are divided into a first half, which is called A, and a\nsecond half, which is called B. The A part is always played thrice and then\nonce the B part. Assuming you have 8 steps (and all the other fancy stuff is\noff), the step order would be 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8.\n\nThe patterns with the three parts A, B, and C divide the steps into three\nequal sized parts. You better make sure that you have 6 or 12 or 24 steps\nin that case, or else your parts won't have equal size (which on the other\nhand could be funny anyway).\n\nThe forms can be combined with {\\t direction}, {\\t pingpong} and {\\t pattern}.\nHere stepping modifications are always applied {\\it within each individual\npart}.\n\nThe forms can also be combined with the start and end point. Here just the\nsteps between start and end are divided into parts.\n\n\\subsubsection*{Autoreset}\n\nIn contrast to the all the upper modifications of the step order, {\\t\nautoreset} is super simple. It resets the whole sequence (including parts)\nto the very beginning after a specified number of clock ticks.\n\nThere are two typical applications: First, if you want to make sure that the pattern\nrepeats in some regular way despite crazy modifications,  set {\\t autoreset =\n16} and the sequence will restart exactly very \\nth{16} clock tick. If it is\nlonger, it will be truncated. If it is shorter, it first repeats, but then\nthe repetition is truncated.\n\nOn the other hand you can make a regular sequence irregular, if you set\ne.g. {\\t autoreset = 7} in a sequence with usually 16 steps, thus forcing\npolymetric shifts with other parallel rhythms.\n\nWhen you use the special gate ``propabilities'' odd and even in combination\nwith autoreset, please note that after a reset the odd / even count always\nstarts with odd.\n\n\\subsubsection*{The Metric Saver}\n\n\\def\\tms{{\\it The Metric Saver}\\textsuperscript{\u2122} }\n\n\\tms is a very musical feature that allows you to go bonkers with all start,\nend, direction, ping pong, pattern, form, repeats, autoreset and skips\nwithout loosing the sync to the rest of your music.\n\nIf \\tms is turned on (which is the default), the {\\t\nmotoquencer} automatically keeps track of the original incoming clock count.\nAs soon as -- after a polymetric journey -- you come back to ``normal'',\nit jumps to the step that {\\it would} have been the current one without\nthose alterations.\n\nAn example: You set {\\t autoreset} to 7 in order to create polymetric tension.\nLater you set it back to {\\t 0}. Now the sequence immediately jumps to the\nstep where it would have been without {\\t autoreset} (this requires that none of\nthe other step changing features are in use). You snap back to your original\ngroove and are in sync again with the rest of your modular ``band''.\n\nNote: \\tms is only activated when really {\\it all} modifications to the\nnormal step order are turned off. That also includes steps where ``repeats''\nor ``skip'' is used, since they also introduce time shifts.\n\n\n\\subsubsection*{I Feel Lucky}\n\n\\def\\ifl{{\\it I Feel Lucky}\\textsuperscript{\u2122}\\xspace}\n\nThe Motoquencer has a powerful system of {\\it one time randomization},\nwhich is called \\ifl.  While setting random CVs or gate propabilities is quite\ncommon amongst sequencers, here we talk of something different. By sending\na trigger to a certain input, some of your steps are randomly modified --\nand stay that way. If your faders currently show these steps, you will\nimmediately see them moving around. And they stay there, so that you can manually\nmodify the random decision if you like. Those triggers are most times sent by buttons, but\nalso slowly running LFOs or using the {\\t startofsequence} as a trigger are fine.\n\nLet's make a simplified example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    ... usual stuff goes here ...}    ... usual stuff goes here ...\n\\immediate\\write\\patchexamples{    luckychance = P1.1}    luckychance = P1.1\n\\immediate\\write\\patchexamples{    luckyamount = P1.2}    luckyamount = P1.2\n\\immediate\\write\\patchexamples{    luckycvs = B1.1 # press to reroll CVs}    luckycvs = B1.1 # press to reroll CVs\n\\end{droidini}\n\nAll {\\it lucky} operations honor the {\\t luckychance} input.  This sets the\nrelative number of steps that is affected by the randomization. Setting it\nto {\\t 1} will affect all steps.  At {\\t 0}, no step is affected. At {\\t 0.5}\n{\\it exactly} half of the steps is affected, randomly chosen from all steps\n{\\it between start and end}.\n\nA trigger to {\\t luckycvs} sets a new random CV value for each affected\nstep. And with the pot {\\t luckyamount} you control the maximum CV that's\npossible here.\n\nYou can use this mechanism also to reset things. A trigger at {\\t luckycvs}\nwhith {\\t luckyamount = 0} and {\\t luckychance = 1} will bring all steps\nback to the CV set by {\\t cvbase}.\n\nPlease have a look at the table of inputs for all the other {\\t lucky...}\ntriggers and ... {\\it feel lucky!}\n\n\n\\subsubsection*{Multiple tracks}\n\nEach {\\t motoquencer} circuit has just one CV and one gate output. In many\ncases it is desirable to have several CVs and maybe also additional gate\noutputs as part of a sequence. Also you probably want more sequencers using\nthe same faders, of course.\n\nThis is done by adding more instances of {\\t motoquencer} to your patch.\nThe easiest way is to use the {\\t select} input of each of these, in order to\nmake sure that at every time exactly {\\it one} {\\t motoquencer} is selected\nand gets access to the motor faders.  You really shouldn't try selecting\nmore than one at the same time, or your faders will get crazy!\n\nHere is an example with the two buttons {\\t B1.7} and\n{\\t B1.8} selecting one of two sequencers:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.7}    button1 = B1.7\n\\immediate\\write\\patchexamples{    button2 = B1.8}    button2 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.7}    led1 = L1.7\n\\immediate\\write\\patchexamples{    led2 = L1.8}    led2 = L1.8\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 20 * P1.1}    hz = 20 * P1.1\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    select = L1.7}    select = L1.7\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O5}    gate = O5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    select = L1.8}    select = L1.8\n\\immediate\\write\\patchexamples{    cv = O2}    cv = O2\n\\immediate\\write\\patchexamples{    gate = O6}    gate = O6\n\\end{droidini}\n\nThis simple patch is a fully functional two-track four-step sequencer.\nAnd as long as you don't run out of RAM, you can add as many tracks as you\nlike.\n\nOne thing you have to have in mind: These sequencers can easily go out of sync.\nJust play around with the start or end step or skip or repeats. While that\n{\\it can} be interesting, sometimes it is not desirable. Maybe you just want\nevery step to have additional CV or gate values.\n\nThis can be done by {\\bf linking} two or more instances of {\\t motoquencer}\ntogethery. To do that, add the following line to the first instance:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    linktonext = 1}    linktonext = 1\n\\end{droidini}\n\nAt the next {\\t motoquencer} in the patch, don't wire {\\t clock} or {\\t reset}\nor anything else that deals with stepping or direction or faders. Just connect\nthe outputs. The linked sequencer is {\\it remote controlled}.\n\nSome inputs still apply for the linked sequencer. One example is {\\t cvbase}\nand {\\t cvrange}. Any parameter that has an influance on which step is played\nwhen, however, is ignored. That task is done by the main sequencer.\n\nHere is a complete example that adds one additional CV and one gate to a\nsequencer. Note: The fader modes 10 and 16 give you access to the\nmodes 0 and 6 of the linked sequencer. Simply add 10 for each sequencer in\nthe chain.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    button5 = B1.5}    button5 = B1.5\n\\immediate\\write\\patchexamples{    button6 = B1.6}    button6 = B1.6\n\\immediate\\write\\patchexamples{    button7 = B1.7}    button7 = B1.7\n\\immediate\\write\\patchexamples{    button8 = B1.8}    button8 = B1.8\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{    led5 = L1.5}    led5 = L1.5\n\\immediate\\write\\patchexamples{    led6 = L1.6}    led6 = L1.6\n\\immediate\\write\\patchexamples{    led7 = L1.7}    led7 = L1.7\n\\immediate\\write\\patchexamples{    led8 = L1.8}    led8 = L1.8\n\\immediate\\write\\patchexamples{    output = _FADERMODE}    output = _FADERMODE\n\\immediate\\write\\patchexamples{    value7 = 10 # CV of sequencer 2}    value7 = 10 # CV of sequencer 2\n\\immediate\\write\\patchexamples{    value8 = 16 # gate of sequencer 2}    value8 = 16 # gate of sequencer 2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 20 * P1.1}    hz = 20 * P1.1\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    fadermode = _FADERMODE}    fadermode = _FADERMODE\n\\immediate\\write\\patchexamples{    linktonext = 1}    linktonext = 1\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O5}    gate = O5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    cv = O2}    cv = O2\n\\immediate\\write\\patchexamples{    gate = O6}    gate = O6\n\\end{droidini}\n\nIf you need more than two CVs, you can create even longer chains, for example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    fadermode = _FADERMODE}    fadermode = _FADERMODE\n\\immediate\\write\\patchexamples{    linktonext = 1}    linktonext = 1\n\\immediate\\write\\patchexamples{    cv = O1}    cv = O1\n\\immediate\\write\\patchexamples{    gate = O5}    gate = O5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    linktonext = 1}    linktonext = 1\n\\immediate\\write\\patchexamples{    cv = O2}    cv = O2\n\\immediate\\write\\patchexamples{    gate = O6}    gate = O6\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    cv = O3}    cv = O3\n\\immediate\\write\\patchexamples{    gate = O7}    gate = O7\n\\end{droidini}\n\nSimply add a {\\t linktonext} at every instance except the last.  And add\n10 to {\\t fadermode} for every sequencer. For example {\\t fadermode = 25}\nselects fader mode 5 on the third sequencer in the chain.\n\nHere are some details, what linking exactly means for the linked sequencer:\n\n\\begin{itemize}\n\n\\item The linked sequencer does not react to {\\t clock}, {\\t reset}, {\\t\nstartstep}, {\\t endstep}, {\\t form}, {\\t direction}, {\\t pingpong}, {\\t\npattern}, {\\t autoreset}, {\\t shiftsteps} or any other potential means of\ninfluencing the play order of the steps.  Instead the current step number\nof the linked sequencer will always be the same as the step number of the\nmain sequencer.\n\n\\item If you use {\\t shiftsteps}, {\\t luckyshuffle} or {\\t luckyreverse} on\nthe main sequencer, the exact same rearrangement of steps will happen at\nthe linked sequencers.\n\n\\item If the main sequencer plays repeats, so does the linked one.\nThe ``repeats'' setting of the linked sequencer's steps are ignored.\n\n\\item If the main sequencer skips a step, so does the linked one. The\n``skip'' property of steps in the linked sequencer are ignored, as well.\n\n\\item Ratches still work independently, since they don't change the step\nsequence.\n\n\\item Also the gate pattern of the linked sequencer will be applied.\n\n\\item In the linked sequencer, {\\t holdcv} has one additional value: {\\t 2}.\nIf you set it to {\\t 2}, the CV output of the linked sequencer is synchronized\nto the gate of the linked sequencer, not to that of the main sequencer.\n\n\\item Don't use {\\t select}, {\\t fadermode} and {\\t buttonmode} on the linked\nsequencer. They are ignored. Instead, for accessing the parameters of the steps\nof the linked sequencer, add {\\t 10} to {\\t fadermode} or {\\t buttonmode}. So\nwhile {\\t fadermode = 1} sets the fader to the CV randomization of the main\nsequencer, so does {\\t fadermode = 11} for the linked sequencer.\n\n\\end{itemize}\n\nThe following parameters are still valid for the linked sequencer:\n\n\\begin{itemize}\n\\item {\\t cvbase}, {\\t cvrange} and {\\t quantize}\n\\item {\\t gatelength}\n\\item {\\t holdcv} (with the extra value {\\t 2})\n\\item {\\t luckychance}, {\\t luckyamount} and all of the other {\\t lucky...}\n   paramters, with the exception of {\\t luckyskips}, {\\t luckyrepeats},\n   {\\t luckyshuffle} and {\\t luckyreverse}.\n\\end{itemize}\n\n\\subsubsection*{Recording with a keyboard}\n\nYou can use a keyboard to record sequences into your motoquencer.\nMore precisely, you can attach a CV / gate input for that purpose.\nThat {\\it might} very well come from a keyboard attached to the X7,\nvia the circuit \\circuit{midiin}. But any other source is possible,\nas well.\n\nThe first step is attaching your recording source to {\\t keyboardcv}\nand {\\t keyboardgate}. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[midiin]}[midiin]\n\\immediate\\write\\patchexamples{    cv = _CV}    cv = _CV\n\\immediate\\write\\patchexamples{    gate = _GATE}    gate = _GATE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motoquencer]}[motoquencer]\n\\immediate\\write\\patchexamples{    keyboardcv = _CV}    keyboardcv = _CV\n\\immediate\\write\\patchexamples{    keyboardgate = _GATE}    keyboardgate = _GATE\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nAfter doing this, you should already be able to play with your keyboard\ndirectly to the voice that's attached to the motoquencer. While a key is\npressed ({\\t keyboardgate} is high), the {\\t keyboardcv} has precedence over\nthe sequence. But you can change that with the setting {\\t keyboardmode}.\n\nTo record your keyboard into a sequence, you need to connect {\\t recordmode},\nmaybe to a \\circuit{button}.  While recording is active and the keyboard\ngate is high, the current sequencer step will be replaced with your keybaord\nnote. Otherwise the steps are untouched. That way you play more and more\nnotes into the sequence.\n\nIn order to get rid of existing notes, either clear the sequence before\nrecording (using the {\\t clear} trigger), or make use of the input {\\t\nrecordsilence}. Setting that to {\\t 1} will silence all steps when no key\nis pressed.\n\nYou also can route {\\t recordsilence} to one key on your keyboard using the\n{\\t notegate} outputs of {\\t midiin}.  That way you can actively ``erase''\nnotes by pressing that key.\n\nWhile recording key presses the motoquencer tries to be tolerant with respect\nto your timing. So keys pressed slightly before or after the current clock\ntick are just fine.\n\nNote: The sequencer can just record into its grid of steps and quantized\nnotes. So it's not a free style MIDI recorder. You cannot record notes\nthat are faster than your input clock. If you have enabled quantiziation,\nyou can just play notes from the current scale. So it needs some time to\nget familiar with this way of recording. Nevertheless it's a great tool for\nrapid composition. Especially because it's easy to modify your melodies with\nthe faders after you have recorded them.\n\n\\subsubsection*{Recording \\& linked sequencers}\n\nWhen you have combined several {\\t motoquencers} with {\\t linktonext = 1},\nrecording also works in the linked sequencers. Here are some hints:\n\n\\begin{itemize}\n\n\\item {\\t recordmode} can be (and must be) set individually on each of the\nmotoquencers. If you want to record into a linked sequencer, make sure that\nyou set {\\t recordmode} there.\n\n\\item Using the same value for {\\t recordmode} for all sequencers means that\nthey always record simultanously.\n\n\\item Also {\\t keyboardcv} and {\\t keyboardgate} are settings that each\nsequencer instance has on its own. That means that you can record different\nCVs with different gates on each sequencer at the same time.\n\n\\item Using the same gate signal for the {\\t keyboardgate} of all sequencers\ncan make sense. E.g. if you want to record paraphonic chords or pitches\ntogether with modulation CVs.\n\n\\end{itemize}\n\n\\subsubsection*{Copy \\& paste}\n\nThe copy \\& paste feature allows you to copy a part of\nyour sequence from one page to another or from one preset\nto another. To do this, map the inputs {\\t copy} and\n{\\t paste} to two buttons (you don't need toggle buttons\nhere, so no {\\t button} circuit is needed).\n\nA trigger to {\\t copy} copies the current sequence into\nan internal clipboard. And {\\t paste} copies the clipboard\ninto the current sequence.\n\nUse {\\t copymode} to determine whether just the current\npage or the complete sequence shall be copied.\n\nThere are also two alternative triggers for pasting. {\\t pastefaders} just\npastes the faders of the currently selected mode. {\\t pastebuttons} is likewise\nfor the buttons. With that you can for example just copy the gate propabilites\nfrom one page to another while leaving the rest of the parameters as they are.\n\nIf you have linked sequencers, those will automatically be handled\nas well. Don't connect the {\\t copy} and {\\t paste} triggers\nthere.\n\n\n\\subsubsection*{LED colors}\n\nDepending on the {\\t buttonmode}, the LEDs below the faders have\ndifferent colors. Here is an overview over all possible colors:\n\n\\begin{tabular}{|l|l|l|} \\hline\n\\it color  & \\it meaning                   & \\t buttonmode \\\\ \\hline\nwhite  & currently played step             & always \\\\ \\hline\nblue   & enabled gate                      & \\t 0 \\\\ \\hline\ngreen  & start step                        & \\t 1 \\\\ \\hline\nred    & end step                          & \\t 1 \\\\ \\hline\ncyan   & gate on the first repetition      & \\t 2 \\\\ \\hline\npink   & gate on each repetition           & \\t 2 \\\\ \\hline\norange & hold gate over duration           & \\t 2 \\\\ \\hline\nyellow & tie the gate to the next step     & \\t 2 \\\\ \\hline\nviolet & skip                              & \\t 3 \\\\ \\hline\n\\end{tabular}\n\n\\clearpage", "inputs": [{"name": "firstfader", "type": "integer", "default": "1", "description": "First M4 fader of the sequencer (starting with 1). If you\nomit this, it starts at the first fader of your first M4.\n", "essential": 0, "ramsize": 12}, {"name": "numfaders", "type": "integer", "default": null, "description": "Number of faders to use for your sequencer. The typical\nnumbers are 4, 8, 16 and 32. 32 is the maximum (eight\nM4 units). If you omit this, all of your M4 faders\nwill be used.\n", "essential": 1, "ramsize": 12}, {"name": "numsteps", "type": "integer", "default": null, "description": "Number of steps your sequence consists of (at maximum).\nThe number of steps can be greater than the number of faders.\nIn that case use {\\t page} for paging your faders so that\nyou can edit all of the steps. Having the number of steps\nless than the faders, makes no sense -- it's just a waste\nof faders. The maximum number of steps is 32.\n\nIf you don't set this parameter, the number of steps\nwill be set to the number of faders.\n\nNote: changing this setting dynamically can provoke various\nsurprising behaviours. For example the number of pages\n(see parameter {\\t page}) might be reduced. Or the end\nmarker is forcibly moved around. If you want to change the\nlength of the sequence via CV, better use {\\t endstep}\nor {\\t autoreset}.\n\nAnother note: Setting {\\t numsteps} will {\\it not} restrict\nthe number of faders. If you set {\\t numsteps = 4} but have\neight faders available, the circuit will use all these,\neven if faders 5, 6, 7 and 8 will be useless. You need to\nset {\\t numfaders = 4} in this situation.\n", "essential": 1, "ramsize": 12}, {"name": "page", "type": "integer", "default": "0", "description": "Use this parameter, if you have less faders than steps.\nThe first page is {\\t 0}, not {\\t 1}.\nFor example if you have 4 faders but 16 steps, you can\nselect between the four ``pages'' of four faders each, by\nsettings {\\t bar} to {\\t 0}, {\\t 1}, {\\t 2} or {\\t 3}.\nThe output of a \\circuit{buttongroup} with one button\nper page is a good match for this parameter.\n", "essential": 0, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "Patch an input clock here. If you want to use ratcheting,\nthat clock needs to be stable and regular, because the sequencer\nneeds to interpolate the clock and create evenly distributed\nnew beats within two clock ticks. If you don't use ratching,\nyou can use any rhythm you like here -- may it be shuffled,\neuklidean, the output from another sequencer or whatever you\nlike. Each clock tick will advance the sequence to the next\nstep (or to the next repition of the current step).\n", "essential": 2, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the sequencer to its start step. The\nnext clock tick (or a tick that is roughly at the same time as\nthe reset) will play step 1. Note: If there is a reset {\\bf without}\na clock tick at the same time, the sequencer will go to ``step 0'',\nwhich is a special state where it waits for the clock to advance\nto the first step. Without that fancy logic, a reset plus clock\nwould skip step 1 and start with step 2.\n", "essential": 1, "ramsize": 16}, {"name": "run", "type": "gate", "default": "1", "description": "If you set this input to {\\t 0}, the sequencer will ignore all\nincoming clock ticks. It stops. The default of {\\t 1} is normal\noperation, where it runs. This input is a better way to temporarily\nstop the sequencer than to stop the clock. The reason: for computing\nthe gate length and ratchets a steady input clock is needed. If\nyou stop the clock, the next gate length and ratches right after\nthe next start will have the wrong duration since at least two\nclock ticks are neccessary for computing its speed.\n\nNote: This input is not a replacement for {\\t mute}, since a\nmuted sequencer leaves the clock running and advances steps.\nIt just mutes the gate output.\n", "essential": 0, "ramsize": 12}, {"name": "composemode", "type": "gate", "default": null, "description": "Enabling ``compose mode'' makes it easier to find the right note in\na step, when creating more complex melodies.  When {\\t composemode}\nis set to {\\t 1}, the sequencer stops clocking. Instead -- every\ntime you change the CV of a step, it immediately jumps to that step,\noutputs the changed CV and opens the gate for a short time, so you\ncan listen to the changed note.\n", "essential": 0, "ramsize": 12}, {"name": "mute", "type": "gate", "default": null, "description": "If you set this to {\\t 1}, the {\\t gate} output of the sequencer\nis muted (will always be 0). Any changes of the CV output still\nhappen.\n", "essential": 0, "ramsize": 12}, {"name": "cvbase", "type": "cv", "default": "0", "description": "Lowest CV voltage the sequencer will output.\n", "essential": 1, "ramsize": 12}, {"name": "cvrange", "type": "cv", "default": "0.2", "description": "CV range of the faders. So the resulting CV lies somewhere\nbetween {\\t cvbase} and {\\t cvbase} + {\\t cvrange}.\n", "essential": 1, "ramsize": 12}, {"name": "quantize", "type": "integer", "default": "2", "description": "Switches on quantization in two levels. At 0, the faders run\nfreely and output a continous CV.\n\nAt 1, the output is quantized to semitones, which is $\\frac{1}{12}$V\nsteps. Also the faders will get artifical notches -- one for each\nsemitone.  That is, unless your range is too large. The maximum number\nof notches with force feedback is 25, so if your range exceeds two\noctaves (0.2), the notches are turned off.\n\nAt 2, the output is quantized to the scale that {\\t root} and {\\t degree}\ndefine. Furthermore the individual scale notes can be switched on or\noff with the parameters {\\t select1}, {\\t select3}\nand so on. Note: the {\\t root} input does not select the lowest\nnote of the CV range. That is still set with {\\t cvbase}. It is\njust used for selecting the scale.\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{no quantization}\n\\jacktablerow{1}{quantize to semitones (1/12V steps)}\n\\jacktablerow{2}{quantize to the scale set by root and degree}\n\\end{tabular}\n\n\\medskip\n", "essential": 1, "ramsize": 12}, {"name": "cvnotches", "type": "integer", "default": "0", "description": "Usually the CVs of the steps are ment to be note pitches\n(when {\\t quantize} is 1 or 2), or just free CVs ({\\t quantize = 0}).\nThere is an alternative mode, however, that allows you to\nassign integer values like 0, 1, 2 and so on to each step.\n\nTo do this set {\\t cvnotches} to a value of {\\t 2} or greater. This\ndefines the number of discrete values (and hence notches) for\neach step and put CVs of the sequence into {\\it notched mode}.\n{\\t 1} makes no sense, of course, since in this ``pitch\nbend mode'' the faders would always return to the neutral position.\n\nIn notched mode the {\\t cv} output does not output a pitch but\na notch number starting from 0. {\\t cvbase}, {\\t cvrange} and\n{\\t quantize} are ignored.\n\nThe maximum number of notches is 127, but the haptic force\nfeedback of the motor faders is disabled starting at 26.\n", "essential": 0, "ramsize": 12}, {"name": "shiftsteps", "type": "integer", "default": "0", "description": "Shifts all your steps by that number to the left (negative\nnumbers shift to the right). So if {\\t shiftsteps} is 1, right\nafter a reset, the sequencer will not play step 1, but step 2.\nThe shifting wraps around at the end of your sequence, so if\nyou have 24 steps and shift is 1, the sequencer will play step 1\ninstead of step 24.\n\nNote: Other things like {\\t startstep}, {\\t endstep}, {\\t playmode},\n{\\t from} and {\\t autoreset} take place {\\bf after} shifting.\n", "essential": 0, "ramsize": 12}, {"name": "startstep", "type": "integer", "default": "1", "description": "Sets the first step to be used.  This means that after a reset or\nwhen the sequencer comes to the end of the sequence, it will begin\nat this step.\n\nThere is also a way for settings start and end with buttons\n(see below at {\\t buttonmode}). If you use the interactive\nmode, the {\\t startstep} and {\\t endstep} settings will be\noverridden. The are reactived if you {\\t clear} everything.\n\nNote: {\\t startstep} and {\\t endstep} take place after applying\n{\\t shiftsteps}.\n", "essential": 0, "ramsize": 12}, {"name": "endstep", "type": "integer", "default": null, "description": "Sets the last of the steps to be played. The default is to play\nall steps. After playing the end step, the sequencer moves on to\nthe start step at the next clock tick.\n\nIf {\\t startstep} is equal to {\\t endstep}, the sequence\njust consists of one single step.\n\nSettings {\\t startstep} larger then {\\t endstep} is allowed\nand reverses the playing order.\n", "essential": 0, "ramsize": 12}, {"name": "form", "type": "integer", "default": "0", "description": "This is an advanced feature that allows you to slice your\nsteps into two or three parts and create musical song forms\nlike AAAB or ABAC. Each of the parts A, B or C are then played\naccording to the {\\t playmode}.\n\nThe form AAAB, for example, creates a 32 step form from\njust 16 steps, by playing the first 8 steps three times and\nthen the second 8 steps once.\n\nThe following forms are available:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{A (forms are basically deactivated)}\n\\jacktablerow{1}{AAAB}\n\\jacktablerow{2}{AABB}\n\\jacktablerow{3}{ABAC}\n\\jacktablerow{4}{AAABAAAC}\n\\jacktablerow{5}{AB}\n\\jacktablerow{6}{AAB}\n\\end{tabular}\n\nNotes:\n\\begin{itemize}\n\\item The splitting of the steps into parts takes place\n{\\it after} accounting for {\\t startstep} and {\\t endstep}.\n\\item Forms with A, B and C split the pattern into\nthree parts. These parts can only be of equal size if the\nnumber of steps is dividable by 3, of course.\n\\item The pattern AB is really not the same as A, e.g when\n{\\t direction} is set {\\t 1} (reverse). In that case each of the\nparts is played backwards, but the parts themselves move\nforwards on your steps.\n\\end{itemize}\n", "essential": 0, "ramsize": 12}, {"name": "direction", "type": "gate", "default": "0", "description": "Sets the general direction in which the sequencer moves through\nthe steps. {\\t 0} means forwards and {\\t 1} means backwards.\n", "essential": 0, "ramsize": 12}, {"name": "pingpong", "type": "gate", "default": "0", "description": "If set to {\\t 1}, the sequencer will change the direction every time\nit reaches the start or end of the sequence.\n", "essential": 1, "ramsize": 12}, {"name": "pattern", "type": "integer", "default": "0", "description": "Selects one of a list of movement patterns. That way, the sequence\nsteps are not played in linear order but in a more sophisticated\nmovement.  Available pattern are:\n\n\\begin{tabular}{|l|l|l|} \\hline\n\\jacktablerowE{0}{go step by step to the sequence (normal)}{$\\rightarrow$}\n\\jacktablerowE{1}{two steps forward, one step backward}{$\\rightarrow$ $\\rightarrow$ $\\leftarrow$}\n\\jacktablerowE{2}{double step forward, one step backward}{$\\Rightarrow$ $\\leftarrow$}\n\\jacktablerowE{3}{double step forward, double step backward, single step forward}{$\\Rightarrow$ $\\Leftarrow$  $\\rightarrow$}\n\\jacktablerowE{4}{double step forward, single step forward, double step backward, single step forward}{$\\Rightarrow$ $\\rightarrow$ $\\Leftarrow$ $\\rightarrow$}\n\\jacktablerowE{5}{random single step forward or backward}{$\\leftrightarrow$}\n\\jacktablerowE{6}{go forward by a small random number of steps}{$\\rightarrow$ $\\times$ ? }\n\\jacktablerowE{7}{random jump to any allowed (other) note}{$\\Updownarrow$}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "autoreset", "type": "integer", "default": "0", "description": "If set to non-zero, automatically issues a reset (just like a\ntrigger to {\\t reset}) every N clock ticks.\n", "essential": 0, "ramsize": 12}, {"name": "metricsaver", "type": "gate", "default": "1", "description": "{\\it The Metric Saver \u2122} helps you to reliably come back\nto your original metric and time after playing around with all\nsorts of parameters that change the played number of steps in\nthe sequence.  These are: {\\t startstep}, {\\t endstep} (also when\nchanged interactively), {\\t form}, {\\t direction}, {\\t pingpong}, {\\t\npattern}, {\\t autoreset} and repeats and skips of individual steps.\nTherefore it counts the actual number of clock cycles since the\nlast external reset (or system start). And when {\\bf all} of these\nfeatures are deactivated, it snaps back the clock to the position\nit {\\it would} have been by now if you never had played around with\nall the funny stuff.\n\nThat way, during a live performance, you can safely play around\nwith all this polymetric and otherwise time disrupting stuff and\nas soon as you clean up your mess -- voila: you are back on track\nand in sync with the rest of the ``band''.\n\nThe metric saver is turned on by default. But you can disable\nit by setting the parameter to {\\t 0}.\n", "essential": 0, "ramsize": 12}, {"name": "fadermode", "type": "integer", "default": "0", "description": "Switches the current meaning of the motor faders. You probably\nwant to connect the output of a \\circuit{buttongroup} here.\nHere are the possible modes:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{pitch / CV}\n\\jacktablerow{1}{randomize CV}\n\\jacktablerow{2}{gate propability}\n\\jacktablerow{3}{repeats (up to 16)}\n\\jacktablerow{4}{gate pattern}\n\\jacktablerow{5}{ratchets (up to 8)}\n\\jacktablerow{6}{gate}\n\\jacktablerow{7}{skip}\n\\end{tabular}\n\\medskip\n", "essential": 0, "ramsize": 12}, {"name": "buttonmode", "type": "integer", "default": "0", "description": "Switches the current meaning of the touch buttons below the faders.\nYou probably want to connect the output of a \\circuit{buttongroup}\nhere. Here are the possible modes:\n\n\\begin{tabular}{|c|l|}\\hline\n\\jacktablerow{0}{gates}\n\\jacktablerow{1}{start / end}\n\\jacktablerow{2}{gate pattern}\n\\jacktablerow{3}{skip}\n\\end{tabular}\n\\medskip\n", "essential": 1, "ramsize": 12}, {"name": "holdcv", "type": "gate", "default": "1", "description": "This setting determines wether the CV output changes every\ntime the sequencer moves to the next step or just when that\nstep is active (a gate is being played). The latter is the\ndefault. But if you set this to {\\t 0}, the CV values of\nsteps without gates will also influence the output CV.\n\nNote: regardless of this setting, the CV will never change\ninbetween. Any change of the CV faders, the {\\t cvbase}\nand {\\t cvrange} and so on will only take effect when the\nnext step is played. This also ensures that repeats or ratchets\nare always in the same pitch.\n", "essential": 0, "ramsize": 12}, {"name": "defaultcv", "type": "cv", "default": "0", "description": "Set the CV the steps should be set to on a trigger to\n{\\t clear}. That value must be within the range set by {\\t cvbase}\nand {\\t cvrange}, or it will be truncated to that range.\n\nIf you have set {\\t cvnotches}, however, the value is expected\nto be an integer in the range {\\t 0} ... {\\t cvnotches} - 1.\n", "essential": 0, "ramsize": 12}, {"name": "defaultgate", "type": "gate", "default": "1", "description": "Here you set to which state (on / off) the gates should be\nset on a trigger to {\\t clear}.\n", "essential": 0, "ramsize": 12}, {"name": "clearskips", "type": "trigger", "default": null, "description": "A trigger here removes the ``skip'' setting from all steps.\n", "essential": 0, "ramsize": 16}, {"name": "clearrepeats", "type": "trigger", "default": null, "description": "A trigger here resets the number of repeats to 1 for each step.\n", "essential": 0, "ramsize": 16}, {"name": "clearstartend", "type": "trigger", "default": null, "description": "A trigger here clears the manual settings of the start and\nend step. So the sequence will be played in its full length\n(again) .\n", "essential": 0, "ramsize": 16}, {"name": "gatelength", "type": "cv", "default": "0.5", "description": "The gate length in input clock cycles. A value of {\\t 0.5}\nthus means half a clock cycle. A steady input clock is needed for\nthis to work. Please note that if the gate length is $>= 1.0$,\ntwo succeeding notes will get a steady gate, which\nessentially means legato.\n\nIf you don't use a steady clock, set this parameter to 0. This\nwill output a minimal gate length of about 10~ms (basically just\na trigger).\n", "essential": 0, "ramsize": 12}, {"name": "keyboardmode", "type": "integer", "default": "1", "description": "This input sets how a keyboard, that is hooked to {\\t keyboardcv},\nand {\\t keyboardgate} should be used for directly playing notes.\nYou can set it to {\\t 0}, {\\t 1} or {\\t 2}.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{ignore the keyboard inputs}\n\\jacktablerow{1}{keyboard and sequencer play together, keyboard has precedence}\n\\jacktablerow{2}{mute sequencer, just play keyboard}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 12}, {"name": "keyboardcv", "type": "voltperoctave", "default": null, "description": "\nThe pitch input of a keyboard. This is used for playing\nalong with the {\\t keyboardmode} or recording with {\\t recordmode}.\n", "essential": 0, "ramsize": 12}, {"name": "keyboardgate", "type": "gate", "default": null, "description": "\nThe gate input of a keyboard. A positive gate enabled play\nalong (see {\\t keyboardmode}) and also recording, if {\\t\nrecordmode} is set accordingly.\n", "essential": 0, "ramsize": 12}, {"name": "recordmode", "type": "integer", "default": "0", "description": "\nUse this input to record melodies played with a keyboard\n(namely {\\t keyboardcv} and {\\t keyboardgate}) into the\nsequencer. There are three possible settings:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{don't record}\n\\jacktablerow{1}{record, notes longer than one step will automatically tie steps via the gate pattern}\n\\jacktablerow{2}{record, don't tie notes. Ignore the length of the input note}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 12}, {"name": "recordsilence", "type": "gate", "default": "0", "description": "When this input is set to {\\t 1} while recording, silence will\nbe recorded while {\\t keyboardgate} is off. Otherwise you can\njust add notes to the sequence.\n", "essential": 0, "ramsize": 12}, {"name": "copy", "type": "trigger", "default": null, "description": "A trigger here copies the complete sequence (if {\\t copymode = 0})\nor just the current page of the sequence (if {\\t copymode = 1}) to\nan internal clipboard. The clipboard is not part of any preset and\nis also not saved to the SD card. It can be used later for pasting\nit's data to another preset or another page of a sequence.\n", "essential": 0, "ramsize": 16}, {"name": "copymode", "type": "integer", "default": "1", "description": "Determines wether copy and paste works with the complete sequence\nor just with the current page (that part of the sequence that is\ncurrently shown on the faders.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{copy and paste works on the sequence as a whole}\n\\jacktablerow{1}{copy and paste just works on the current page}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 12}, {"name": "paste", "type": "trigger", "default": null, "description": "A trigger here copies the steps from the clipboard either\nto the complete sequence ({\\t copymode = 0}) or just to the\ncurrent page ({\\t copymode = 1}).\n", "essential": 0, "ramsize": 16}, {"name": "pastefaders", "type": "trigger", "default": null, "description": "This is like {\\t paste}, but just the values of the faders\nof the current {\\t fadermode} are copied.\n", "essential": 0, "ramsize": 16}, {"name": "pastebuttons", "type": "trigger", "default": null, "description": "This is like {\\t paste}, but just the values of the faders\nof the current {\\t buttonmode} are copied. Note: the button\nmode ``start / end'' is not supported by copy and paste.\n", "essential": 0, "ramsize": 16}, {"name": "linktonext", "type": "gate", "default": "0", "description": "This settings allows you to create motoquencer tracks that\nhave more than one CV or gate output for each step. If you\nset this to {\\t 1}, the next {\\t motoquencer} circuit\nin your patch will by synchronized to this one. This means\nthat it always plays the same step number -- including all\nfancy operating like {\\t shiftsteps}, {\\t startstep},\n{\\t endstep}, {\\t form}, {\\t pattern} and {\\t autoreset}.\nAll those inputs and also {\\t clock} and {\\t reset}\nare {\\bf ignored} by the next {\\t motoquencer}.\n\nThe same holds for the ``repeats'' and ``skip'' setting of the steps.\n\n{\\t fadermode} and {\\t buttonmode} are extended to\nthe next motoquencers by adding 10 for each motoquencer to\nfollow. So {\\t fadermode = 10} will show the CV of next motoquencer\nin the faders. {\\t fadermode = 11} the CV randomization of the\nnext motoquencer. {\\t fadermode = 20} show the CV of the\nthird linked motoquencer and so on.\n\nDon't set {\\t fadermode} or {\\t buttonmode} on the linked\nmotoquencers. They will be ignored there.\n\n{\\bf Note:} The {\\t linktonext} setting cannot by dynamically\nchanged. It needs to be fixed {\\t 0} or {\\t 1}. You cannot\nuse any button or internal cable or other methods to change\nit while the patch is running.\n", "essential": 0, "ramsize": 12}, {"name": "luckychance", "type": "fraction", "default": "1", "description": "Sets tha chance for a step to be affected by the next\n``lucky'' operation (see triggers below).\n", "essential": 0, "ramsize": 12}, {"name": "luckyscope", "type": "integer", "default": "0", "description": "Determines which part of the sequence is affected by\nthe ``lucky'' operations. Depending on this setting the\nfollowing steps are affected:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{All steps between the current start and end step}\n\\jacktablerow{1}{All steps}\n\\jacktablerow{2}{All steps between start and end on the current page}\n\\jacktablerow{3}{All steps on the current page}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 0, "ramsize": 12}, {"name": "luckyamount", "type": "fraction", "default": "1", "description": "Sets the amount of change that a ``lucky'' operation does to\na step. The meaning depends on the operation. See the parameters\nbelow.\n", "essential": 0, "ramsize": 12}, {"name": "luckyfaders", "type": "trigger", "default": null, "description": "Moves the currently selected faders (according to\n{\\t fadermode}) to new random positions. {\\t luckyamount}\nsets the maximum value of the fader, where {\\t 1} allows the\nmaximum.\n", "essential": 0, "ramsize": 16}, {"name": "luckybuttons", "type": "trigger", "default": null, "description": "Randomly toggles the currently selected buttons (according\nto {\\t buttonmode}). {\\t luckyamount}\nonly has an effect when the gate patterns are selected, since\nhere, four different values are possible. {\\t luckamount}\nrestricts them if it is lower than {\\t 1}.\n", "essential": 0, "ramsize": 16}, {"name": "luckycvs", "type": "trigger", "default": null, "description": "Replaces the affected steps' CVs with a new random CVs. The\nlowest possible CV is {\\t cvbase}. If {\\t luckyamount} is {\\t 1},\nthe highest possible CV is {\\t cvbase} + {\\t cvrange}, otherwise\nit is {\\t cvbase} + {\\t luckyamount} $\\times$ {\\t cvrange}.\n", "essential": 0, "ramsize": 16}, {"name": "luckycvdrift", "type": "trigger", "default": null, "description": "Modifies the affected steps' CV randomly up or down. They will stay\nin the CV range set by {\\t cvbase} and {\\t cvrange}. {\\t luckyamount}\ncontrols the amount of change.\n", "essential": 0, "ramsize": 16}, {"name": "luckyspread", "type": "trigger", "default": null, "description": "First computes the average CV of all steps. Then changes\nthe CV values of the affected steps such that their distance to\nthe average increases or decreases.  If {\\t luckyamount}\nis greater than {\\t 0.5}, the distance is increased. Otherwise it\nis decreased.\n", "essential": 0, "ramsize": 16}, {"name": "luckyinvert", "type": "trigger", "default": null, "description": "Inverts the CVs of the affected steps within the allowed CV\nrange. {\\t luckyamount} has no influence.\n", "essential": 0, "ramsize": 16}, {"name": "luckyrandomizecv", "type": "trigger", "default": null, "description": "Sets the ``randomize CV'' values of the affected steps to\nrandom values (yes, this is double randomization). The {\\t luckyamount}\nsets the maximum randomization value that will be set.\n", "essential": 0, "ramsize": 16}, {"name": "luckygates", "type": "trigger", "default": null, "description": "Sets the gates of the affected steps randomly to on or off. The\nchance for on is determined by {\\t luckyamount}. So with\n{\\t luckyamount = 0} you clear all gates and with {\\t luckyamount = 1}\nyou set all gates.\n", "essential": 0, "ramsize": 16}, {"name": "luckyskips", "type": "trigger", "default": null, "description": "Sets the ``skip this step'' setting of the affected steps\nrandomly to skip or normal. The chance for skip is determined by {\\t\nluckyamount}.\n", "essential": 0, "ramsize": 16}, {"name": "luckyties", "type": "trigger", "default": null, "description": "Sets the ``tie this step to the next'' setting of the affected steps\nrandomly to tie or normal. This is the same as setting the gate pattern\nto the upper most position. The chance for tie is determined by {\\t\nluckyamount}.\n", "essential": 0, "ramsize": 16}, {"name": "luckygatepattern", "type": "trigger", "default": null, "description": "Randomizes the gate pattern of the selected steps (there are four\ndifferent values: once, all, hold and tie). Use {\\t luckyamount}\nto reduce that set.\n", "essential": 0, "ramsize": 16}, {"name": "luckygateprob", "type": "trigger", "default": null, "description": "Sets the ``randomize gate'' values of the affected steps to\nrandom values (yes, this is double randomization). The {\\t luckyamount}\nsets the minimum randomization value that will be set (yes, this\nis inverted). So with {\\t luckyamount = 1} you disable randomization\nand make the gates play always. With {\\t luckymount = 0} you set\nthe gate propability to the lowest possible value (still not 0).\n", "essential": 0, "ramsize": 16}, {"name": "luckyrepeats", "type": "trigger", "default": null, "description": "Randomly sets the number of repeats of the affected steps to\nsomething between 1 and 16 (the maximum). The {\\t luckyamount} determines\nthe maximum repetition number, where 1 stands for a maximum of 16\nrepetitions.\n", "essential": 0, "ramsize": 16}, {"name": "luckyratchets", "type": "trigger", "default": null, "description": "Randomly sets the number of ratches of the affected steps to\nsomething between 1 and 8 (the maximum). The {\\t luckyamount} determines\nthe maximum ratchet number, where 1 stands for a maximum of 8\nratchets.\n", "essential": 0, "ramsize": 16}, {"name": "luckyshuffle", "type": "trigger", "default": null, "description": "Randomly swaps all affected affected steps (their playing\norder) together will all their attributes. {\\t luckyamount} has no\ninfluence.\n", "essential": 0, "ramsize": 16}, {"name": "luckyreverse", "type": "trigger", "default": null, "description": "Reverses the playin gorder of the affected steps. {\\t luckyamount}\nhas not influence.\n", "essential": 0, "ramsize": 16}, {"name": "root", "type": "integer", "default": "0", "description": "Set the root note here. {\\t 0} means {\\it C}, {\\t 1} means\n{\\it $C\\sharp$}, {\\t 2} means {\\it D} and so on. If you multiply\nthe value of an input like {\\t I1} with 120, then you can use a 1V/Oct\ninput for selecting the root note via a sequencer, MIDI keyboard\nor the like.\nAlso then you are compatible with the ROOT CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{C}\n\\jacktablerow{1}{C\\sharp}\n\\jacktablerow{2}{D}\n\\jacktablerow{3}{D\\sharp}\n\\jacktablerow{4}{E}\n\\jacktablerow{5}{F}\n\\jacktablerow{6}{F\\sharp}\n\\jacktablerow{7}{G}\n\\jacktablerow{8}{G\\sharp}\n\\jacktablerow{9}{A}\n\\jacktablerow{10}{A\\sharp}\n\\jacktablerow{11}{B}\n\\jacktablerow{12}{C}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "degree", "type": "integer", "default": "0", "description": "Set the musical scale. This is a number from {\\t 0} to {\\t 11}.\nAt {\\t 12} this repeats over again. Please refer to the introduction\nfor the list of scales. If you multiply an input like {\\t I1} with\n{\\t 120}, this will internally scale to one scale per semitone\nand you are compatible with the DEGREE CV input of the Sinfonion.\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{lyd -- Lydian major scale (it has a $\\sharp 4$)}\n\\jacktablerow{1}{maj -- Normal major scale (ionian)}\n\\jacktablerow{2}{X$^7$ -- Mixolydian (dominant seven chords)}\n\\jacktablerow{3}{sus -- mixolydian with \\nth3/\\nth4 swapped}\n\\jacktablerow{4}{alt -- Altered scale}\n\\jacktablerow{5}{hm$^5$ -- Harmonic minor scale from the \\nth5}\n\\jacktablerow{6}{dor -- Dorian minor (minor with $\\sharp 13$)}\n\\jacktablerow{7}{min -- Natural minor (aeolian)}\n\\jacktablerow{8}{hm -- Harmonic minor ($\\flat 6$ but $\\sharp 7$)}\n\\jacktablerow{9}{phr -- Phrygian minor scale (with $\\flat 9$)}\n\\jacktablerow{10}{dim -- Diminished scale (whole/half tone)}\n\\jacktablerow{11}{aug -- Augmented scale (just whole tones)}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}, {"name": "select1", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the {\\it root} note as being an\nallowed interval. When you want to create a playing interface\nfor live operation you can patch the output of a toggle button\n(made with the circuit {\\t [button]}) here.\n\nNote: When all {\\t select} and {\\t selectfill} inputs are 0,\nautomatically all seven scale notes are selected, i.e.\n{\\t select1} ... {\\t select13} will be set to one.\n", "essential": 1, "ramsize": 12}, {"name": "select3", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{3}.\n", "essential": 1, "ramsize": 12}, {"name": "select5", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{5}.\n", "essential": 1, "ramsize": 12}, {"name": "select7", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{7}.\n", "essential": 1, "ramsize": 12}, {"name": "select9", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{9} (which is the same\nas the \\nth2).\n", "essential": 1, "ramsize": 12}, {"name": "select11", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{11} (which is the same\nas the \\nth4).\n", "essential": 1, "ramsize": 12}, {"name": "select13", "type": "gate", "default": "unpatched", "description": "Gate input for selecting the \\nth{13} (which is the same\nas the \\nth6).\n", "essential": 1, "ramsize": 12}, {"name": "selectfill1", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{9} (i.e.\nthe \\nth9 that is {\\it not} in the scale.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill2", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{3} (i.e.\nthe \\nth3 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill3", "type": "gate", "default": "off", "description": "Selects the alternative \\nth4 or \\nth{5}. In\nmost cases this is the diminished \\nth5.\n", "essential": 0, "ramsize": 12}, {"name": "selectfill4", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{13} (i.e.\nthe \\nth13 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "selectfill5", "type": "gate", "default": "off", "description": "Selects the alternative \\nth{7} (i.e.\nthe \\nth7 that is {\\it not} in the scale).\n", "essential": 0, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "off", "description": "While this is {\\t 1}, the circuit will output the value set\nby {\\t tuningpitch} instead of the actual pitch. This is ment\nto be a help for tuning your VCOs.\n", "essential": 0, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 0, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "This value is being added to the output pitch when not\nin tuning mode. It can be used for musical transposition\nor adding a vibrato.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "cv", "type": "cv", "default": null, "description": "The CV output (or pitch output, if you use {\\t quantize}).\n", "essential": 2, "ramsize": 4}, {"name": "gate", "type": "gate", "default": null, "description": "The gate output.\n", "essential": 2, "ramsize": 4}, {"name": "startofsequence", "type": "trigger", "default": null, "description": "Outputs a trigger whenever the sequencer starts playing\nfrom the beginning. This can be used for synchronizing with other sequencers.\nAn external {\\t reset} will also cause this output to trigger.\n", "essential": 0, "ramsize": 8}, {"name": "startofpart", "type": "trigger", "default": null, "description": "Outputs a trigger whenever a form part starts again.\nThis is only interesting when you use {\\t form}.\n", "essential": 0, "ramsize": 8}, {"name": "startstepout", "type": "integer", "default": null, "description": "Outputs the current start step. This is useful in case it has\nbeen interactively set with the buttons and you need that information\nfor another circuit.\n", "essential": 0, "ramsize": 4}, {"name": "endstepout", "type": "integer", "default": null, "description": "Outputs the current end step. This is useful in case it has\nbeen interactively set with the buttons and you need that information\nfor another circuit.\n", "essential": 0, "ramsize": 4}, {"name": "currentstep", "type": "integer", "default": null, "description": "Outputs the number of the step that is currently being played\n(starting from 0).\n", "essential": 0, "ramsize": 4}, {"name": "currentpage", "type": "integer", "default": null, "description": "Outputs the number of the fader page that is currently played,\ni.e. the value you would have to feed into {\\t page} in order to\nsee the currently being played step.\n", "essential": 0, "ramsize": 4}], "presets": 4, "manual": 205, "ramsize": 1112}, "motorfader": {"category": "ui", "title": " Create virtual fader in M4 controller", "description": "The circuit provides the most basic access to motor faders and supports switching\nbetween presets, overlayed functions and force feedback.\n\nFor the basics about these ideas and the M4 in general, please read the introduction\nto the M4 on page \\pageref{m4}.\n\n\\subsubsection*{Presets}\n\nLet's start with presets and make a simple example with one P2B8 and one\nM4 controller. First we need to declare both in our patch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[m4]}[m4]\n\\end{droidini}\n\nLet's use the first fader as a simple CV source to be output on {\\t O1}. And\nfour buttons should select four different presets of that fader. Those are\ngrouped into a button with the circuit \\circuit{buttongroup}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{    output = _PRESET}    output = _PRESET\n\\end{droidini}\n\nThis circuit will switch between the values {\\t 0}, {\\t 1}, {\\t 2} and {\\t 3}\nand output that number to the intercal cable {\\t\\_PRESET}.  Now let's add\nthe fader definition:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    preset = _PRESET}    preset = _PRESET\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nThat's really all. {\\t fader = 1} selects the first motor fader\nin your setup. All faders are simply enumerated, so {\\t fader = 7}\nwould select the third fader on the second M4.\n\nThe output {\\t O1} now always outputs the current setting of the\nfader. The range is 0~V ... 10~V -- just like with pots\nof the controllers.\n\nHitting the buttons will switch to one of the four presets and move\nthe fader to the position corresponding to current value of that preset.\n\n\\subsubsection*{Faders with multiple functions}\n\nThe second way to use the motor faders is to assign multiple\nfunctions to one fader and then switch between those functions.\nThe crucial difference to the presets is, that for every function\nthere is a {\\it dedicated output}.\n\nLet's now change our example so that we use one fader controlling\n{\\it four} CV sources, but without any presets for the while.\nThe start is the same (just we renamed the internal cable\nto {\\t\\_FUNCTION}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{    output = _FUNCTION}    output = _FUNCTION\n\\end{droidini}\n\nNo we need a separate {\\t motorfader} circuit for each function.\nAnd instead of choosing a preset, we need to {\\bf select} each\ncircuit when the active button selects its function:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = _FUNCTION}    select = _FUNCTION\n\\immediate\\write\\patchexamples{    selectat = 0}    selectat = 0\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = _FUNCTION}    select = _FUNCTION\n\\immediate\\write\\patchexamples{    selectat = 1}    selectat = 1\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = _FUNCTION}    select = _FUNCTION\n\\immediate\\write\\patchexamples{    selectat = 2}    selectat = 2\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = _FUNCTION}    select = _FUNCTION\n\\immediate\\write\\patchexamples{    selectat = 3}    selectat = 3\n\\immediate\\write\\patchexamples{    output = O4}    output = O4\n\\end{droidini}\n\nAs you can see: each fader has a {\\t selectat} input matching one of\nthe buttons of the buttongroup. And each fader also sends its output\nto one of the main outputs of the master.\n\nThere is one possible simplification: Instead of using {\\t\\_FUNCTION}\nand {\\t selectat}, we also could use the LED outputs of the button group\ndirectly:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = L1.1}    select = L1.1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = L1.2}    select = L1.2\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = L1.3}    select = L1.3\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = L1.4}    select = L1.4\n\\immediate\\write\\patchexamples{    output = O4}    output = O4\n\\end{droidini}\n\n\\subsubsection*{Notches}\n\nMaybe the coolest feature of the M4 is the haptic feedback. The M4\nuses its motors in order to give you force feedback. This is done\nin various forms.\n\nThe most useful form is to use artifical ``notches'' or ``dents''.\nTry that out be setting {\\t notches} to a number, e.g. 8:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{    notches = 8}    notches = 8\n\\end{droidini}\n\nThis changes the behaviour of the fader in two ways:\n\n\\begin{enumerate}\n\\item The output value is now a discrete whole number from {\\t 0} up to {\\t 7}.\n\\item When you move the fader you feel eight artificial dents. That's really\nhard to explain. Try it out!\n\\end{enumerate}\n\nThese notches are super helpful especially in live performances. You instantly\n{\\it feel} where your are. You don't need any visual feedback. You can very\nreliably set a value without looking.\n\nThe maximum number of notches is {\\t 201}. But if you select more than 25\nnotches, the force feedback is turned off as the notches would get too small\nto work.\n\nThere are also two other variants of force feed back:\n\n\\subsubsection*{Binary switch}\n\nIf you set {\\t notches = 2}, you turn the fader into a binary switch. The\noutput will be {\\t 0} if the fader is in the bottom position and {\\t 1} on\nthe top. Just move the fader away from its position and it will immediately\nsnap to the other side.\n\n\\subsubsection*{Pitch bend wheel}\n\nSetting {\\t notches = 1} will convert the fader into a kind\nof pitch bend wheel. It always wants to stay in the middle,\nwhere it outputs a value of {\\t 0.5}. If you move it\naway from the center position, it creates a force back to\nthe center that is the greater the nearer you are to the\ntop or bottom. As soon as you release it, it snaps back\nto the middle.\n\n\\subsubsection*{Modifying one value with two virtual faders}\n\nThe sharing of virtual faders is a bit more tricky to explain and you\nprobably won't need it. It means that you use two {\\t motorfader} circuits\nfor controlling the same output value. Why would you do this?\n\nI have added that feature when building a motor fader based\nMIDI control for my audio interface. I have one mode where\nevery of eight faders controls the main volume of one\nof eight voices.\n\nAnd then I have a ``drill down'' for each voice, where the first fader is\nthe main volume, the second fader the head phone, the third the volume of\nan aux channel and so on.\n\nSo now I can control the volume of voice 3 either with the third fader in\nthe ``global'' volume control or with the first fader the drill down of\nvoice 3. This leads to an output collision since two circuits would try\nto modify the same output, even if always just one of the two motor fader\ncircuits is selected.\n\nThe solution to this problem is the {\\t sharewithnext} input.\nPut the two {\\t motorfader} circuits next to each other into\nyour patch. Put a {\\t sharewithnext = 1} into the first one.\nDon't use the {\\t output} there. Now both virtual faders will\ncontrol the output that is defined in the second {\\t motorfader}\ncircuit:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 1}    fader = 1\n\\immediate\\write\\patchexamples{    select = _GLOBAL}    select = _GLOBAL\n\\immediate\\write\\patchexamples{    sharewithnext = 1}    sharewithnext = 1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[motorfader]}[motorfader]\n\\immediate\\write\\patchexamples{    fader = 3}    fader = 3\n\\immediate\\write\\patchexamples{    select = _DRILLDOWN_3}    select = _DRILLDOWN_3\n\\immediate\\write\\patchexamples{    output = _VOLUME_3}    output = _VOLUME_3\n\\end{droidini}\n\nNote: if you are using {\\t notches}, make sure that both\n{\\t motorfader} circuits have the same number of notches!", "inputs": [{"name": "fader", "type": "integer", "default": "1", "description": "The number of the motor fader to use, starting with {\\t 1}\nfor the first fader in the first M4. {\\t 5} selects the first\nfader in the second M4 and so on.\n", "essential": 1, "ramsize": 12}, {"name": "startvalue", "type": "cv", "default": "0", "description": "This sets the value the fader gets when you start this circuit\nthis first time or when a trigger to {\\t clear} happens.\n", "essential": 0, "ramsize": 12}, {"name": "notches", "type": "integer", "default": "0", "description": "Number of artifical notches. {\\t 0} disables the notches.\n{\\t 1} creates a pitch bend wheel. {\\t 2} creates a binary\nswitch with the output values {\\t 0} and {\\t 1}. Higher\nnumber create that number of notches. E.g. {\\t 8} creates\neight notches and {\\t output} will output one of the\nvalue {\\t 0}, {\\t 1}, ... {\\t 8}. The maximum allowed number\nis {\\t 25}.\n", "essential": 1, "ramsize": 12}, {"name": "ledvalue", "type": "cv", "default": null, "description": "When you use this input, it will override the brightness\nof the LED below the fader, but just when this circuit\nis selected.\n", "essential": 0, "ramsize": 12}, {"name": "ledcolor", "type": "cv", "default": null, "description": "When you use this input, it will set the color of the\nLED below the fader, when the circuit is selected. If the\nLED is off, this setting has now impact.\n", "essential": 0, "ramsize": 12}, {"name": "sharewithnext", "type": "gate", "default": "0", "description": "If set to {\\t 1}, the output {\\t output} will not be\nused but the circuit shares it's output with the next\n{\\t motorfader} circuit.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Output the current value if the virtual motor fader\n(don't use this if you are using {\\t sharewithnext}).\n", "essential": 2, "ramsize": 4}], "presets": 8, "manual": 226, "ramsize": 104}, "notchedpot": {"category": "deprecated", "title": " Helper circuit for pots (OBSOLETE)", "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit\n\\circuit{pot}.  It will be removed in the next firmware version. If you use\nit in your patch, better replace it.}\n\n{\\t pot} can do all {\\t notchedpot} can do and much\nmore. So {\\t notchedpot} will be removed soon.\n\n\\medskip\n\\hrule\n\nThis little circuit simulates a potentiometer with a notch at the center.\nIt helps you exactly selecting the center position by defining a range\nthat is considered to be the center. This range is called ``notch'' and\ndefaults to 10\\% of the available range. You can set the size of the notch\nvia the {\\t notch} input. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notchedpot]}[notchedpot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 15%}    notch    = 15%\n\\immediate\\write\\patchexamples{    output   = _ACTIVITY}    output   = _ACTIVITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    activity = _ACTIVITY}    activity = _ACTIVITY\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nFor a second use case there is the output {\\t bipolar}. That converts\na normal pot into one with range from -1.0 to 1.0. This example also\nshows how to disable the notch, if you do not need it here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notchedpot]}[notchedpot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 0}    notch    = 0\n\\immediate\\write\\patchexamples{    bipolar  = O1 # Send @10V ... +10V to O1}    bipolar  = O1 # Send -10V ... +10V to O1\n\\end{droidini}", "inputs": [{"name": "pot", "type": "fraction", "default": null, "description": "Wire your pot here, e.g. {\\t P1.1}\n", "essential": 0, "ramsize": 12}, {"name": "notch", "type": "cv", "default": "0.1", "description": "Optionally set the notch size, if you do not like the default of {\\t 0.1}.\nThe maximum allowed value is {\\t 0.5}. Greater values will be reduced to that.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "fraction", "default": null, "description": "Your pot output comes here. It still goes from {\\t 0.0} to {\\t 1.0}.\n", "essential": 0, "ramsize": 4}, {"name": "bipolar", "type": "cv", "default": null, "description": "Optional output with a range from -1.0 to 1.0, where the center notch\nis at 0.0.\n", "essential": 0, "ramsize": 4}, {"name": "absbipolar", "type": "cv", "default": null, "description": "A variation of {\\t bipolar} that always outputs a positive value,\ni.e. the pot will go 1 ... 0.5 ... 0 ... 0.5 ... 1\n", "essential": 0, "ramsize": 4}, {"name": "lefthalf", "type": "cv", "default": null, "description": "This output allows you to split the pot into two hemispheres. Here\nyou get 1.0 ... 0.0 while the pot is in the left half. In the middle\nand right of it you always get 0.\n", "essential": 0, "ramsize": 4}, {"name": "righthalf", "type": "cv", "default": null, "description": "This is the same but for the right half. It outputs 0 while\nthe pot is in the left half and 0.0 ... 1.0 from the middle to the\nfully right position.\n", "essential": 0, "ramsize": 4}, {"name": "lefthalfinv", "type": "cv", "default": null, "description": "This outputs 1.0 - {\\t lefthalf}, i.e. the value range\n0.0 ... 1.0 ... 1.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right.\n", "essential": 0, "ramsize": 4}, {"name": "righthalfinv", "type": "cv", "default": null, "description": "This outputs 1.0 - {\\t righthalf}, i.e. the value range\n1.0 ... 1.0 ... 0.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 230, "ramsize": 40}, "notebuttons": {"category": "ui", "title": " Note Selection Buttons", "description": "This simple utility combines 12 buttons, just like radio buttons, into\na selector for a note such as C, $C\\sharp$, D, D$\\sharp$ and so on. It is\nsimilar to {\\t buttongroup}, but much simpler. And it allows 12 buttons. The\noutput is either a number from {\\t 0} to {\\t 11} -- or alternatively on a\n$\\frac{1}{12}$~V per semitone base. The latter one is ideal for sending it\nto external sequencers or quantizers as they often adopt that scheme.\n\nThe following example uses all eight buttons of the\nfirst controller plus the first column of the second\ncontroller for selecting the twelve notes. It sends the\ncurrently selected note to {\\t O7} in a 1~V per octave scheme:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[notebuttons]}[notebuttons]\n\\immediate\\write\\patchexamples{    button1  = B1.1}    button1  = B1.1\n\\immediate\\write\\patchexamples{    button2  = B1.2}    button2  = B1.2\n\\immediate\\write\\patchexamples{    button3  = B2.1}    button3  = B2.1\n\\immediate\\write\\patchexamples{    button4  = B1.3}    button4  = B1.3\n\\immediate\\write\\patchexamples{    button5  = B1.4}    button5  = B1.4\n\\immediate\\write\\patchexamples{    button6  = B2.3}    button6  = B2.3\n\\immediate\\write\\patchexamples{    button7  = B1.5}    button7  = B1.5\n\\immediate\\write\\patchexamples{    button8  = B1.6}    button8  = B1.6\n\\immediate\\write\\patchexamples{    button9  = B2.5}    button9  = B2.5\n\\immediate\\write\\patchexamples{    button10 = B1.7}    button10 = B1.7\n\\immediate\\write\\patchexamples{    button11 = B1.8}    button11 = B1.8\n\\immediate\\write\\patchexamples{    button12 = B2.7}    button12 = B2.7\n\\immediate\\write\\patchexamples{    led1     = L1.1}    led1     = L1.1\n\\immediate\\write\\patchexamples{    led2     = L1.2}    led2     = L1.2\n\\immediate\\write\\patchexamples{    led3     = L2.1}    led3     = L2.1\n\\immediate\\write\\patchexamples{    led4     = L1.3}    led4     = L1.3\n\\immediate\\write\\patchexamples{    led5     = L1.4}    led5     = L1.4\n\\immediate\\write\\patchexamples{    led6     = L2.3}    led6     = L2.3\n\\immediate\\write\\patchexamples{    led7     = L1.5}    led7     = L1.5\n\\immediate\\write\\patchexamples{    led8     = L1.6}    led8     = L1.6\n\\immediate\\write\\patchexamples{    led9     = L2.5}    led9     = L2.5\n\\immediate\\write\\patchexamples{    led10    = L1.7}    led10    = L1.7\n\\immediate\\write\\patchexamples{    led11    = L1.8}    led11    = L1.8\n\\immediate\\write\\patchexamples{    led12    = L2.7}    led12    = L2.7\n\\immediate\\write\\patchexamples{    semitone = O7}    semitone = O7\n\\end{droidini}\n\n\\clearpage", "inputs": [{"prefix": "button", "name": "button1 ... button12", "count": 12, "start_at": 1, "type": "trigger", "default": null, "description": "Wire 12 buttons to these 12 inputs.\n", "essential": 2, "essential_count": 12, "ramsize": 16}, {"name": "clock", "type": "trigger", "default": null, "description": "When you use this jack, all button presses are quantized in\ntime to the next clock pulse arriving here. That makes it easier\nto switch the note exactly in time.\n", "essential": 1, "ramsize": 16}, {"name": "startnote", "type": "integer", "default": null, "description": "Specify the note that should be selected when the Droid\nstarts and no state is loaded, or when a trigger to {\\t clear}\nor {\\t clearall} happened.\nThis is an integer number from {\\t 0} to {\\t 11}.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "led", "name": "led1 ... led12", "count": 12, "start_at": 1, "type": "gate", "default": null, "description": "Wire the LEDs in the buttons to these 12 outputs.\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "output", "type": "integer", "default": null, "description": "Here you get a number from {\\t 0} to {\\t 11}, according to the currently\nselected button.\n", "essential": 2, "ramsize": 4}, {"name": "semitone", "type": "voltperoctave", "default": null, "description": "Here you get the same as {\\t output}, but divided by 120. When\nyou patch this output to a CV output of the \\droid, like {\\t O1},\nit will output the note as a semitone on a 1~V per octave scheme.\n", "essential": 0, "ramsize": 4}, {"name": "gate", "type": "gate", "default": null, "description": "This output is {\\t 1} as long as one of the buttons is held.\nYou can use that together with the {\\t semitone} output to use\nthe {\\t notebuttons} as a CV/gate keyboard with 12 keys.\n", "essential": 0, "ramsize": 4}], "presets": 16, "manual": 231, "ramsize": 128}, "nudge": {"category": "ui", "title": " Modify a value in steps using two buttons", "description": "This small utility allows you to modify a value up and down\nin fixed steps using two buttons. This value can be persistent\nso it survives a power cycle.\n\nHere is an example for a simple CV source that outputs\na value between -2~V and 2~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    minimum    = @2V}    minimum    = -2V\n\\immediate\\write\\patchexamples{    maximum    = 2V}    maximum    = 2V\n\\immediate\\write\\patchexamples{    amount     = 1V}    amount     = 1V\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\end{droidini}\n\n{\\bf Note}: If you press both buttons at the same time, the value will be reset to\nits start value.\n\nYou can extend this into an octave switch by using the input\n{\\t offset}, which will be added to the output:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    minimum    = @2V}    minimum    = -2V\n\\immediate\\write\\patchexamples{    maximum    = 2V}    maximum    = 2V\n\\immediate\\write\\patchexamples{    amount     = 1V}    amount     = 1V\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\immediate\\write\\patchexamples{    offset     = I1}    offset     = I1\n\\end{droidini}\n\nIf you now feed some V/Oct source, such as the pitch output of a\nsequencer, to {\\t I1}, it will be shifted up and down for up to two octaves.\n\nAnother application might be to fine tune an oscillator. Here you\nset the nudge steps (set by {\\t amount}) a lot smaller. Also it is\nallowed to leave out {\\t minimum} and {\\t maximum} and thus make the possible\nrange unrestricted. Note: {\\t 1V / 1200} means essentially a step size of\n$\\frac{1}{1200}$ of an octave, which is $\\frac{1}{100}$ of a semitone, which is\nalso known as {\\it one cent}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    amount     = 1V / 1200}    amount     = 1V / 1200\n\\immediate\\write\\patchexamples{    buttonup   = B1.1}    buttonup   = B1.1\n\\immediate\\write\\patchexamples{    buttondown = B1.3}    buttondown = B1.3\n\\immediate\\write\\patchexamples{    ledup      = L1.1}    ledup      = L1.1\n\\immediate\\write\\patchexamples{    leddown    = L1.3}    leddown    = L1.3\n\\immediate\\write\\patchexamples{    output     = O1}    output     = O1\n\\immediate\\write\\patchexamples{    offset     = I1}    offset     = I1\n\\end{droidini}\n\n\nA third application could be a button for selecting a certain input\nnumber for -- let's say -- an euclidean rhythm pattern:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[nudge]}[nudge]\n\\immediate\\write\\patchexamples{    amount = 1}    amount = 1\n\\immediate\\write\\patchexamples{    buttonup = B1.1}    buttonup = B1.1\n\\immediate\\write\\patchexamples{    ledup = L1.1}    ledup = L1.1\n\\immediate\\write\\patchexamples{    minimum = 3}    minimum = 3\n\\immediate\\write\\patchexamples{    maximum = 7}    maximum = 7\n\\immediate\\write\\patchexamples{    wrap = 1}    wrap = 1\n\\immediate\\write\\patchexamples{    output = _BEATS}    output = _BEATS\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[euklid]}[euklid]\n\\immediate\\write\\patchexamples{    clock   = G1}    clock   = G1\n\\immediate\\write\\patchexamples{    length  = 16}    length  = 16\n\\immediate\\write\\patchexamples{    beats   = _BEATS}    beats   = _BEATS\n\\immediate\\write\\patchexamples{    output  = G3}    output  = G3\n\\end{droidini}\n\nNote: Here only one button is wired. In addition {\\t wrap} is set to {\\t\n1}, which means that after reaching the maximum value, the next value will\nbe the minimum value.  Here each press of the button {\\t B1.1} forwards the\nnumber of beats in the matter 3 $\\rightarrow$ 4 $\\rightarrow$ 5 $\\rightarrow$\n6 $\\rightarrow$ 7 $\\rightarrow$ 3 and so on...\n\n\\subsubsection*{Understanding the LEDs}\n\nBy nudging the value below the center value the buttonup LED will be off and\nthe brightness of the buttondown LED will gradually increase indicating how\nmuch the value is set below this center value. It remains maximally bright\nat the minimum.\n\nVice versa by nudging the value above the center value the buttondown LED\nwill be off and the brightness of the buttonup LED will gradually increase\nindicating how much the value is set above this center value. It remains\nmaximally bright at the maximum.\n\nAnd if the value is exactly in the middle between {\\t maximum} and {\\t\nminimum}, both LEDs are maximally bright. Here you have to have in mind that\nthis must be {\\t exactly} in the middle. Of course, this only works if the\ndistance between {\\t maximum} and {\\t minimum} is an exact odd number of\n{\\t amount}s.\n\n\n\\clearpage", "inputs": [{"name": "buttonup", "type": "trigger", "default": null, "description": "Button for nudging the value up by one step\n", "essential": 2, "ramsize": 16}, {"name": "buttondown", "type": "trigger", "default": null, "description": "Button for nudging the value down by one step\n", "essential": 2, "ramsize": 16}, {"name": "amount", "type": "cv", "default": "0.1", "description": "Amount to modify the value by on each press. This must be a value $> 0$\n", "essential": 1, "ramsize": 12}, {"name": "startvalue", "type": "cv", "default": "0", "description": "The value this circuit starts with or is being reset to if you use\nthe {\\t clear} input.\n", "essential": 0, "ramsize": 12}, {"name": "minimum", "type": "cv", "default": "unpatched", "description": "The minimum possible value. If you do not wire this,\nthe value can go down infinitely.\n", "essential": 1, "ramsize": 12}, {"name": "maximum", "type": "cv", "default": "unpatched", "description": "the maximum possible value. If you do not wire this,\nthe value can go up infinitely.\n", "essential": 1, "ramsize": 12}, {"name": "wrap", "type": "gate", "default": "0", "description": "Set this to {\\t 1} in order to have the value wrap around\nif the minimum or the maximum has been exceeded. Note: {\\t wrap}\ndoes only work if you set {\\t minimum} and {\\t maximum}.\n", "essential": 0, "ramsize": 12}, {"name": "offset", "type": "cv", "default": "0", "description": "This value is being added to the output.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "ledup", "type": "stepped", "default": null, "description": "Wire this to the LED in the button for nuding up. It will indicate the current value.\n", "essential": 0, "ramsize": 4}, {"name": "leddown", "type": "stepped", "default": null, "description": "Wire this to the LED in the button for nuding down. It will indicate the current value.\n", "essential": 0, "ramsize": 4}, {"name": "output", "type": "cv", "default": null, "description": "The output of the current value plus value if {\\t offset}.\n", "essential": 2, "ramsize": 4}], "presets": 16, "manual": 234, "ramsize": 136}, "octave": {"category": "pitch", "title": " Multi-VCO octave animator", "description": "This circuit is used to control the pitches of three oscillators\nby octave or even fifths. It also allows a linear detune in order\nto make the common sound of the VCOs sound fatter.\n\nHere is an example for a setup where the octave spreading and the detune\nis controlled with two pots:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[octave]}[octave]\n\\immediate\\write\\patchexamples{    input    = I1}    input    = I1\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    output3  = O3}    output3  = O3\n\\immediate\\write\\patchexamples{    spread   = P1.1}    spread   = P1.1\n\\immediate\\write\\patchexamples{    detune   = P1.2}    detune   = P1.2\n\\end{droidini}\n\nPatch the 1~V / octave inputs of three VCOs at {\\t O1}, {\\t O2} and {\\t\nO3}. Tune all VCOs at exactly the same pitch. Patch the pitch output from\nyour sequencer, quantizer or whatever to {\\t I1}.\n\nNow with the pot {\\t P1.1} turned fully left nothing changes. All VCOs will get\nexactly the same pitch. As you turn up the pot the pitches of the VCOs 2\nand 3 will start to get octaved up more and more until VCO~2 is two octaves\nabove VCO~1 and VCO~3 is four octaves above VCO~1.\n\nIf you add {\\t fifths = on} then intermediate steps shift the pitch\nby perfect fifths.\n\nNote: The output {\\t output1} was implemented just for sake of completeness.\nIt passes through the input to {\\t output1}, since the pitch\nof VCO~1 is never detuned nor pitched up. If you are running low in\noutputs then some use a passive multiple or stacked cable and connect\nVCO~1 externally the pitch and thus save one output.\n\n\\subsubsection*{Detune}\n\nIn the example, if you turn {\\t P1.2}, VCO~2 will be detuned up\nand VCO~3 down. A very slight turn will get get you the nice fat classical\ndetune sound. The speciality here is: the detune is {\\it linear}. This means\nthat the detune is always done by the same number of {\\it Hertz} -- regardless\nof the current pitch. This is done by automatically adapting the detune\nvoltage to be less in higher pitches and greater in lower pitches. The result\nis a beating independent of pitch.\n\n\\subsubsection*{Animation}\n\nSince everything in \\droid is CV'able so is {\\t spread}.\nA nice application is to use a sequencer or clocked random generator for\n{\\it animating} the octaving. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    trigger  = I1}    trigger  = I1\n\\immediate\\write\\patchexamples{    output   = _RANDOM}    output   = _RANDOM\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[octave]}[octave]\n\\immediate\\write\\patchexamples{    input    = I1}    input    = I1\n\\immediate\\write\\patchexamples{    output1  = O1}    output1  = O1\n\\immediate\\write\\patchexamples{    output2  = O2}    output2  = O2\n\\immediate\\write\\patchexamples{    output3  = O3}    output3  = O3\n\\immediate\\write\\patchexamples{    spread   = _RANDOM * P1.1}    spread   = _RANDOM * P1.1\n\\end{droidini}\n\nNow {\\t P1.1} controls the depth of random octave animation.\n\n\\clearpage", "inputs": [{"name": "input", "type": "voltperoctave", "default": "0", "description": "The general pitch information on a 1~V / octave base to be used\nfor the three VCOs.\n", "essential": 2, "ramsize": 12}, {"name": "spread", "type": "stepped", "default": "0", "description": "The amount of octave spread between {\\t output1} and {\\t output3}.\nAt a value of {\\t 1.0} the spread is four octaves.\n", "essential": 2, "ramsize": 12}, {"name": "detune", "type": "fraction", "default": "0", "description": "The amount of linear detune of VCO~2 and 3. This is {\\it not}\non a 1~V / octave base but corresponds to an absolute frequency\ndifference in Hertz. The exact frequency difference cannot be\nset here, since that depends on how you have tuned your VCOs.\nBut the rule is the following: If {\\t input} is a 0~V and {\\t detune} is {\\t 1.0},\nthe detune is by four semitones. And for\nan input of 1~V (one octave higher) it is just two semitones,\nbecause that results in the same frequency difference. For\n2~V (two octaves up) it ist just one semitone and for 3~V\nhalf a semitone (and so on). Best thing is to simply try out\nand listen!\n", "essential": 1, "ramsize": 12}, {"name": "fifths", "type": "gate", "default": "off", "description": "Set this to {\\t 1} or {\\t on} if you want to include\nperfect fifths as intermediate steps.\n", "essential": 1, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output3", "count": 3, "start_at": 1, "type": "voltperoctave", "default": null, "description": "Outputs for the 1~V / octave of the three VCOs. {\\t output1}\nis an exact copy of {\\t input} so you could omit that and rather patch\nVCO~1 to the original pitch CV.\n", "essential": 2, "essential_count": 3, "ramsize": 4}], "presets": 0, "manual": 237, "ramsize": 32}, "once": {"category": "clock", "title": " Output one trigger after the Droid has started", "description": "This circuit outputs exactly one trigger after the Droid module\nhas started. You can set a delay for that to happen.\n\n\\columnbreak\n\nExample:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[once]}[once]\n\\immediate\\write\\patchexamples{    delay    = 0.2 # 200 ms}    delay    = 0.2 # 200 ms\n\\immediate\\write\\patchexamples{    trigger  = _DO_ONCE}    trigger  = _DO_ONCE\n\\end{droidini}\n\nThe applications are up to you. Maybe you want to automatically start something\nwhen the Droid starts or update some MIDI data or whatever weird other idea\nyou have in mind.", "inputs": [{"name": "delay", "type": "cv", "default": "0.01", "description": "Set a delay in seconds after the Droid's start before the trigger\ntriggers. Note: the default value is 10~ms, not zero. This allows\nall attached controllers to have sent at least one update before\nand the real pot values etc. are available at the circuits.\n", "essential": 1, "ramsize": 12}, {"name": "onlycoldstart", "type": "gate", "default": "0", "description": "If you set this input to 1, {\\t once} just sends a trigger after\na cold start, {\\it only}. A cold start means that the Droid has been powered\nup. Pressing the button for loading a new patch and does a warm\nstart.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "trigger", "type": "trigger", "default": null, "description": "The trigger is output here.\n", "essential": 2, "ramsize": 8}], "presets": 0, "manual": 239, "ramsize": 24}, "polytool": {"category": "sequencing", "title": " Change number of voices in polyphonic setups", "description": "The polytool is an intelligent ``transformer'' that can map melodies with\n{\\it N} parallel notes to synth voices with {\\it M} parallel voices\nand can thus change the polyphony of a melody.\n\nThis functionality is inspired by MIDI to CV interfaces (such as\n\\circuit{midiin}), which need to deal with the almost unlimited possible\npolyphony of MIDI, where 127 parallel notes are possible and where the\ninterface needs to suffice with a fixed limited number of CV/gate outputs.\n\nThe usage is very simple: patch your input voices (CV/gate pairs) into {\\t\npitchinput}{\\it X} and {\\t gateinput}{\\it X}. And patch your output voices\ninto {\\t pitchoutput}{\\it X} and {\\t gateoutput}{\\it X}.\n\nHere is an example for converting a three-fold polyphony into a single\nvoice. That voice is controlled by {\\t O1} and {\\t O2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[polytool]}[polytool]\n\\immediate\\write\\patchexamples{    pitchinput1 = _PITCH_1}    pitchinput1 = _PITCH_1\n\\immediate\\write\\patchexamples{    pitchinput2 = _PITCH_2}    pitchinput2 = _PITCH_2\n\\immediate\\write\\patchexamples{    pitchinput3 = _PITCH_3}    pitchinput3 = _PITCH_3\n\\immediate\\write\\patchexamples{    gateinput1 = _GATE_1}    gateinput1 = _GATE_1\n\\immediate\\write\\patchexamples{    gateinput2 = _GATE_2}    gateinput2 = _GATE_2\n\\immediate\\write\\patchexamples{    gateinput3 = _GATE_3}    gateinput3 = _GATE_3\n\\immediate\\write\\patchexamples{    pitchoutput1 = O1}    pitchoutput1 = O1\n\\immediate\\write\\patchexamples{    gateoutput1 = O2}    gateoutput1 = O2\n\\end{droidini}\n\nSee how the parameter {\\t voiceallocation} determines, which note should\nbe played if there is more than one at a time.\n\nThe {\\t polytool} can also do the opposite: You input a serial melody with\njust one note at a time and have that mapped to multiple output voices\nthat make the actual audible sound of the notes overlap. This can even be\nused to convert fast short arpeggios into chord pads.\n\nThe next example shows this. At {\\t pitchinput1} and {\\t gateinput1}\nthere is a melody, for example from a sequencer or from the circuit \\circuit{arpeggio}.\nThat is then played on two output voices:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[polytool]}[polytool]\n\\immediate\\write\\patchexamples{    pitchinput1 = _PITCH}    pitchinput1 = _PITCH\n\\immediate\\write\\patchexamples{    gateinput1 = _GATE}    gateinput1 = _GATE\n\\immediate\\write\\patchexamples{    pitchoutput1 = O1}    pitchoutput1 = O1\n\\immediate\\write\\patchexamples{    pitchoutput2 = O2}    pitchoutput2 = O2\n\\immediate\\write\\patchexamples{    gateoutput1 = O3}    gateoutput1 = O3\n\\immediate\\write\\patchexamples{    gateoutput2 = O4}    gateoutput2 = O4\n\\end{droidini}\n\nHere the parameter {\\t roundrobin} decides how the notes will be distributed\nonto the two output voices.", "inputs": [{"prefix": "pitchinput", "name": "pitchinput1 ... pitchinput16", "count": 16, "start_at": 1, "type": "any", "default": null, "description": "The pitches of up to 16 input voices.\n", "essential": 2, "essential_count": 1, "ramsize": 12}, {"prefix": "gateinput", "name": "gateinput1 ... gateinput16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "The gates of up to 16 input voices.\n", "essential": 2, "essential_count": 1, "ramsize": 16}, {"name": "roundrobin", "type": "gate", "default": "0", "description": "Normally when looking for a free output for playing the\nnext note, this circuit will start from {\\t pitchoutput1}\nin its search. This way, if there are not more notes than outputs\nat any time, the notes played first will always be played\nat the lowest numbered outputs. This leads to a deterministic\nbehaviour when it comes to playing things like chords. The\nsame voice will always be used for the first note in the stream\nof MIDI events.\n\nWhen you switch {\\t roundrobin} to {\\t 1}, this changes.\nNow the outputs are scanned in a round-robin\nfashion, like in a rotating switch. That way every output has\nthe same chance to get a new note. Here it can even make sense\nto define multiple voices even if the track is\nmonophonic. When you use envelopes with longer release times,\nyou can transform such a melody into chords with simultaneous\nnotes.\n\nNote: When all outputs are currently used by a note, {\\t roundrobin}\nhas no influence. Here {\\t voiceallocation} selects which of the\nnotes will be dropped.\n", "essential": 1, "ramsize": 12}, {"name": "voiceallocation", "type": "integer", "default": "0", "description": "When from the pitch inputs, at any given time, more voice are active\nthan you have outputs assigned, normally the ``oldest'' notes\nwould be cancelled. This behaviour can be configured here by\nsetting {\\t voiceallocation} to one of the following values:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{The oldest note will be cancelled (default)}\n\\jacktablerow{1}{The new note will not be played and simply be omitted}\n\\jacktablerow{2}{The lowest note will be cancelled}\n\\jacktablerow{3}{The highest note will be cancelled}\n\\end{tabular}\n\\vspace{2mm}\n", "essential": 1, "ramsize": 12}], "outputs": [{"prefix": "pitchoutput", "name": "pitchoutput1 ... pitchoutput16", "count": 16, "start_at": 1, "type": "any", "default": null, "description": "The pitches of up to 16 output voices.\n", "essential": 2, "essential_count": 2, "ramsize": 4}, {"prefix": "gateoutput", "name": "gateoutput1 ... gateoutput16", "count": 16, "start_at": 1, "type": "gate", "default": null, "description": "The gates of up to 16 output voices.\n", "essential": 2, "essential_count": 2, "ramsize": 4}], "presets": 0, "manual": 240, "ramsize": 240}, "pot": {"category": "ui", "title": " Helper circuit for pots", "description": "This circuit adds plenty of functionality to the controller pots in one\ncircuit. It helps with various tasks. It replaces the former circuits {\\t\nnotchedpot} and {\\t switchedpot} and these are also the main applications\nof {\\t pot}: the simulation a precise center dent (notch) and the sharing\nof one pot for several different functions.\n\n\\subsubsection*{Convert a knob to bipolar output voltage}\n\nLet's start with some simple features. There are a couple of\nuseful outputs, all of which you could do externally by use of\nsome math. The following example converts a pot (which is ranging\nfrom 0 to 1) to a bipolar pot ranging from -1 to +1 (or -10~V to +10~V\nif you send it to an output):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    bipolar  = O1 # Send @10V ... +10V to O1}    bipolar  = O1 # Send -10V ... +10V to O1\n\\end{droidini}\n\nHave a look into the table of jacks below about further useful things\nlike splitting the pot's way in two halfs.\n\n\\subsubsection*{Center notch}\n\n{\\t pot} can simulate a potentiometer with a notch at the center.  It helps\nto exactly select the center position by defining a \"range of tolerance\"\nthat is considered to be the center. This range is called ``notch'' and is\ngiven in a percentage of the available range. I suggest using 10\\% so you\ndon't lose to much pot resolution, but it's still easy enough to hit the\ncenter reliably. Here is an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot      = P1.1}    pot      = P1.1\n\\immediate\\write\\patchexamples{    notch    = 10%}    notch    = 10%\n\\immediate\\write\\patchexamples{    output   = _ACTIVITY}    output   = _ACTIVITY\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[algoquencer]}[algoquencer]\n\\immediate\\write\\patchexamples{    activity = _ACTIVITY}    activity = _ACTIVITY\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\\subsubsection*{Slope}\n\nSometimes you want a bit more resolution at the smaller values\nof the pot range. Maybe the pot controls a time from 0.0 to 1.0 seconds.\nAnd in the low range, say about 0.1 seconds, you need finer control.\n\nYou can change the slope of the pot in a way that either small values or\nvalues near 1.0 are ``streched out''. The default is {\\t slope = 1.0}.\nLook at the following diagram for the impact of different slope\nvalues:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $pot\\ movement (\\%)$,\n    ylabel = {$output\\ value$},\n    xmin = 0, xmax = 100, ymin = 0, ymax = 1,\n    ymajorgrids = true,\n    ytick={0, 0.25, 0.5, 0.75, 1},\n    grid style = dashed,\n    legend style={at={(0.25,1.0)}},\n]\n\\addplot [domain=0:100,color=cyan!70!black,samples=100] {((x/100) ^ 0.5)};\n\\addplot [color=red] coordinates { (0, 0) (100, 1) };\n\\addplot [domain=0:100,color=blue,samples=100] {((x/100) ^ 2)};\n\\addplot [domain=0:100,color=green!50!black,samples=100] {((x/100) ^ 3)};\n% \\legend{slope = 0.5, slope = 1.0, slope = 2.0, slope = 3.0}\n\\legend{0.5, 1.0, 2.0, 3.0}\n\\end{axis}\n\\end{tikzpicture}\n\nAs slope value of 0.0 does not make sense, because the pot would\nstick to 0.0 all the time, a minimum value of 0.001 is enforced.\n\nIf you are curious about the algorithm: This operation is just $x^{slope}$.\nSo it's not ``logarithmic'' or ``exponential'' but polynomial.\n\n\\subsubsection*{Splitting the pot into two hemisperes}\n\nThe jacks {\\t lefthalf}, {\\t righthalf}, {\\t lefthalfinv} and\n{\\t righthalfinv} allow you to split the pot in the middle into\ntwo ranges and use them for something completely different.\nLet's make an example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    lefthalf = O1}    lefthalf = O1\n\\immediate\\write\\patchexamples{    righthalf = O2}    righthalf = O2\n\\end{droidini}\n\nNow let's start with the pot in the center position. Both outputs will be at\n{\\t 0.0}. If you now turn the pot to the left, just {\\t lefthalf} (at {\\t O1})\nis going to rise until it reaches {\\t 1.0} at the left end of the pot range.\n{\\t righthalf} is staying at {\\t 0} all the time.\n\nAt the right half of the pot range, likewise {\\t lefthalf} stays zero and\n{\\t righthalf} will raise from {\\t 0} to {\\t 1}.\n\nThe jacks {\\t lefthalfinv} and {\\t righthalfinv} are similar, but\nare {\\t 1.0} in the neutral position in the center and fall to\n{\\t 0.0} at the edges.\n\n\\subsubsection*{Virtual pots}\n\nThis circuit can handle so called ``virtual pots''. This is a situation\nwhere the physical position of the potentiometer does not match it\noutput value. There are three situations where the {\\t pot} circuit\nautomatically switches to this virtual mode:\n\n\\begin{itemize}\n\\item When you share (overlay) pots using the {\\t select} input\n\\item When you you enable presets (using {\\t preset} or {\\t loadpreset})\n\\item When you send a trigger to {\\t clear}\n\\end{itemize}\n\nIf course you can even use combinations of this: Overlay a pot\nwith multiple functions, work with presets and set a start value\nat the same time.\n\nIf none of these three feature are used, there is not virtual\npot and the physical position always counts.\n\nIn virtual mode, the last virtual value of the pot is always\nsaved to the SD card and restored the next time your start\nyour Droid.\n\nIn addition, in virtual mode the LED gauge is automatically activated.\nThat displays the current virtual value of a pot using the\n16 LEDs of the Droid master.\n\n\\subsubsection*{Sharing / overlaying pots}\n\nPotentiometers are valuable ressources and sooner or later you will\nrun into a situation where you wish you had more pots. So you come\nup with the idea of using one pot for more than one function and\nswitch between those with a button.\n\nPreviously \\droid offered the circuit {\\t switchedpot} for that task\nbut that had certain limitations and also was not consistent with\nother circuits.\n\nLet's make an example: Our task is to share pot {\\t P1.1} so it\nsets {\\it individual} release values for four different envelopes.\nFirst we need something to switch between these\nfour. We do this with a {\\t buttongroup} (see page \\pageref{buttongroup}):\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[buttongroup]}[buttongroup]\n\\immediate\\write\\patchexamples{    button1 = B1.1}    button1 = B1.1\n\\immediate\\write\\patchexamples{    button2 = B1.2}    button2 = B1.2\n\\immediate\\write\\patchexamples{    button3 = B1.3}    button3 = B1.3\n\\immediate\\write\\patchexamples{    button4 = B1.4}    button4 = B1.4\n\\immediate\\write\\patchexamples{    led1 = L1.1}    led1 = L1.1\n\\immediate\\write\\patchexamples{    led2 = L1.2}    led2 = L1.2\n\\immediate\\write\\patchexamples{    led3 = L1.3}    led3 = L1.3\n\\immediate\\write\\patchexamples{    led4 = L1.4}    led4 = L1.4\n\\end{droidini}\n\nNow at any given time, exactly one of the four buttons (i.e. their LEDs)\nis active. Now we add four {\\t pot} circuits using the {\\it same pot}.\nThe trick is the {\\t select} input. Each of these four should be selected\njust if one specific button is active. The output of each is being sent\nto one of the envelopes:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.1}    select = L1.1\n\\immediate\\write\\patchexamples{    output = _RELEASE1}    output = _RELEASE1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.2}    select = L1.2\n\\immediate\\write\\patchexamples{    output = _RELEASE2}    output = _RELEASE2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.3}    select = L1.3\n\\immediate\\write\\patchexamples{    output = _RELEASE3}    output = _RELEASE3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[pot]}[pot]\n\\immediate\\write\\patchexamples{    pot = P1.1}    pot = P1.1\n\\immediate\\write\\patchexamples{    select = L1.4}    select = L1.4\n\\immediate\\write\\patchexamples{    output = _RELEASE4}    output = _RELEASE4\n\\immediate\\write\\patchexamples{}\n\\end{droidini}\n\nFinally we can add the four envelopes:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I1}    trigger = I1\n\\immediate\\write\\patchexamples{    release = _RELEASE1}    release = _RELEASE1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    release = _RELEASE2}    release = _RELEASE2\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I3}    trigger = I3\n\\immediate\\write\\patchexamples{    release = _RELEASE3}    release = _RELEASE3\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    trigger = I4}    trigger = I4\n\\immediate\\write\\patchexamples{    release = _RELEASE4}    release = _RELEASE4\n\\immediate\\write\\patchexamples{    output = O4}    output = O4\n\\end{droidini}\n\nNow you can switch between the four envelopes with the buttons\nand use the pot to adjust the release time of the selected envelope.\n\nHints:\n\\begin{itemize}\n\\item Don't mix up {\\t B1.1} and {\\t L1.1}. If you would use {\\t B1.1}\nfor the switching, you would need to {\\it hold} the button down while\nturning the knob. In which case you wouldn't need the {\\t buttongroup}\ncircuit.\n\\item It is supported (and maybe useful) to select {\\it several} of the \"virtual\"\npots at the same time. In such a situation the turning of the real knob will\nadjust all of the selected values at the same time.\n\\item Pots are no motorized faders. So they cannot show the current value\ncorrectly after switching. See below for details.\n\\item In certain cases the {\\t selectat} input might come handy: if you\ndo the switching with {\\it one} number that changes, not a bunch of gate\nsignals. See the jack table below for details.\n\\end{itemize}\n\n\\subsubsection*{Working with presets}\n\nThe {\\t pot} circuit supports up to 16 presets. With the use of the\n{\\t preset} input you can select one of these. Set a number from\n{\\t 0} to {\\t 15} there to switch between presets. A change of\nthat number immediately switches to another preset.\n\nAs an alternative you can work in a triggered mode by patching\n{\\t loadpreset} and {\\t savepreset} in addition. Switching\npresets happens just on these triggers. In triggered mode it's\nlike have one more preset: the current ``working'' position\nof the pot.\n\nOn page \\pageref{presets} there is a whole chapter about presets.\nYou find examples and more hints there.\n\n\\subsubsection*{Using a start value}\n\nA trigger to {\\t clear} will set the virtual position of the pot\nto a defined start value (which you can adapt with {\\t startvalue}).\nThis means that now the physical postion of the pot is not anymore\nidentical with the virtual position. For that reason the pot runs\nin virtual mode as soon as you connect the {\\t clear} input.\n\nIn virtual mode the state of the virtual pot is saved to the SD\ncard, the pickup procedure (as described below) is applied and the\nLED gauge is active per default.\n\n\\subsubsection*{Picking up the pots}\n\nWhen you use overlaying, presets or a start value, your pots run in virtual\nmode. It means that the physical value of the pot might not be identical with its\noutput value.\n\nAs an example let's assume that -- using the upper example with overlaying --\nyou first press {\\t B1.1} and set decay fully CW {\\t 1.0}. Now you select {\\t\nB1.2}. Because {\\t 0.5} is the start position of every virtual pot that is the\ncurrent value of the second virtual pot. But the physical pot is at {\\t 1.0}.\n\nThis is solved in the following way:\n\n\\begin{itemize}\n\n\\item If you turn the physical pot {\\it right}, the value of the virtual\npot is always increased until both reach {\\t 1.0} at the same time.\n\n\\item If the physical pot is already at {\\t 1.0} when you select a virtual\npot, it cannot be increased further. You first have to turn the pot left a\nbit and then right again.\n\n\\item If you turn the physical pot {\\it left}, then the value of the virtual\npot is always {\\it decreased} until both reach {\\t 0.0} at the same time.\n\n\\item If the physical pot is already at {\\t 0.0} when you select a virtual\npot, it cannot be decreased further. You first have to turn the pot right\nand then left again.\n\n\\end{itemize}\n\nIf you really want even more details -- here we go: Let's assume that the\nvirtual pot is at {\\t 0.4} when you select it. And let's further assume\nthat the physical pot is at position {\\t 0.8}. When you turn it {\\it left},\nthe physical pot has a way of {\\t 0.8} to go until {\\t 0.0} and the virtual\njust {\\t 0.4}. So the virtual pot is moving with half of the speed, for\nboth to reach {\\t 0.0} at the same time. When you turn the pot {\\it right},\nthe virtual pot has {\\t 0.6} to go until maximum, while\nthe physical pot has just {\\t 0.2} left until it reaches its maximum. So\nnow the virtual pot moves three times faster than the physical.\n\nThis algorithm is different than the common ``picking up'' of pots that you\nsee in Eurorack land quite a lot in such situations. I preferred my solution\nbecause it seems to be more convenient -- especially if you\nwant to change a value {\\it a little bit}. Also it allows to have multiple\nvirtual pots to be selected at the same time without having their values\nimmediately snap to the same value.\n\nBy the way: it is also possible to select {\\it none} of the pots. Which is\na convenient way to reset the physical pot to the middle position so that\nyou always have headroom for movement left {\\it and} right, before selecting\none of the virtual pots.\n\n\\clearpage", "inputs": [{"name": "pot", "type": "fraction", "default": "0", "description": "Wire your pot here, e.g. {\\t P1.1}\n", "essential": 2, "ramsize": 12}, {"name": "outputscale", "type": "cv", "default": "1", "description": "The final output is multiplied with this value. It's a convenient\nmethod for scaling up and down the pot range.\n", "essential": 1, "ramsize": 12}, {"name": "notch", "type": "cv", "default": "0", "description": "By setting this parameter to a positive number you create an\nartificial ``notch'' of that size. We suggest using {\\t 0.1} (or\n{\\t 10\\%}.  The maximum allowed value is {\\t 0.5}. Greater values\nwill be reduced to that.  Note: Using this in combination with {\\t\noutputscale} also moves the notching point.  E.g. with {\\t outputscale = 2}\nthe notch will be at {\\t 1.0}.\n", "essential": 1, "ramsize": 12}, {"name": "discrete", "type": "integer", "default": null, "description": "Setting this value to 1 or larger switches the pot over\nto select a discrete integer number, rather than a continous\nvalue. For example {\\t discrete = 5} makes the pot output\none of the {\\it exact} values {\\t 0}, {\\t 1}, {\\t 2}, {\\t 3}\nor {\\t 4}. This is ideal for selecting presets and similar.\nIf you enable {\\t ledgauge} (highly recommended), it shows\nyou the value by using the LEDs of the master in an adapted\nway.\n\nThe maximum allowed number is {\\t 16}.\n\nWhen using discrete, the {\\t startvalue} input is\ninterpreted as a discrete number. So for example if you\nhave {\\t discrete = 5}, you can use {\\t startvalue = 3}\nto set the selected value to the number {\\t 3} after a\ntrigger to {\\t clear}.\nA potential {\\t outputscale} is applied {\\it afterwards}.\n\nNotes: The options {\\t notch} and {\\t slope} do not work\nin discrete mode. {\\t outputscale} is still applied, though.\nAll outputs other than {\\t output} are dead\nand output 0.0. {\\t discrete = 1} does not really make sense,\nsince there is just one value to select from and the output\nwill always be {\\t 0.0}.\n", "essential": 0, "ramsize": 12}, {"name": "slope", "type": "cv", "default": "1", "description": "Changes the resolution of the pot in lower or higher ranges.\nSet {\\t slope} to {\\t 2} or more, if you want small values near 0.0\nto be ``zoomed in''. Set slope to {\\t 0.5} or {\\t 0.3} if you want\nto zoom in value nears 1.0.\n", "essential": 0, "ramsize": 12}, {"name": "ledgauge", "type": "cv", "default": "unpatched", "description": "The ``LED gauge'' uses the 16 LEDs of the \\droid master in order\nto indicate the current value of the pot. This is especially useful\nfor ``virtual'' pots -- i.e. those pots that you get when you use\n{\\t select} in order to layer several different functions onto one pot.\nIn that situation the position of the physical pot can be different\nthan that of the virtual one, so the gauge shows you the effective\nvirtual value.\n\nFurthermore, by illuminating the inner four LEDs, the gauge shows\nwhen the pot hits {\\it exactly} 0.5. This can only happen if you\nuse the {\\t notch} parameter. Otherwise its practically impossible\nto hit exactly.\n\nThe LED gauge is automatically activated if you use {\\t select}.\nIf you don't like the LED gauge, you can turn it\noff with {\\t ledgauge = off}. Otherwise {\\t ledgauge} set's the color\nof the indicator in the same way as the {\\t R}-registers do and at the\nsame time {\\it enables} the gauge even if you don't use {\\t select}.\n\nHere are some color examples that you can use for the value of {\\t ledgauge}:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0.2}{magenta}\n\\jacktablerow{0.4}{red}\n\\jacktablerow{0.6}{yellow}\n\\jacktablerow{0.8}{green}\n\\jacktablerow{1.0}{cyan}\n\\jacktablerow{1.2}{blue}\n\\end{tabular}\n\nThe colors repeat over in a kind of wheel at 1.2, so e.g. {\\t 1.4}\ncreates the same color as {\\t 0.2}.\n", "essential": 0, "ramsize": 12}, {"name": "startvalue", "type": "fraction", "default": "0.5", "description": "This parameter defines the value your pot will get when there is\na trigger to {\\t clear}. This is the value {\\it before} {\\t outputscale}\nis applied.\n\nIf you use {\\t discrete}, the parameter does not expect a fraction but\na discrete number in the range of the discrete values ({\\t 0}, {\\t 1},\n{\\t 2}, etc.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}, {"name": "preset", "type": "integer", "default": "unpatched", "description": "This is the preset number to save or to load. Note: the first\npreset has the number {\\t 0}, not {\\t 1}! For the whole story\non presets please refer to page \\pageref{presets}.\n", "essential": 0, "ramsize": 12}, {"name": "loadpreset", "type": "trigger", "default": null, "description": "A trigger here loads a preset. As a speciality you can\nuse the trigger for selecting a preset at the same time.\n", "essential": 0, "ramsize": 16}, {"name": "savepreset", "type": "trigger", "default": null, "description": "A trigger here saves a preset.\n", "essential": 0, "ramsize": 16}, {"name": "clear", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit.\nThe presets are not affected, unless you use direct preset switching\nwith the {\\t preset} input and without triggers. And that case\nthe current preset is also cleared.\n", "essential": 0, "ramsize": 16}, {"name": "clearall", "type": "trigger", "default": null, "description": "A trigger here loads the default start state into the circuit\nand into all of its presets.\n", "essential": 0, "ramsize": 16}, {"name": "dontsave", "type": "gate", "default": "0", "description": "If you set this to {\\t 1}, the state of the circuit will\nnot saved to the SD card and not loaded from the SD card\nwhen the Droid starts.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "fraction", "default": null, "description": "Your pot output comes here.\n", "essential": 2, "ramsize": 4}, {"name": "bipolar", "type": "cv", "default": null, "description": "Optional output with a range from -1.0 to 1.0, where the center notch\nis at 0.0 (or from -{\\t outputscale} to +{\\t outputscale} if that is used).\n", "essential": 1, "ramsize": 4}, {"name": "absbipolar", "type": "cv", "default": null, "description": "A variation of {\\t bipolar} that always outputs a positive value,\ni.e. the pot will go 1 ... 0.5 ... 0 ... 0.5 ... 1 (if {\\t outputscale}\nis not used).\n", "essential": 0, "ramsize": 4}, {"name": "lefthalf", "type": "cv", "default": null, "description": "This output allows you to split the pot into two hemispheres. Here\nyou get {\\t outputscale} ... 0.0 while the pot is in the left half. In the middle\nand right of it you always get 0.\n", "essential": 0, "ramsize": 4}, {"name": "righthalf", "type": "cv", "default": null, "description": "This is the same but for the right half. It outputs 0 while\nthe pot is in the left half and 0.0 ... {\\t outputscale} from the middle to the\nfully right position.\n", "essential": 0, "ramsize": 4}, {"name": "lefthalfinv", "type": "cv", "default": null, "description": "This outputs 1.0 - {\\t lefthalf}, i.e. the value range\n0.0 ... 1.0 ... 1.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right (and the scaled by {\\t outputscale}).\n", "essential": 0, "ramsize": 4}, {"name": "righthalfinv", "type": "cv", "default": null, "description": "This outputs 1.0 - {\\t righthalf}, i.e. the value range\n1.0 ... 1.0 ... 0.0 when the pot moves left $\\rightarrow$ mid\n$\\rightarrow$ right (and the scaled by {\\t outputscale}).\n", "essential": 0, "ramsize": 4}, {"name": "onchange", "type": "trigger", "default": null, "description": "This output emits a trigger whenever the pot is turned in\neither direction.\n", "essential": 0, "ramsize": 8}], "presets": 16, "manual": 242, "ramsize": 120}, "quantizer": {"category": "cv", "title": " Non-musical quantizer", "description": "This quantizer circuit is very simple. It reads an input voltage,\nquantizes it to the next discrete step that you configured and\noutputs it.\n\nYou {\\it can} use it for musical purposes by setting the number of steps\nto 12 per Volt (which is default). It will quantize the\ninput to semitones.\n\nThe following example scales down a pot {\\t P1.1} to 1~V\n(i.e. one octave) and then quantizes it to semitones. Since {\\t 12}\nis the default value for {\\t steps} this parameter can be\nomitted here:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input  = P1.1 * 1V}    input  = P1.1 * 1V\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nNote$^1$: In fact you can select {\\it 13} semitones here because\nif you turn the pot fully CW it will output 1, which will be scaled\nto 1 V and then quantized to 1 V -- which is the \\nth{13} semitone\nabove the lowest possible note.\n\nNote$^2$: if you are looking for a more musical quantizer then have a\nlook at the Minifonion circuit.\n\nYou can use the Quantizer circuit as a sample \\& hold circuit if you\nset {\\t steps} to {\\t 0} and use the trigger input:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    steps   = 0}    steps   = 0\n\\immediate\\write\\patchexamples{    trigger = I2}    trigger = I2\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Patch the unquantized input voltage here\n", "essential": 2, "ramsize": 12}, {"name": "trigger", "type": "trigger", "default": null, "description": "This jack is optional. If you patch it, the quantizer will\nwork in triggered mode. Here the output pitch is always frozen until the\nnext trigger happens.\n", "essential": 1, "ramsize": 16}, {"name": "steps", "type": "integer", "default": "12", "description": "Number of steps that one Volt should be divided in. The default\nis {\\t 12} and will quantize the input voltage to semitones.\nThe number of steps is related to a value of 1 V which means {\\t 0.1}.\nIt {\\it is} allowed to use a fractional number here. E.g. the value\n{\\t 1.2} will quantize to 12 steps per 10 V (which means 12 steps\nper {\\t 1.0}, which can make sense. A value of {\\t 0.0} (or lower)\nwill basically mean an {\\it infinite} number of steps and thus\npractically disable quantization.\n", "essential": 1, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": "0", "description": "If you set this gate input to {\\t 1} then quantization is bypassed\nand the input voltage is directly copied to the output.\n", "essential": 1, "ramsize": 12}], "outputs": [{"name": "output", "type": "stepped", "default": null, "description": "Here comes your quantized output voltage\n", "essential": 2, "ramsize": 4}, {"name": "changed", "type": "trigger", "default": null, "description": "Whenever the quantization changes to a new output value a trigger\nwith the duration 10~ms is output here. No trigger is output in bypass\nmode.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 248, "ramsize": 40}, "queue": {"category": "cv", "title": " Clocked CV shift register", "description": "This circuit implements a shift register (a queue) with 64 cells. Each cell\ncontains one CV value. At each clock impulse the CVs each move one cell\nforwards. The last CV is dropped. And the current input value is copied\nto the first cell.\n\nThere are eight outputs, which you can place at any of the 64 cells you\nlike. If you do not specify any placement, the outputs are placed at the first\neight cells -- und thus the information in the remaining 56 cells is not being\nused.\n\nThe following example reads CVs from the input {\\t I1}. {\\t O4} always shows\nthe CV value that was seen at the input four cycles previously:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[queue]}[queue]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    clock = I2}    clock = I2\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\end{droidini}\n\n\nThe next example places three outputs at the positions {\\t 3}, {\\t 24} and {\\t 64}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[queue]}[queue]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    clock = I2}    clock = I2\n\\immediate\\write\\patchexamples{    outputpos1 = 3}    outputpos1 = 3\n\\immediate\\write\\patchexamples{    outputpos2 = 24}    outputpos2 = 24\n\\immediate\\write\\patchexamples{    outputpos3 = 64}    outputpos3 = 64\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\end{droidini}\n\nPlease note:\n\n\\begin{itemize}\n\\item Since the DROID is very precise in processing CV voltages you can use\n  the {\\t queue} in order to delay melodies from sequencers etc.\n\\item As always also the inputs {\\t outputpos1} ... {\\t outputpos8} may be\n  CV controlled and change in time.\n\\end{itemize}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "This CV will be pushed into the first cell of the shift register\nwhenever a clock occurs.\n", "essential": 2, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "Each clock signal at this jack will move the CV content\nfrom every cell of the shift register to the next cell. The CV\nin the last cell will be dropped.\n", "essential": 2, "ramsize": 16}, {"prefix": "outputpos", "name": "outputpos1 ... outputpos8", "count": 8, "start_at": 1, "type": "integer", "default": "unpatched", "description": "Specifies the position of each of the eight outputs -- i.e. which\ncell of the shift register it should output. Allowed are values\nfrom 1 up to 64. These jacks defaults to {\\t 1}, {\\t 2}, ... {\\t 8}, so\nif you do not wire them the eight outputs reflect the first eight\npositions of the shift register.\n", "essential": 1, "essential_count": 4, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output8", "count": 8, "start_at": 1, "type": "cv", "default": null, "description": "Eight outputs for eight different positions of the register. If\nyou do not wire {\\t outputpos1} ... {\\t outputpos8}, these outputs\nshow the content of the \\nth{1}, \\nth{2}, ... \\nth{8} cell.\n", "essential": 2, "essential_count": 4, "ramsize": 4}], "presets": 0, "manual": 249, "ramsize": 312}, "random": {"category": "modulation", "title": " Random number generator", "description": "A random number generator with clocked and unclocked mode, that can\neither create voltages at discrete steps and completely free values.\n\nThis circuit creates random numbers between two tunable levels {\\t minimum} and\n{\\t maximum}. In clocked mode each clock creates and holds a new random value.\nIn unclocked mode the random values change at the maximum possible speed (about\n6000 times per second).\n\nSimple example for clocked random numbers between {\\t 0.0} and {\\t 1.0}\n({\\t 1.0} translates into 10~V at the output):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\end{droidini}\n\nExample for creating random output voltages between 1~V and 3~V:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[random]}[random]\n\\immediate\\write\\patchexamples{    clock   = I1}    clock   = I1\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\immediate\\write\\patchexamples{    minimum = 1V}    minimum = 1V\n\\immediate\\write\\patchexamples{    maximum = 3V}    maximum = 3V\n\\end{droidini}", "inputs": [{"name": "clock", "type": "trigger", "default": null, "description": "Optional triggger: if this input is used then the output holds\nthe current random number until the next clock impulse (sample \\& hold)\n", "essential": 1, "ramsize": 16}, {"name": "minimum", "type": "cv", "default": "0", "description": "Minimum possible random number\n", "essential": 1, "ramsize": 12}, {"name": "maximum", "type": "cv", "default": "1", "description": "Maximum possible random number\n", "essential": 1, "ramsize": 12}, {"name": "steps", "type": "integer", "default": "0", "description": "Number of different voltage levels. If this is set to 0 (default),\nany voltage can appear, there is no limit. If this is {\\t 1}, then there is no\nrandom any more since there is only one allowed step (which is the average\nbetween {\\t minimum} and {\\t maximum}. At {\\t 2} the only two possible\noutput values are {\\t minimum} and {\\t maximum}. At {\\t 3} the possible\nlevels are {\\t minimum}, $\\frac{{\\t minimum} + {\\t maximum}}{2}$\nand {\\t maximum} and so on...\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Output of the random number / voltage\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 250, "ramsize": 32}, "recorder": {"category": "cv", "title": " Record and playback CVs und gates", "description": "Record and playback the movement of one CVs, eight gates and one integer\nnumbers in the range 0 to 255, with permanent storage on the SD card.\n\n{\\it Note: This circuit is still experimental. In a future firmware version it\nmight be changed or removed. Also the file format on the SD card for the\nsaved recordings might change and a new version might not be\nable to load old recordings.}\n\n\\subsubsection*{Basic usage}\n\nThe typical interface to the recorder is to use the three buttons\n``Record'', ``Play'' and ``Stop''. The stop button is optional if you\nare low in buttons. Here is a simple example patch for recording a\nCV:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    cvin = I1}    cvin = I1\n\\immediate\\write\\patchexamples{    cvout = O1}    cvout = O1\n\\immediate\\write\\patchexamples{    recordbutton = B1.1}    recordbutton = B1.1\n\\immediate\\write\\patchexamples{    playbutton = B1.2}    playbutton = B1.2\n\\immediate\\write\\patchexamples{    stopbutton = B1.3}    stopbutton = B1.3\n\\immediate\\write\\patchexamples{    recordled = L1.1}    recordled = L1.1\n\\immediate\\write\\patchexamples{    playled = L1.2}    playled = L1.2\n\\immediate\\write\\patchexamples{    stopled = L1.3}    stopled = L1.3\n\\end{droidini}\n\nNow feed some CV into {\\t I1}. The circuit starts in idle / stopped mode\nand {\\t L1.1} is lit. In that mode the input is bypassed to the output,\nso that you can ``hear'' the effects of the CV at {\\t I1}.\n\nWhen you press the record button ({\\t B1.1}), the recording starts and {\\t\nL1.1} becomes lit. The input is still bypassed to the output but at the same\ntime written to the tape.  Stop the recording either by pressing the stop\nbutton {\\t B1.3} or record again.\n\nNote: For your first experiments you might want to use the value of a pot\nas input CV. Then you can record your pot movements:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    cvin = P1.1 # record pot P1.1}    cvin = P1.1 # record pot P1.1\n\\end{droidini}\n\n\nYou can now play the recording by hitting {\\t B1.2}. The LED in that button\nis lit to indicate that the playback is going on. During playback the signal\nat {\\t I1} is ignored and instead the tape's content is sent to {\\t O1}. The\nplayback stops when the recording has played completely or when you hit the\nstop button.  Hitting the play button during playback does not stop it but\nimmediately restarts it from the beginning.\n\nSharing the three buttons with other circuits can be done with the {\\t select}\ninput -- just as usual.\n\n\\subsubsection*{Pausing}\n\nThe {\\t pause} input allows you to pause the tape. This input is different\nfrom the three buttons as it does not expect a trigger but a gate (a state).\nYou can use a \\circuit{button} circuit for that:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led = L1.4}    led = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    cvin = I1}    cvin = I1\n\\immediate\\write\\patchexamples{    cvout = O1}    cvout = O1\n\\immediate\\write\\patchexamples{    record = B1.1}    record = B1.1\n\\immediate\\write\\patchexamples{    play = B1.2}    play = B1.2\n\\immediate\\write\\patchexamples{    stop = B1.3}    stop = B1.3\n\\immediate\\write\\patchexamples{    recordled = L1.1}    recordled = L1.1\n\\immediate\\write\\patchexamples{    playled = L1.2}    playled = L1.2\n\\immediate\\write\\patchexamples{    stopled = L1.3}    stopled = L1.3\n\\immediate\\write\\patchexamples{    pause = L1.4}    pause = L1.4\n\\end{droidini}\n\nWhen you enable pause during playback, the playback is hold and the\noutput sticks at the current CV. Disable pause to go on with the playback.\n\nWhen you enable pause while recording, the tape stops and the input\nCV is no longer recorded. But you can resume the recording later by\ndisabling pause.\n\n\\subsubsection*{Looping}\n\nThe recorder has a simple loop function builtin. When you set the input\n{\\t loop} to {\\t 1}, a playback immediately starts again when it's finished.\n\nIf looping is your main objective, please have a look at \\circuit{cvlooper}.\nThat circuit has some very useful features for a real performance looper.\n\n\\subsubsection*{Playback speed}\n\nWith the parameter {\\t playbackspeed} you can alter the speed of the\nplayback. The default value is {\\t 1}. A value of {\\t 2} doubles the speed\nspeed. The fun part: you even can use a negative speed for running the\ntape backwards. In that case a press to the play button starts the\nplayback at the tape end.\n\nThe following example maps the speed to a pot that's scaled to a range\nfrom -5 to 5 (five times speed backwards to five times speed forwards).\nThe center position sets the speed to 0 and stops the tape.\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    playbackspeed = P1.1 * 10 @ 5}    playbackspeed = P1.1 * 10 - 5\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\n\n\\subsubsection*{Scrubbing}\n\nScrubbing is a special playback mode that's enabled by {\\t scrub = 1}.\nDuring scrubbing no linear playback is done. Instead, you select a position\non the tape with the input CV {\\t scrubposition}. Example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.5}    button = B1.5\n\\immediate\\write\\patchexamples{    led = L1.5}    led = L1.5\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    scrub = L1.5}    scrub = L1.5\n\\immediate\\write\\patchexamples{    scrubposition = P1.1}    scrubposition = P1.1\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nWhile the button {\\t B1.5} is enabled, the {\\t recorder} outputs the CV\nthat's at the position that {\\t P1.1} selects. The left position of\nthe pot (or the value {\\t 0}) selects the start of the recording,\nthe right position ({\\t 1}) the end.\n\nWhile {\\t scrub} is {\\t 1}, the current state (play, record, stop) of the\nrecorder is ignored. It is in scrub mode. The {\\t playled} output is {\\t 1},\nthe other LED outputs are {\\t 0}.\n\n\\subsubsection*{Trimming the start and end}\n\nThe two inputs {\\t trimstart} and {\\t trimend} range from {\\t 0} to {\\t 1}\nand limit of the portion of the recording that is used for playback or\nscrubbing. For example {\\t trimstart = 0.1} and {\\t trimend = 0.8} disables\nthe first 10\\% and the last 20\\% of the recording.\n\nIf you map the trimming positions to two pots you can manually select\na portion. Just make sure that you start with the {\\t timstart} pot\nfully left and {\\t trimright} fully right:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    trimstart = P1.1}    trimstart = P1.1\n\\immediate\\write\\patchexamples{    trimend = P1.2}    trimend = P1.2\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nThis limitation is not permanent. The recording itself is not modified by\nusing trimming.\n\n\\subsubsection*{Recording gates and numbers}\n\nAlong the CV, the recorder also records the state of up to eight input gates.\nYou could record the output of a multi-track drum sequencer or even a manually\ntapped button pattern with that:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    gatein1 = I1}    gatein1 = I1\n\\immediate\\write\\patchexamples{    gatein2 = I2}    gatein2 = I2\n\\immediate\\write\\patchexamples{    gatein3 = I3}    gatein3 = I3\n\\immediate\\write\\patchexamples{    gatein4 = I4}    gatein4 = I4\n\\immediate\\write\\patchexamples{    gateout1 = O1}    gateout1 = O1\n\\immediate\\write\\patchexamples{    gateout2 = O2}    gateout2 = O2\n\\immediate\\write\\patchexamples{    gateout3 = O3}    gateout3 = O3\n\\immediate\\write\\patchexamples{    gateout4 = O4}    gateout4 = O4\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nOther than {\\t cvin} and {\\t cvout} the gate tracks on the tape just\ndistinguish between {\\t 0} and {\\t 1}.\n\nIn addition you can record one discrete integer number from {\\t 0} to {\\t 255}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[recorder]}[recorder]\n\\immediate\\write\\patchexamples{    numberin = I1}    numberin = I1\n\\immediate\\write\\patchexamples{    numberout = O1}    numberout = O1\n\\immediate\\write\\patchexamples{    ...}    ...\n\\end{droidini}\n\nOther than with the CV, no linear interpolation is done. Every time the\ninput number changes a new sample is created.\n\nApplications for recording a number could be chord progressions or melodies\nthat are represented by note numbers rather than pitch CVs.\n\n\n\n\n\\input{cvtape.tex}\n\n\n\\clearpage", "inputs": [{"name": "playbutton", "type": "trigger", "default": null, "description": "A trigger here starts or restarts the playback.\n", "essential": 0, "ramsize": 16}, {"name": "recordbutton", "type": "trigger", "default": null, "description": "A trigger here starts or stops the recording.\n", "essential": 0, "ramsize": 16}, {"name": "stopbutton", "type": "trigger", "default": null, "description": "A trigger here stops and ongoing playback or recording.\n", "essential": 0, "ramsize": 16}, {"name": "loop", "type": "gate", "default": "off", "description": "Set this to {\\t 1} to enable loop mode. In loop mode the playback\nis restarted immediately when it's finished.\n", "essential": 0, "ramsize": 12}, {"name": "pause", "type": "gate", "default": "off", "description": "While this is {\\t 1}, playback or recording is halted (the tape\nstops moving for the while).\n", "essential": 0, "ramsize": 12}, {"name": "mode", "type": "integer", "default": null, "description": "Using this input is an alternative to using the three button\ninputs. If you patch {\\t mode}, the three buttons (and LED outputs)\nare ignored. Instead you set the mode with this input:\n\n\\begin{tabular}{|l|l|} \\hline\n\\jacktablerow{0}{Idle / stopped}\n\\jacktablerow{1}{Playback}\n\\jacktablerow{2}{Recording}\n\\end{tabular}\n\nSince you set the mode from ``outside'', the recorder cannot switch\nit by itself. So if the mode is set to {\\t 1} (playback) and the\nplayback is finished, it stays in playback mode and continues outputting\nthe last sample.\n", "essential": 0, "ramsize": 12}, {"name": "playbackspeed", "type": "cv", "default": "1", "description": "Sets the speed of the tape during playback. {\\t 1} is normal speed,\n{\\t 0.5} half speed, {\\t 2} double speed, and so on. Negative speeds\nare allowed an move the tape backwards. The speed {\\t 0} stops the\ntape.\n", "essential": 0, "ramsize": 12}, {"name": "scrub", "type": "gate", "default": "off", "description": "If {\\t 1} enables scrubbing. Now the outputs reflect the tape\nposition that is set with {\\t scrubposition}.\n", "essential": 0, "ramsize": 12}, {"name": "scrubposition", "type": "fraction", "default": "0", "description": "Position of the tape to play when scrubbing is enabled.\n", "essential": 0, "ramsize": 12}, {"name": "trimstart", "type": "fraction", "default": "0", "description": "Omits a fraction of the recording at the beginning during\nplayback and scrubbing. {\\t 0.1} omits the first 10\\%.\n", "essential": 0, "ramsize": 12}, {"name": "trimend", "type": "fraction", "default": "1", "description": "Omits a fraction of the recording at the end during\nplayback and scrubbing. {\\t 0.8} omits the last 20\\% (not\n80\\%!).\n", "essential": 0, "ramsize": 12}, {"name": "cvin", "type": "cv", "default": "0", "description": "Continous input CV\n", "essential": 2, "ramsize": 12}, {"name": "numberin", "type": "integer", "default": null, "description": "Discrete input number in the range 0 ... 255\n", "essential": 0, "ramsize": 12}, {"prefix": "gatein", "name": "gatein1 ... gatein8", "count": 8, "start_at": 1, "type": "cv", "default": null, "description": "Input gates\n", "essential": 1, "essential_count": 1, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "If you use this clock input, all time inputs are measured in\nclock ticks instead of seconds.\n", "essential": 0, "ramsize": 30}, {"name": "sample", "type": "gate", "default": null, "description": "If you patch this input, ``triggered'' mode is enabled. In this mode,\nthe virtual tape just records a new CV on each trigger at {\\t sample}.\nSo it just records stepped CVs, no slopes and no CV changes\nbetween the triggers.\n", "essential": 0, "ramsize": 16}, {"name": "timewindow", "type": "cv", "default": "0", "description": "When in triggered mode, this optional parameter helps tackling\na problem that many hardware sequencers show: often their\npitch CV is not at its final destination value at the time their\ngate is being output. Often you see a very short ``slew'' ramp\nof say 5~ms after the gate. During that time the pitch CV moves\nfrom its former to the new value.\n\nNow if you trigger the {\\t cvtape} circuit with the sequencer's\ngate you will essentially sample the {\\it previous} pitch CV\ninstead of the new one. Or maybe something in between.\n\nThe {\\t timewindow} parameter configures a short time window\nafter the trigger to {\\t trigger}. During that time period the\ntape will constantly adapt the last sample to a changed input\nCV. When that time is over, the input is finally frozen on the tape.\n\nThe {\\t timewindow} parameter is in seconds. So when you set {\\t\ntimewindow} to say 0.005 (which means 5~ms), you give the\ninput CV 5~ms time for settling to its final value after a trigger\nto {\\t sample} before freezing it.\n", "essential": 0, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": "off", "description": "Setting {\\t bypass} to {\\t on} copies the input signals directly\nto the outputs, regardless of any other stuff going on.\n", "essential": 0, "ramsize": 12}, {"name": "save", "type": "trigger", "default": null, "description": "Send a trigger here to save the current contents of the\ntape to a file on the SD card. The filename is {\\t tapeXXXX.bin},\nwhere {\\t XXXX} is replaced by the number set by {\\t filenumber}.\n", "essential": 0, "ramsize": 16}, {"name": "load", "type": "trigger", "default": null, "description": "Send a trigger here to load a previously saved file into the\ntape. Use {\\t filenumber} so specify which file to load.\n", "essential": 0, "ramsize": 16}, {"name": "filenumber", "type": "integer", "default": "1", "description": "Number of the file to load or save. The range is 0 - 9999.\nIf {\\t filenumber} is 123, the name on the SD card is\n{\\t tape0123.bin}. These files are shared between all\n{\\t recorder} and {\\t delay} circuits.\n", "essential": 0, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "recordled", "type": "gate", "default": null, "description": "Is {\\t 1} during recordings.\n", "essential": 0, "ramsize": 4}, {"name": "playled", "type": "gate", "default": null, "description": "Is {\\t 1} during playback or scrubbing.\n", "essential": 0, "ramsize": 4}, {"name": "stopled", "type": "gate", "default": null, "description": "Is {\\t 1} when no playback, recording or scrubbing is going on.\n", "essential": 0, "ramsize": 4}, {"name": "cvout", "type": "cv", "default": null, "description": "Output of the continous input CV\n", "essential": 2, "ramsize": 4}, {"name": "numberout", "type": "integer", "default": null, "description": "Output of the discrete number\n", "essential": 0, "ramsize": 4}, {"prefix": "gateout", "name": "gateout1 ... gateout8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "Output of the gates\n", "essential": 0, "essential_count": 0, "ramsize": 4}, {"name": "overflow", "type": "gate", "default": null, "description": "When the internal memory of the tape is exceeded and\ndata got lost, this gate goes to {\\t 1} for 0.5 seconds.\nIf you are suspecting this situation, you can wire this\noutput to an LED and observe the memory status that way.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 251, "ramsize": 1712}, "sample": {"category": "cv", "title": " Sample \\& Hold Circuit", "description": "This is a simple sample \\& hold circuit. Each time a positive trigger is\nseen at the jack {\\t sample} a new value is sampled from {\\t input} and sent\nto the {\\t output}.\n\nExample:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sample]}[sample]\n\\immediate\\write\\patchexamples{    input       = I1}    input       = I1\n\\immediate\\write\\patchexamples{    sample      = I2}    sample      = I2\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Input signal to be sampled\n", "essential": 2, "ramsize": 12}, {"name": "sample", "type": "trigger", "default": null, "description": "A positive trigger here will read the current value from\n{\\t input} and store it internally.\n", "essential": 2, "ramsize": 16}, {"name": "gate", "type": "gate", "default": null, "description": "This is an alternative way of making the circuit take a sample\nfrom the input. Here it is sampling all the time while the gate\nis high. In that way it is a bit like {\\t bypass}. But as soon\nas the gate goes low again, the output sticks to the last sample\nvalue just before that.\n", "essential": 0, "ramsize": 12}, {"name": "timewindow", "type": "cv", "default": "0", "description": "This optional parameter helps tackling a problem that\nmany (non-analog) sequencers show: often their pitch CV\nis not at its final destination value at the time their\ngate is being output. Often you see a very short ``slew''\nramp of say 5~ms after the gate. During that time the pitch\nCV moves from its former to the new value.\n\nNow if you trigger the {\\t sample} circuit with the sequencer's\ngate you will essentially sample the {\\it previous} pitch\nCV instead of the new one. Or maybe something in between.\n\nNow the {\\t timewindow} parameter introduces a short time window after\nthe {\\t sample} trigger. During that time period the sample \\& hold\ncircuit will constantly adapt to a changed input CV (is essentially\nin bypass mode). When that time is over, the input is finally frozen.\n\nThe {\\t timewindow} parameter is in seconds. So when you set {\\t\ntimewindow} to say 0.005 (which means 5~ms), you give the\ninput CV 5~ms time for settling to its final value after a trigger\nto {\\t sample} before freezing it.\n", "essential": 0, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": null, "description": "While this gate input is high, the circuit is bypassed and\n{\\t input} is copied to {\\t output}.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "The most recently sampled value is sent here.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 257, "ramsize": 40}, "select": {"category": "logic", "title": " Copy a signal if selected", "description": "Copies a value just when the circuit is selected via {\\t select}.\n\nThis solves the problem of having an LED displaying something, but just\nwhen a certain ``menu page'' or similar is active. Simply setting the LED\nwith \\circuit{copy} or some other circuit's output will {\\it always} set it.\nChecking some select state and sending {\\t 0} does not help, since it will\noverride any other circuit's values for the LED even when those are selected.\n\nHere is an example of letting the LED {\\t L1.1} flash when {\\t \\_SELECTED}\nis high, and otherwise {\\bf don't copy anything} to the LED:\n\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    output = _FLASH}    output = _FLASH\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[select]}[select]\n\\immediate\\write\\patchexamples{    select = _SELECT}    select = _SELECT\n\\immediate\\write\\patchexamples{    input = _FLASH}    input = _FLASH\n\\immediate\\write\\patchexamples{    output = L1.1}    output = L1.1\n\\end{droidini}", "inputs": [{"name": "input", "type": "cv", "default": "0", "description": "Connect the signal you want to copy.\n", "essential": 2, "ramsize": 12}, {"name": "select", "type": "gate", "default": "unpatched", "description": "The {\\t select} input allows you to overlay buttons and\nLEDs with\nmultiple functions. If you use this input, the circuit will\nprocess the buttons and LEDs just as if {\\t select} has a positive\ngate signal (usually you will select this to {\\t 1}).\nOtherwise it won't touch them so they can be used by\nanother circuit. Note: even if the circuit is currently\nnot selected, it will nevertheless work and process all its\nother inputs and its  outputs (those that do not deal with\nbuttons or LEDs) in a normal way.\n", "essential": 0, "ramsize": 12}, {"name": "selectat", "type": "integer", "default": "unpatched", "description": "This input makes the {\\t select} input more flexible. Here\nyou specify at which value {\\t select} should select this circuit.\nE.g. if {\\t selectat} is {\\t 0}, the circuit will be active if\n{\\t select} is {\\it exactly} {\\t 0} instead of a positive gate signal.\nIn some cases this is more conventient.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "The input will be copied here, but just when the circuit is\nselected via {\\t select}.\n", "essential": 2, "ramsize": 4}], "presets": 0, "manual": 258, "ramsize": 24}, "sequencer": {"category": "sequencing", "title": " Simple eight step sequencer", "description": "This circuit implements a sequencer that is a bit similar to the widely known\nMetropolis sequencer by Intellijel. It lacks a couple of its features --\nbut most of these can be patched externally by use of other circuits. On\nthe other hand it is not limited to 8 stages since you can chain multiple\ninstance of this sequencer together to form one large sequencer very easily.\n\nSince {\\it everything} in the \\droid is controllable via CV, of course pitch\nand gate signals are included, which makes the circuit much more versatile\nthan it may seem at a first look.\n\nHere is a small example of a CV sequencer that is playing four voltages in\na turn (it needs a clock into {\\t I1}):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = I1}    clock       = I1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    pitch1      = 1V}    pitch1      = 1V\n\\immediate\\write\\patchexamples{    pitch2      = 3.5V}    pitch2      = 3.5V\n\\immediate\\write\\patchexamples{    pitch3      = 8V}    pitch3      = 8V\n\\immediate\\write\\patchexamples{    pitch4      = @2V}    pitch4      = -2V\n\\end{droidini}\n\nIf you set the {\\t outputscale} parameter to $\\frac{1}{12}$~V\n(which is the same as the number $\\frac{1}{120}$, you\ncan specify pitches directly in {\\it semitones}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = I1}    clock       = I1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    outputscale = 1/120}    outputscale = 1/120\n\\immediate\\write\\patchexamples{    pitch1      = 0}    pitch1      = 0\n\\immediate\\write\\patchexamples{    pitch2      = 12}    pitch2      = 12\n\\immediate\\write\\patchexamples{    pitch3      = 10}    pitch3      = 10\n\\immediate\\write\\patchexamples{    pitch4      = 7}    pitch4      = 7\n\\immediate\\write\\patchexamples{    pitch5      = 5}    pitch5      = 5\n\\immediate\\write\\patchexamples{    pitch6      = 3}    pitch6      = 3\n\\immediate\\write\\patchexamples{    pitch7      = 5}    pitch7      = 5\n\\immediate\\write\\patchexamples{    pitch8      = 7}    pitch8      = 7\n\\end{droidini}\n\nThe following example uses four expander buttons for turning the\nsteps on or off and four pots, which are scaled down to a range of\n0V ... 3V.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = 4}    hz = 4\n\\immediate\\write\\patchexamples{    square = _CLOCK}    square = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led    = L1.1}    led    = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.2}    button = B1.2\n\\immediate\\write\\patchexamples{    led    = L1.2}    led    = L1.2\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.3}    button = B1.3\n\\immediate\\write\\patchexamples{    led    = L1.3}    led    = L1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.4}    button = B1.4\n\\immediate\\write\\patchexamples{    led    = L1.4}    led    = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock       = _CLOCK}    clock       = _CLOCK\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput  = O2}    gateoutput  = O2\n\\immediate\\write\\patchexamples{    pitch1      = P1.1 * 3V}    pitch1      = P1.1 * 3V\n\\immediate\\write\\patchexamples{    pitch2      = P1.2 * 3V}    pitch2      = P1.2 * 3V\n\\immediate\\write\\patchexamples{    pitch3      = P2.1 * 3V}    pitch3      = P2.1 * 3V\n\\immediate\\write\\patchexamples{    pitch4      = P2.2 * 3V}    pitch4      = P2.2 * 3V\n\\immediate\\write\\patchexamples{    gate1       = L1.1}    gate1       = L1.1\n\\immediate\\write\\patchexamples{    gate2       = L1.2}    gate2       = L1.2\n\\immediate\\write\\patchexamples{    gate3       = L1.3}    gate3       = L1.3\n\\immediate\\write\\patchexamples{    gate4       = L1.4}    gate4       = L1.4\n\\end{droidini}\n\nNote: the pitch values you dial in with the pots are not quantized,\nso it's a bit hard to hit a musical pitch. Please have a look at the\ncircuits {\\t quantizer} (page \\pageref{quantizer}) and {\\t minifonion}\n(page \\pageref{minifonion}) for how to quantize pitch values.\n\n\\subsubsection*{Making longer sequences}\n\nThe {\\t sequencer} circuit is limited to 8 steps. But: you can easily\nchain a large number of these circuits together to form longer sequences.\nThis is super easy. Just set the jack {\\t chaintonext} to {\\t 1} and\nplace another {\\t sequencer} circuit with more steps after that. Here\nis an example for a 12 step sequencer:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = P1.1 * 30}    hz = P1.1 * 30\n\\immediate\\write\\patchexamples{    output = _CLOCK}    output = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = B1.1}    reset = B1.1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput = O2}    gateoutput = O2\n\\immediate\\write\\patchexamples{    outputscaling = 1/120}    outputscaling = 1/120\n\\immediate\\write\\patchexamples{    pitch1 = 1}    pitch1 = 1\n\\immediate\\write\\patchexamples{    pitch2 = 8}    pitch2 = 8\n\\immediate\\write\\patchexamples{    pitch3 = 13}    pitch3 = 13\n\\immediate\\write\\patchexamples{    pitch4 = 25}    pitch4 = 25\n\\immediate\\write\\patchexamples{    pitch5 = 4}    pitch5 = 4\n\\immediate\\write\\patchexamples{    pitch6 = 11}    pitch6 = 11\n\\immediate\\write\\patchexamples{    pitch7 = 7}    pitch7 = 7\n\\immediate\\write\\patchexamples{    pitch8 = 21}    pitch8 = 21\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 2}    pitch1 = 2\n\\immediate\\write\\patchexamples{    pitch2 = 9}    pitch2 = 9\n\\immediate\\write\\patchexamples{    pitch3 = 14}    pitch3 = 14\n\\immediate\\write\\patchexamples{    pitch4 = 26}    pitch4 = 26\n\\end{droidini}\n\nYou can make the chain longer by adding more {\\t sequencer}\ncircuits. All but the last must have {\\t chaintonext} set to\n{\\t 1}. Here comes a 19 step sequencer:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[p2b8]}[p2b8]\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz = P1.1 * 30}    hz = P1.1 * 30\n\\immediate\\write\\patchexamples{    output = _CLOCK}    output = _CLOCK\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    clock = _CLOCK}    clock = _CLOCK\n\\immediate\\write\\patchexamples{    reset = B1.1}    reset = B1.1\n\\immediate\\write\\patchexamples{    pitchoutput = O1}    pitchoutput = O1\n\\immediate\\write\\patchexamples{    gateoutput = O2}    gateoutput = O2\n\\immediate\\write\\patchexamples{    outputscaling = 1/120}    outputscaling = 1/120\n\\immediate\\write\\patchexamples{    pitch1 = 1}    pitch1 = 1\n\\immediate\\write\\patchexamples{    pitch2 = 8}    pitch2 = 8\n\\immediate\\write\\patchexamples{    pitch3 = 13}    pitch3 = 13\n\\immediate\\write\\patchexamples{    pitch4 = 25}    pitch4 = 25\n\\immediate\\write\\patchexamples{    pitch5 = 4}    pitch5 = 4\n\\immediate\\write\\patchexamples{    pitch6 = 11}    pitch6 = 11\n\\immediate\\write\\patchexamples{    pitch7 = 7}    pitch7 = 7\n\\immediate\\write\\patchexamples{    pitch8 = 21}    pitch8 = 21\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 2}    pitch1 = 2\n\\immediate\\write\\patchexamples{    pitch2 = 9}    pitch2 = 9\n\\immediate\\write\\patchexamples{    pitch3 = 14}    pitch3 = 14\n\\immediate\\write\\patchexamples{    pitch4 = 26}    pitch4 = 26\n\\immediate\\write\\patchexamples{    pitch5 = 2}    pitch5 = 2\n\\immediate\\write\\patchexamples{    pitch6 = 9}    pitch6 = 9\n\\immediate\\write\\patchexamples{    pitch7 = 14}    pitch7 = 14\n\\immediate\\write\\patchexamples{    pitch8 = 26}    pitch8 = 26\n\\immediate\\write\\patchexamples{    chaintonext = 1 # continue at next sequencer}    chaintonext = 1 # continue at next sequencer\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[sequencer]}[sequencer]\n\\immediate\\write\\patchexamples{    pitch1 = 3}    pitch1 = 3\n\\immediate\\write\\patchexamples{    pitch2 = 10}    pitch2 = 10\n\\immediate\\write\\patchexamples{    pitch3 = 15}    pitch3 = 15\n\\end{droidini}\n\nNotes:\n\\begin{itemize}\n\\item Define all the input and output jacks like {\\t clock}, {\\t pitchoutput}\netc. just for the first sequencer. All subsequent ones just have {\\t pitch}, {\\t gate}, {\\t repeat}, {\\t slew} and {\\t cv} definitions.\n\\item The parameter {\\t chaintonext} is {\\it dynamic}. You could make or break\nthe chain with a toggle {\\t button} or something else if you like.\n\\end{itemize}\n\n\n\\pagebreak", "inputs": [{"name": "clock", "type": "trigger", "default": null, "description": "Each trigger into this jack advances the sequence\nby one step.\n", "essential": 2, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the sequence to the first step\n", "essential": 1, "ramsize": 16}, {"name": "stages", "type": "integer", "default": "unpatched", "description": "Number of inputs of {\\t pitch..}, {\\t gate..}, {\\t slew..}, {\\t cv} and\n{\\t repeats} that should be used. If you set stages to a number higher\nthan the number of used inputs, all inputs will be used.\nIf you omit this parameter, all used inputs will be used.\n", "essential": 0, "ramsize": 12}, {"name": "steps", "type": "integer", "default": "0", "description": "With this input you can force the sequencer to begin from start\nafter a certain number of clock cycles. If you omit the parameter\nor if it is set to 0, the sequencer will play all stages with all\nrepeats until it resets to the beginning.\n", "essential": 1, "ramsize": 12}, {"name": "transpose", "type": "cv", "default": "0", "description": "This voltage is added to the pitch output.\n", "essential": 0, "ramsize": 12}, {"name": "outputscaling", "type": "cv", "default": "1", "description": "The output pitch is multiplied by this parameter.\n", "essential": 0, "ramsize": 12}, {"name": "gatelength", "type": "fraction", "default": "unpatched", "description": "The length of the output gates. If it is unpatched, the original\ninput clock is fed through 1:1 (with its own duty cycle). When used, it\nis a ratio from {\\t 0.0} to {\\t 1.0} and relative to the cycle of the\ninput clock. Setting the {\\t gatelength} to 1.0 merges two adjacent\ngates together since there is not time left for a low gate before\nthe next step begins.\n", "essential": 0, "ramsize": 12}, {"prefix": "pitch", "name": "pitch1 ... pitch8", "count": 8, "start_at": 1, "type": "cv", "default": "0", "description": "These are the pitches of the various steps. You can put fixed numbers\nhere but also of course pots or variable inputs. Note: The number of\n{\\it used} {\\t input} jacks defines the length of the sequence,\nunless you override that with {\\t stages}.\n", "essential": 2, "essential_count": 8, "ramsize": 12}, {"prefix": "cv", "name": "cv1 ... cv8", "count": 8, "start_at": 1, "type": "cv", "default": "0", "description": "Each step has an optional CV assigned. You can use that CV for\nmodulating something or even outputting a second pitch information.\n", "essential": 1, "essential_count": 8, "ramsize": 12}, {"prefix": "gate", "name": "gate1 ... gate8", "count": 8, "start_at": 1, "type": "gate", "default": "1", "description": "The gate inputs should be {\\t 0} ({\\t off}) or {\\t 1} ({\\t on}).\nFor stages with a 0-gate no output gate is produced and the pitch\ninformation is kept at the previous state. Unpatched gates are\nconsidered to be on!\n", "essential": 1, "essential_count": 8, "ramsize": 12}, {"prefix": "slew", "name": "slew1 ... slew8", "count": 8, "start_at": 1, "type": "cv", "default": "0", "description": "Enables slew limiting for that stage. The input is not binary but\nyou can set the amount of slew here -- individually for each step.\n{\\t 0.0} switches the slew off, higher values create slower slews.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"prefix": "repeat", "name": "repeat1 ... repeat8", "count": 8, "start_at": 1, "type": "cv", "default": "1", "description": "Set this to a positive integer number like {\\t 1}, {\\t 2}, and so on.\nIt sets the number of times this stage should be repeated until the\nnext stage will be approached.\nIt is currently not allowed to have {\\t 0} repeats -- although this would\nmake sense in a future version.\n", "essential": 0, "essential_count": 0, "ramsize": 12}, {"name": "chaintonext", "type": "gate", "default": "unpatched", "description": "If you set this input to {\\t 1}, the next sequencer circuit's {\\t pitch}\nand other step inputs will be added to this sequencer. See the general circuit\nnotes for details.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "pitchoutput", "type": "cv", "default": null, "description": "The pitch output. It is unquantized.\n", "essential": 2, "ramsize": 4}, {"name": "cvoutput", "type": "cv", "default": null, "description": "The optional CV output, in case you use the {\\t cv1} ... {\\t cv8} inputs.\n", "essential": 1, "ramsize": 4}, {"name": "gateoutput", "type": "gate", "default": null, "description": "The gate output.\n", "essential": 1, "ramsize": 4}], "presets": 0, "manual": 259, "ramsize": 168}, "slew": {"category": "cv", "title": " Slew limiter", "description": "This is a CV controllable slew limiter for CVs. Special about it is that it\nimplements three alternative algorithms. The traditional exponential algorithm\n(as is commonly implemented in analog circuits), a linear algorithm and a\nspecial S-shaped curve.\n\nHere is a simple example for a slew limiting on {\\t I1} $\\longrightarrow$ {\\t O1}\nwhich is controlled with the pot {\\t P1.1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[slew]}[slew]\n\\immediate\\write\\patchexamples{    input       = I1}    input       = I1\n\\immediate\\write\\patchexamples{    slew        = P1.1}    slew        = P1.1\n\\immediate\\write\\patchexamples{    exponential = O1}    exponential = O1\n\\end{droidini}\n\n\\subsubsection*{Exponential shape}\n\nThis is the ``classical'' slew limit shape, which originates from the\n(negative) exponential loading current of a capacitor. It is also the shape of a low\npass filter that is used for slew limiting. The slope is proportional to\nthe distance between the current and the target voltage. Or in other words\nthe voltage changes fast at the beginning and slower at the end:\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:1.5,color=blue,samples=100]{5 - 0.08^x * 4};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.5,5)};\n\\legend{Exponential,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\n\\subsubsection*{Linear shape}\n\nThe {\\it linear} algorithm simply limits the voltage change per time\nto a certain change rate, e.g. to 10~V per second. If the input\nvoltage changes faster (for example suddenly jumps up), the output\nvoltage follows that with that maximum rate. At a pot position of\n{\\t 0.5} the maximum slew is 120~V per second.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:1.5,color=green!50!black] coordinates {(-0.5,1) (0.0,1) (1.3,5) (1.5,5)};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.3,5)};\n\\legend{Linear,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\\subsubsection*{S-Curve shape}\n\nThe S-curve -- when applied to pitches -- sounds different than\nan exponential curve since it more reflects the way e.g. a trombone\nplayer accelerates and deaccelerates his arm in order to move to\nanother pitch. In our algorithm we assume that in the first half\nof the time the arm accelerates at a constant rate (which is controlled\nby the {\\t slew} parameter) and at the second half of the time it\ndeaccelerates (again at that rate, just negative), until it exactly\nreaches the target pitch.\n\nThere is one audible difference to a real trombone player, however.\nThe real musician would start to move his arm {\\it before} the new\nnote begins, in order to be at the target position right in time.\nBut here the movement is initiated by the pitch change it self so\nit is delayed by the slew limiting.\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    axis lines = left,\n    xlabel = $time$,\n    ylabel = {$Volts$},\n    xmin = -0.5, xmax = 1.5, ymin = 0, ymax = 6,\n    ymajorgrids = true,\n    ytick={0, 2, 4, 6, 8, 10},\n    xtick=\\empty,\n    grid style = dashed,\n    legend style={at={(0.5,-0.15)},\n\t\tanchor=north,legend columns=-1},\n]\n\\addplot [domain=0.0:0.5,color=red,samples=100] {x * x * 8 + 1};\n\\addplot [domain=0.5:1.0,color=red,samples=100]\n{5 - ((0.5-(x-0.5)) * (0.5-(x-0.5)) * 8)};\n\\addplot [domain=1.0:1.5,color=red,samples=100] {5};\n\\addplot [color=gray] coordinates {(-0.5,1) (0.0,1) (0.0,5) (1.5,5)};\n\\legend{S-curve,,,original pitch}\n\\end{axis}\n\\end{tikzpicture}\n\n\\clearpage", "inputs": [{"name": "input", "type": "cv", "default": null, "description": "Wire the CV that you wish to slew limit here.\n", "essential": 2, "ramsize": 12}, {"name": "slew", "type": "cv", "default": "1", "description": "This controls the slew rate. A value of {\\t 0.0} disables slew\nlimiting. The output immediately follows the input without any\ndelay. A value of for example {\\t 2.0} in linear mode means that\n2.0 seconds are needed for a change of 1~V (which is a value of\n0.1 or one octave if used as pitch).\nIn the other two modes the slew time is tuned to sound similar.\nNegative values of this parameter are treated as {\\t 0.0}.\n", "essential": 2, "ramsize": 12}, {"name": "slewup", "type": "cv", "default": "1", "description": "This allows a special handling when the voltage moves {\\it upwards}.\nThe slew limiting for upwards is {\\t slew} multiplied with {\\t slewup}.\nSince {\\t slew} defaults to {\\t 1.0} you can just use {\\t slewup}\nand {\\t slewdown} if you want to control both directions separately.\n", "essential": 0, "ramsize": 12}, {"name": "slewdown", "type": "cv", "default": "1", "description": "Sets the slew rate for downwards movement.\n", "essential": 0, "ramsize": 12}, {"name": "gate", "type": "gate", "default": "unpatched", "description": "If this jack is patched, the slew limiting is only active\nwhile this gate is high. Otherwise it's like setting the {\\t slew}\nparameter to zero.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "exponential", "type": "cv", "default": null, "description": "Output for the resulting CV with the exponential (classical) slew\nalgorithm applied\n", "essential": 2, "ramsize": 4}, {"name": "linear", "type": "cv", "default": null, "description": "Output for linear slew limiting\n", "essential": 1, "ramsize": 4}, {"name": "scurve", "type": "cv", "default": null, "description": "Output with the slew limitation according to the S-curve algorithm.\n", "essential": 1, "ramsize": 4}], "presets": 0, "manual": 263, "ramsize": 48}, "spring": {"category": "modulation", "title": " Physical spring simulation", "description": "A physical simulation of a mass hanging from on an\nideal spring which can create interesting ``bouncing'' CV sources.\n\nConsider the following drawing:\n\n\\begin{tikzpicture}\n\\fill[black!20] (0,7) rectangle (8,8);\n\\draw (0,8) -- (0,7) -- (8,7) -- (8,8);\n\\foreach \\x in {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}\n  \\draw(\\x * 0.5,7) -- (\\x * 0.5 +0.5,8);\n\\foreach \\x in {0,0.5,1,1.5,2,2.5,3}\n  \\draw(4, 7-\\x) -- (3, 6.875-\\x) -- (5, 6.625-\\x) -- (4,6.5-\\x);\n\\draw(4,3.5) -- (4,2);\n\\fill[black!80] (4,2) circle (0.8);\n\\draw[thick,->] (1,6.9) -- (1,0.75);\n\\foreach \\x in {6.9, 5.75, 4.5, 3.25, 2}\n    \\draw[thick] (0.9,\\x) -- (1.1,\\x);\n\\draw (0.7, 6.8) node[anchor=east] {0.00};\n\\draw (0.7, 5.75) node[anchor=east] {0.25};\n\\draw (0.7, 4.5) node[anchor=east] {0.50};\n\\draw (0.7, 3.25) node[anchor=east] {0.75};\n\\draw (0.7, 2) node[anchor=east] {1.00};\n\\draw[white] (4,2) node {mass};\n\\draw[thick,<->] (7,2.8) -- (7,1.2);\n\\draw[thick] (6.9,2) -- (7.1,2);\n\\draw (7,1.2) node[anchor=north] {gravity};\n\\draw (7,2.8) node[anchor=south] {springforce};\n\\end{tikzpicture}\n\n\nWithout any further parameters the mass starts at position\n{\\t 0.00} and velocity {\\t 0.00} and is accelerating downwards until the\nforce of the spring equals the gravity. At this point it decelerates until\nthe velocity is zero. Now the mass is being accelerated {\\it upwards} until\nit reaches the top position at {\\t 0.00} again. This results, in essence,\nto a damped sine wave.\n\nThe {\\t position} and {\\t velocity} are available at their respective\noutputs ready to be used for modulation.\n\n\n\\columnbreak\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[spring]}[spring]\n\\immediate\\write\\patchexamples{    position = O1}    position = O1\n\\immediate\\write\\patchexamples{    velocity = O2}    velocity = O2\n\\end{droidini}\n\nNow, this could be done more easily with the LFO circuit (see page\n\\pageref{lfo}).  But it's getting interesting when you look at the other\nparameters and the modulation possibilities. Please look at the\ntable of jacks for details.\n\n\\subsubsection*{Friction}\n\nPer default the motion is without any friction and thus the mass will move\nup and down forever. You can apply two different types of friction.\n{\\t flowresistance} is the type of friction a body has in a liquid or\ngas. Its force is relative to its velocity. Whereas the normal {\\t friction}\nforce is constant.\n\nWhen you use any type of friction, the spring will finally stop swinging.\nYou need to either {\\it shove} it from time to time or reset it to its\nstart with the {\\t reset} trigger input.\n\nThe following example will create a slowly decaying sine wave, which is\nrestarted whenever a trigger is sent to {\\t reset}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[spring]}[spring]\n\\immediate\\write\\patchexamples{    flowresistance = 0.5}    flowresistance = 0.5\n\\immediate\\write\\patchexamples{    reset = I1}    reset = I1\n\\immediate\\write\\patchexamples{    position = O1}    position = O1\n\\immediate\\write\\patchexamples{    velocity = O2}    velocity = O2\n\\end{droidini}\n\n\n\\subsubsection*{Shoving}\n\nYou also can {\\it shove} the mass downwards or upwards. As long as you send a\ngate signal into {\\t shove} the mass will be shoved downwards.  The exact force\ncan be set with {\\t shoveforce} and defaults to being the same as the gravity.\nA negative value will lift the mass upwards.\n\nSetting {\\t shove} to a constant {\\t 1} value will steadily apply {\\t shoveforce},\nwhich can be interesting as that is itself a changing CV (some LFO, feedback\nloop or whatever).\n\n\\subsubsection*{The physical model}\n\nPlease note that the physical model is normalized in a way such that\nevery parameter is 1. For example the mass is $1 kg$ and the gravity\nis $1\\frac{N}{kg}$. The force of the spring is $1\\frac{N}{m}$.\n\nIn order to avoid anomalies or infinities, the velocity of the mass is limited\nto $\\pm 10\\frac{m}{s}$ and the position is limited to the range of $\\pm 10~m$.\n\n\\pagebreak", "inputs": [{"name": "mass", "type": "cv", "default": "1", "description": "The mass of the object on the spring. The heavier it is, the farther the spring\nwill move up and down.\n", "essential": 1, "ramsize": 12}, {"name": "gravity", "type": "cv", "default": "1", "description": "The gravity of the simulated planet the spring is mounted at. If you\nset the gravity to zero, the mass will move exactly around the zero\nposition from positive to negative and back. But you need to shove\nit or set a start position other than 0, in order to get it started.\n", "essential": 0, "ramsize": 12}, {"name": "springforce", "type": "cv", "default": "1", "description": "The force of the string per m it is stretched. In an ideal spring\nthe force is proportional to the current elongation.\n", "essential": 1, "ramsize": 12}, {"name": "flowresistance", "type": "cv", "default": "0", "description": "Setting this to a value $> 0$ will dampen the oscillation in a way,\nthat higher velocities will be damped more then slower ones. This means\nthat impact of the friction will get less and less as time goes by and\nthe movement slows down.\n", "essential": 1, "ramsize": 12}, {"name": "friction", "type": "cv", "default": "0", "description": "Setting this to a value $> 0$ will also dampen the oscillation, but in\na way that is independent of the current speed of the mass.\n", "essential": 1, "ramsize": 12}, {"name": "speed", "type": "cv", "default": "0", "description": "This parameter speeds up or slows down the perceived time. It works\non a 1V/Oct base. Every positive {\\t 1V} (or {\\t 0.1}) doubles the speed.\nSo if you set {\\t speed} to {\\t 2V} or {\\t 0.2} it will speed\nup the movement by a factor of 4. An input of {\\t -1V} will slow down the\nmovement to the half.\n", "essential": 0, "ramsize": 12}, {"name": "shove", "type": "gate", "default": "0", "description": "While this gate input is logical 1, an extra force of 1~N is applied to\nthe mass pointing downwards. You can change that force with {\\t shoveforce}.\n", "essential": 0, "ramsize": 12}, {"name": "shoveforce", "type": "cv", "default": "1", "description": "This is the force being applied to the mass while {\\t shove} is active\n", "essential": 0, "ramsize": 12}, {"name": "reset", "type": "trigger", "default": null, "description": "Resets the whole system to its start position.\n", "essential": 2, "ramsize": 16}, {"name": "startvelocity", "type": "cv", "default": "0", "description": "Sets the velocity the mass has which \\droid starts of a reset is triggered\n", "essential": 0, "ramsize": 12}, {"name": "startposition", "type": "cv", "default": "0", "description": "Sets the position the spring has which \\droid starts of a reset is triggered\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "velocity", "type": "cv", "default": null, "description": "Outputs the current velocity of the mass\n", "essential": 0, "ramsize": 4}, {"name": "position", "type": "cv", "default": null, "description": "Output the current length of the string. If the string goes\nupwards (which is possible with certain modulations), this can\nbe negative.\n", "essential": 1, "ramsize": 4}], "presets": 0, "manual": 265, "ramsize": 56}, "superjust": {"category": "pitch", "title": " Perfect intonation of up to eight voices", "description": "This circuit automatically creates a perfect pure intonation for up to eight\ninput pitches.\n\n\\subsubsection*{Introduction}\n\nThis means that all pitches are in just intervals, which\ncorrespond to small whole number ratios such as $\\frac{3}{2}$ or $\\frac{5}{4}$.\nAssuming that you have perfectly tuned and calibrated VCOs, If these pitches\nare used to play a chord, there will be no or just minimal\naudible beatings and the chord will sound very pure.\n\nIn normal equal temperament intonation all intervals are a multiple of $\\sqrt[12]{2}$\nand thus there is no pure interval at all, with the exception of the octave.\nSo all chords will sound impure.\n\nThe problem about pure or just intonation is, that you need to decide for\njust one scale, e.g. C major, and then tune all 12 notes in a way that\nchords from that scale sound good. But as soon as you change the scale,\nthe intervals will sound ugly.\n\nWhat makes the {\\t superjust} unique is that fact, that it automatically\ncreates a pure intonation in a {\\it dynamic} way. It constantly ``listens''\nto the notes that are {\\it currently} being played and creates a perfect\nintonation just for those, not for a scale or so. As soon as at least one\nnote changes, all notes are retuned in order to find a new perfect tuning.\nThis is a bit like a well-trained string ensemble or choir, where each\nmusician listens and adjusts his or her pitch in relation to all others.\n\n\\subsubsection*{Usage}\n\nThe nice thing is: you don't need any configuration. You need not specify\nany information about the root note, the scale or anything else. Neither\nneed the inputs be quantized so some scale or tuned to 440~Hz. The circuit\nwill simply analyse all input pitches, apply its algorithm (patent pending)\nand then just slightly raises or lowers each note so that at the end each\npair of frequencies have a rational oscillation ratio with small numerator\nand denominator. This is done in a way that the average pitch does not change.\nJust pipe your pitches through that circuit and you are done. And if you\nwant to use a quantizer, use {\\t superjust} {\\it after} quantization.\n\nHere an example for three voices:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\end{droidini}\n\n\\subsubsection*{Tuning}\n\nOf course, an exact tuning of your VCOs is crucial, since the pitch\ndifferences between a normal tempered intonation and a perfect intonation\nare quite small. The circuit helps you in the process of tuning with the\ninputs {\\t tuningmode}, which you can map to a toggle button:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\end{droidini}\n\nNow when the button {\\t B1.1} is active, all outputs will output\nzero volts. Tuning with 0~V is not optimal in some cases.\nYou should tune your VCOs always roughly in the average pitch\nyou play them.  So you can set the tuning voltage with the parameter\n{\\t tuningpitch}. Here it is set to 2~V (2 octaves higher then 0~V):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\immediate\\write\\patchexamples{    tuningpitch = 2V}    tuningpitch = 2V\n\\end{droidini}\n\nSometimes it is desirable to change the tuning pitch to other\noctaves on the fly. This example uses pot {\\t P1.1} for going through\nseveral octaves, and uses a quantizer for creating steps of 1~V each:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[button]}[button]\n\\immediate\\write\\patchexamples{    button = B1.1}    button = B1.1\n\\immediate\\write\\patchexamples{    led = L1.1}    led = L1.1\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[quantizer]}[quantizer]\n\\immediate\\write\\patchexamples{    input = P1.1}    input = P1.1\n\\immediate\\write\\patchexamples{    steps = 1 # 1 step per octave}    steps = 1 # 1 step per octave\n\\immediate\\write\\patchexamples{    output = _TUNINGPITCH}    output = _TUNINGPITCH\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    tuningmode = L1.1}    tuningmode = L1.1\n\\immediate\\write\\patchexamples{    tuningpitch = _TUNINGPITCH}    tuningpitch = _TUNINGPITCH\n\\end{droidini}\n\n\n\\subsubsection*{Perfect VCO calibration}\n\nIf you {\\it really} want to eliminate all beatings in your chords while\nusing analog VCOs, you probably need something to correct tracking\ndeviations. Here I strongly recommend using the circuit {\\t calibrator}\n(see page \\pageref{calibrator}). Here is an example with three voices,\nwhere buttons of a P2B8 are used for fine tuning the VCO tracking\nin each octave:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[superjust]}[superjust]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = _O1}    output1 = _O1\n\\immediate\\write\\patchexamples{    output2 = _O2}    output2 = _O2\n\\immediate\\write\\patchexamples{    output3 = _O3}    output3 = _O3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O1}    input = _O1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    nudgeup = B1.1}    nudgeup = B1.1\n\\immediate\\write\\patchexamples{    nudgedown = B1.3}    nudgedown = B1.3\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O2}    input = _O2\n\\immediate\\write\\patchexamples{    output = O2}    output = O2\n\\immediate\\write\\patchexamples{    nudgeup = B1.2}    nudgeup = B1.2\n\\immediate\\write\\patchexamples{    nudgedown = B1.4}    nudgedown = B1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[calibrator]}[calibrator]\n\\immediate\\write\\patchexamples{    input = _O3}    input = _O3\n\\immediate\\write\\patchexamples{    output = O3}    output = O3\n\\immediate\\write\\patchexamples{    nudgeup = B1.5}    nudgeup = B1.5\n\\immediate\\write\\patchexamples{    nudgedown = B1.7}    nudgedown = B1.7\n\\end{droidini}\n\nThe number of pitch inputs and pitch outputs you patch\nshould be identical.", "inputs": [{"prefix": "input", "name": "input1 ... input8", "count": 8, "start_at": 1, "type": "voltperoctave", "default": "unpatched", "description": "\\nth1 ... \\nth8 pitch input\n", "essential": 2, "essential_count": 4, "ramsize": 12}, {"name": "tuningmode", "type": "gate", "default": "0", "description": "While this is {\\t 1}, all outputs output the value set\nby {\\t tuningpitch}. This is for tuning all outputs. Since\nperfect tuning is crucial for perfect intonation, this is\nquite useful.\n", "essential": 1, "ramsize": 12}, {"name": "tuningpitch", "type": "voltperoctave", "default": "0", "description": "This pitch CV will be output while the tuning mode\nis active.\n", "essential": 1, "ramsize": 12}, {"name": "bypass", "type": "gate", "default": "0", "description": "While this is {\\t 1}, all inputs are passed through\nto the outputs without changes.\n", "essential": 1, "ramsize": 12}, {"name": "transpose", "type": "voltperoctave", "default": "0", "description": "This value is being added to all outputs, but not\nin tuning or bypass mode. It can e.g. be used for\nmaking a vibrato on a chord.\n", "essential": 0, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output8", "count": 8, "start_at": 1, "type": "voltperoctave", "default": null, "description": "\\nth1 ... \\nth8 pitch output\n", "essential": 2, "essential_count": 4, "ramsize": 4}], "presets": 0, "manual": 267, "ramsize": 64}, "switch": {"category": "cv", "title": " Adressable/clockable switch", "description": "This circuit supports a set of various switching operations. It can switch\nseveral inputs to one output either by means of addressing the input via CV\nor by stepping forward and backward. You can do the same vice versa:\nconnecting one input to one of several outputs while setting the inactive\noutputs to 0~V.\n\nYou can even use several inputs {\\it and} outputs at the same time and\nthus create an $n \\times m$ switch with the option of rotating the outputs against\nthe inputs by means of addressing or stepping.\n\nAt minimum you need to patch two inputs and one output (or vice versa), plus\na switch like {\\t forward}, {\\t backward} or {\\t offset}.\n\nThe first example switches four inputs {\\t I1} ... {\\t I4} to one output {\\t\nO1} be means of a trigger at {\\t forward}. At the beginning {\\t I1} is wired to\n{\\t O1}. Each time a trigger is seen at {\\t forward} the switch switches to the\nnext input and at the end starts over at {\\t I1} again. So\nit cycles through {\\t I1} $\\rightarrow$ {\\t I2}\n$\\rightarrow$ {\\t I3}  $\\rightarrow$ {\\t I4} $\\rightarrow$ {\\t I1}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    input4  = I4}    input4  = I4\n\\immediate\\write\\patchexamples{    output  = O1}    output  = O1\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nPlease note, that {\\t output} and {\\t output1} are synonyms here. You\ncan use either way you like. Just the same is {\\t input} just a shorthand\nfor {\\t input1}.\n\nNow Let's do the opposite thing: distribute one input to four different\noutputs:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input = I1}    input = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    output4 = O4}    output4 = O4\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nNow, if you try this out, you might notice that a trigger to {\\t forward}\nmoves the selected output {\\it backwards}! This is no bug but very logical.\nThe reason will get more clear if we build a switch with several inputs\n{\\it and} outputs. Let's make a 3$\\times$3 switch:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1 = I1}    input1 = I1\n\\immediate\\write\\patchexamples{    input2 = I2}    input2 = I2\n\\immediate\\write\\patchexamples{    input3 = I3}    input3 = I3\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    output3 = O3}    output3 = O3\n\\immediate\\write\\patchexamples{    forward = I8}    forward = I8\n\\end{droidini}\n\nNow a trigger to {\\t forward} moves each output forward to the next\ninput. That is the same as saying each input moves {\\it backward} to\nthe previous output. Of course you can change the direction by using\n{\\t backward} instead of {\\t forward}.\n\nInstead of moving the switch with a trigger you also can {\\it address} it\nby using a CV at the input {\\t offset}. In this example we use a steady CV\nbeing either 0 (for selecting {\\t O1}) or 1 (10~V) for selecting {\\t O2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input   = I1}    input   = I1\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    offset  = I7}    offset  = I7\n\\end{droidini}\n\nUsing two inputs and two outputs creates a switch that can swap these two. Here\nwith offset 0 {\\t input1} is connected to {\\t output1}\nand {\\t input2} to {\\t output2}. If {\\t offset} is {\\t 1}, {\\t input1}\nwill be connected to {\\t output2} and {\\t input2} to {\\t output1}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    output2 = O2}    output2 = O2\n\\immediate\\write\\patchexamples{    offset  = I7}    offset  = I7\n\\end{droidini}\n\nNow let's make another example for a CV addressable switch. The CV is read from\n{\\t I7}. At a voltage of 0~V {\\t output1} is connected to {\\t input1},\nat 1~V to {\\t input2}, at 2~V to {\\t input3}, at 3~V to {\\t input4}, at\n4~V to {\\t input1} again, at 5~V to {\\t input2} and so on:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switch]}[switch]\n\\immediate\\write\\patchexamples{    input1  = I1}    input1  = I1\n\\immediate\\write\\patchexamples{    input2  = I2}    input2  = I2\n\\immediate\\write\\patchexamples{    input3  = I3}    input3  = I3\n\\immediate\\write\\patchexamples{    input4  = I4}    input4  = I4\n\\immediate\\write\\patchexamples{    output1 = O1}    output1 = O1\n\\immediate\\write\\patchexamples{    offset = I7 * 10 # 1 V per switch step}    offset = I7 * 10 # 1 V per switch step\n\\end{droidini}\n\nGenerally speaking, if you connect less inputs than outputs, the unconnected\ninputs are regarded as getting a 0~V input. If you connect less outputs then\ninputs, the unconnected outputs send their values into the black horrible void.", "inputs": [{"prefix": "input", "name": "input1 ... input16", "count": 16, "start_at": 1, "type": "cv", "default": "0", "description": "\\nth1 ... \\nth{16} input. Use these inputs in order and don't leave\ngaps.\n", "essential": 2, "essential_count": 4, "ramsize": 12}, {"name": "forward", "type": "trigger", "default": null, "description": "If a trigger or gate is received here, the switch adds one\nto the current internal switch offset. So every output moves to the\nnext input and every input moves to the previous output.\n", "essential": 1, "ramsize": 16}, {"name": "backward", "type": "trigger", "default": null, "description": "Similar then {\\t forward}, but switches backwards\n", "essential": 1, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "Resets the switch to its initial position. Assuming {\\t offset} is at {\\t 0},\n{\\t input1} is connected to {\\t output1}, {\\t input2} to {\\t output2} etc.\n\nIf {\\t reset} and a trigger at {\\t forward} / {\\t backward} happen at the\nsame time (within\n5~ms), the reset will win and the switch is being reset to offset\n0. This avoids problems with unprecise timing of external sequencers.\n", "essential": 0, "ramsize": 16}, {"name": "offset", "type": "integer", "default": "0", "description": "This allows CV addressable switching. The number read here is being used\na shifting offset and is always added to the internal offset.\nFor example if you send {\\t 5} here, it is like\nyou have triggered {\\t forward} five times after the last reset. Please\nnote, then {\\t 5} would mean 50 Volts, not 5 Volts. So if you patch an\nexternal CV like {\\t I1} here, you probably want to multiply with some\nuseful number.\n", "essential": 2, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output16", "count": 16, "start_at": 1, "type": "cv", "default": null, "description": "\\nth1 ... \\nth{16} output. Use these outputs in order and don't\nleave gaps.\n", "essential": 2, "essential_count": 1, "ramsize": 4}], "presets": 0, "manual": 269, "ramsize": 96}, "switchedpot": {"category": "deprecated", "title": " Overlay pot with multiple functions (OBSOLETE)", "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit\n\\circuit{pot}.  {\\t pot} can do all {\\t switchedpot}\ncan do and much more. {\\t switchedpot} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis circuit allows you to use one of your potentiometers on your controllers\nfor up to eight different functions. It is like creating up to eight {\\it\nvirtual} pots. With the inputs {\\t switch1} \\dots\\ {\\t switch8} you select,\nwhich of these virtual pots are currently active. When you turn the (physical)\npot, all active virtual pots are being changed.\n\nThe values of all virtual pots start at center position ({\\t 0.5}).\n\nThe current values of all virtual pots are saved in the \\droid's internal\nflash memory, so next time you power on you have all settings of the\nvirtual pots reserved.\n\nHere is an example, where one pot is used to control both decay and\nrelease of an envelope.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[switchedpot]}[switchedpot]\n\\immediate\\write\\patchexamples{    pot       = P1.1}    pot       = P1.1\n\\immediate\\write\\patchexamples{    switch1   = B1.1}    switch1   = B1.1\n\\immediate\\write\\patchexamples{    switch2   = B1.2}    switch2   = B1.2\n\\immediate\\write\\patchexamples{    output1   = _DECAY}    output1   = _DECAY\n\\immediate\\write\\patchexamples{    output2   = _RELEASE}    output2   = _RELEASE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[contour]}[contour]\n\\immediate\\write\\patchexamples{    gate      = I1}    gate      = I1\n\\immediate\\write\\patchexamples{    decay     = _DECAY}    decay     = _DECAY\n\\immediate\\write\\patchexamples{    release   = _RELEASE}    release   = _RELEASE\n\\immediate\\write\\patchexamples{    output    = O1}    output    = O1\n\\end{droidini}\n\nNow -- while you press {\\it and hold} button {\\t B1.1} and turn the knob, the\ndecay parameter will change. Holding {\\t B1.2} will change release. Holding\n{\\it both} at the same time is also possible and will change decay and\nrelease at the same time.\n\nHints:\n\\begin{itemize}\n\\item If you do not like to hold the buttons then you might want to use the {\\t\nbutton} circuit for converting the buttons into toggle buttons.\n\\item If you want one button per function and want always one pot to\nbe selected, you can use the {\\t buttongroup} circuit for combining\nthe buttons into a group.\n\\end{itemize}\n\n\\subsubsection*{Picking up the pots}\n\nPots are no encoders. So when reusing a pot for more than one function at\na time there is always the problem that when you switch to one pot function\nthe pot probably currently is not set to the current value of the function.\nAs an example let's assume that -- using the upper example -- you first press\n{\\t B1.1} and set decay fully CW {\\t 1.0}. Now you select release. Because\n{\\t 0.5} is the start position of every virtual pot that is the current\nvalue of release. But the physical pot is at {\\t 1.0}.\n\n\\droid solves this in the following way:\n\n\\begin{itemize}\n\\item If you turn the physical pot {\\it right}, then the value of the virtual pot is always\nincreased until both pots reach {\\t 1.0} at the same time.\n\\item If the physical pot is already at {\\t 1.0} when you select a virtual pot, it cannot\nbe increased further. You first have to turn the pot left a bit and then right again.\n\\item If you turn the physical pot {\\it left}, then the value of the virtual pot is always\n{\\it decreased} until both pots reach {\\t 0.0} at the same time.\n\\item If the physical pot is already at {\\t 0.0} when you select a virtual pot, it cannot\nbe decreased further. You first have to turn the pot right a bit and then left again.\n\\end{itemize}\n\nLet's assume that the virtual pot is at {\\t 0.4} when you select it. And\nlet's further assume that the physical pot is at position {\\t 0.8}. When you\nturn it {\\it left} the physical pot as a way of {\\t 0.8} go until {\\t 0.0}\nand the virtual just {\\t 0.4}. So the virtual pot is moving with half of the\nspeed, so that both reach {\\t 0.0} at the same time. When you turn the pot\n{\\it right}, on the other hand, the virtual pot has {\\t 0.6} to go until\nmaximum while the physical pot has just {\\t 0.2} left until it reaches its\nmaximum. So now the virtual pot moves three times faster than the physical.\n\nThis algorithm is different than the common ``picking up'' up pots that\nyou see in Eurorack land quite a lot in such situations. We preferred\nour solution over that because it seems to be more convenient -- especially\nif you just want to change a value just a little bit. Also it allows to have\nmultiple virtual pots to be selected at the same time.\n\nBy the way: in the upper example it is possible to select {\\it none} of\nthe pots. That is a convenient way to reset the physical pot to the middle\nposition so that you always have headroom for movement left {\\it and} right,\nbefore selecting one of the virtual pots.\n\n\\clearpage", "inputs": [{"name": "pot", "type": "fraction", "default": null, "description": "The pot that you want to overlay, e.g. {\\t P1.1}\n", "essential": 0, "ramsize": 12}, {"name": "bipolar", "type": "gate", "default": null, "description": "If this input is set to 1, the usual pot range of 0 ... 1 will be\nmapped to -1 ... +1, which converts this to a bipolar potentiometer.\nThis is done by multiplying the output with 2.0 and substracting\n1.0 afterwards.\n", "essential": 0, "ramsize": 12}, {"prefix": "switch", "name": "switch1 ... switch8", "count": 8, "start_at": 1, "type": "gate", "default": null, "description": "These inputs select which of the virtual pots should be changed\nwhen the physical pot is being turned. These should be set to {\\t 0}\nor {\\t 1} (or {\\t off} and {\\t on}).\n", "essential": 0, "essential_count": 0, "ramsize": 12}], "outputs": [{"prefix": "output", "name": "output1 ... output8", "count": 8, "start_at": 1, "type": "fraction", "default": null, "description": "The output of the up to eight virtual pots.\n", "essential": 0, "essential_count": 0, "ramsize": 4}], "presets": 0, "manual": 271, "ramsize": 88}, "timing": {"category": "clock", "title": " Shuffle/swing and complex timing generator", "description": "This circuit converts a steady input clock into an output clock\nwith flexible timing modifications. The most common use is a \"swing\"\nfeeling where every second note is delayed. But this circuit\nis much more flexible.\n\nThe length of a timing pattern can be up to eight steps.\nThat means that you can set a different relative time shift\nfor each clock pulse in a sequence of up to eight.\n\nLet's start with a simple swing pattern, which is just\na sequence of two. We assume an external input clock\nat G1 and output the resulting modified clock to G2:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = 0.3}    timing2 = 0.3\n\\end{droidini}\n\nIn this example every second clock pulse is delayed by 30\\% of\none clock tick's duration -- which gives a standard swing\npattern.\n\nCreating a {\\it reverse} swing, where every second pulse\nis {\\it early} is as easy as using a negative number for {\\t timing2}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = @0.3}    timing2 = -0.3\n\\end{droidini}\n\nCreating a sequence with an odd number of steps can create rather weird\ngroove patterns. Look at the following example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = 0.0}    timing1 = 0.0\n\\immediate\\write\\patchexamples{    timing2 = 0.2}    timing2 = 0.2\n\\immediate\\write\\patchexamples{    timing3 = 0.1}    timing3 = 0.1\n\\end{droidini}\n\nNow every second note {\\it of three} is delayed by 20\\% and every third\nnote by 10\\%.\n\nOf course, you can use {\\t timing} in order to create a simple clock\nshift by creating a pattern with just one timing, as well. The following example\nwill shift the input clock {\\it forwards}, so that it always comes a\nbit earlier. This can be used for compensating a slight delay of a master\nclock:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[timing]}[timing]\n\\immediate\\write\\patchexamples{    clock = G1}    clock = G1\n\\immediate\\write\\patchexamples{    output = G2}    output = G2\n\\immediate\\write\\patchexamples{    timing1 = @0.03}    timing1 = -0.03\n\\end{droidini}\n\nNotes:\n\\begin{itemize}\n\\item This circuit needs a steady and stable input clock.\n\\item In order to get a synchronized start together with the rest\nof your patch, it is advisable also to make use of the {\\t reset}\ninput.\n\\item You cannot shift a beat forward or backward by more than 99.99\\%\nof a clock tick.\n\\item When you set your timings in a way that two beats happen at\nthe same time, just one trigger is output for these two beats.\n\\item When you set your timings in a way that a later beat would\ncome before an earlier beat, the later beat is not played.\n\\item For each input beat there is at max one output beat.\nIf for any input beat the corresponding output beat has already been\nplayed, it will will not be replayed even if you suddenly shift\nit into the future.\n\\item If an output beat has not yet played because it is delayed\nand then you suddenly reduce the delay by an amount that would shift\nthat beat into the past, it is played immediately (so it is not lost).\n\\end{itemize}", "inputs": [{"name": "clock", "type": "trigger", "default": null, "description": "Patch a steady clock here for this circuit to be of any use\n", "essential": 2, "ramsize": 30}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here resets the internal step counter and restart at\nstep 1.\n", "essential": 1, "ramsize": 16}, {"prefix": "timing", "name": "timing1 ... timing8", "count": 8, "start_at": 1, "type": "cv", "default": "unpatched", "description": "Specifies a {\\it relative} timing for each step in relation to the input clock.\nA {\\t timing} of 0.3 will shift the respective beat 30\\% of a clock cycle behind,\nwhile -0.3 will make it 30\\% early.\n\nThe timing values are clipped into the range -0.9999 \\dots 0.9999.\n", "essential": 2, "essential_count": 2, "ramsize": 12}], "outputs": [{"name": "output", "type": "trigger", "default": null, "description": "Here comes the modified output clock\n", "essential": 2, "ramsize": 8}], "presets": 0, "manual": 273, "ramsize": 56}, "togglebutton": {"category": "deprecated", "title": " Create on/off buttons (OBSOLETE)", "description": "\\textcolor{red}{\\bf This circuit has been superseded by the new circuit\n\\circuit{button}. {\\t button} can do all {\\t togglebutton}\ncan do and much more. So {\\t togglebutton} will be removed soon.}\n\n\\medskip\n\\hrule\n\nThis small utility circuit converts a normal push button into a\ntoggle button that is either {\\t on} or {\\t off}. It toggles its state\nevery time the button is being pressed. It even can persist the current\nstate of the button in the \\droid's internal flash memory, so at the\nnext time you start your modular the button will have the same state\nas just before you switched it off.\n\nTypically you will wire {\\t button} to one of your controllers' buttons like\n{\\t B1.1} and {\\t led} to the LED in that button ({\\t L1.1}). LED will\nthen always visualise the current state of the button.  As a side effect\nthe LED register {\\t L1.1} will store the button state as a value {\\t 0}\nor {\\t 1} and hence can be used by some other \\droid as an input.\n\nHere is a typical example. The button is being used for enabling\nthe loop in the CV looper:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop        = L1.4}    loop        = L1.4\n\\end{droidini}\n\nIf you do not want the state of the button to be persisted in\nthe \\droid's flash memory then use {\\t startvalue} for setting\na start value. This make sense for the CV looper since the loop\nis apparently empty anyway if you start your \\droid. By the way:\n{\\t off} is a synonym for {\\t 0}.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button     = B1.4}    button     = B1.4\n\\immediate\\write\\patchexamples{    led        = L1.4}    led        = L1.4\n\\immediate\\write\\patchexamples{    startvalue = off}    startvalue = off\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[cvlooper]}[cvlooper]\n\\immediate\\write\\patchexamples{    loop       = L1.4}    loop       = L1.4\n\\end{droidini}\n\nSince a multiplication with {\\t 0} or {\\t 1} can switch off or on\na signal you can use the LED register directly for enabling a signal.\nThe next example uses a button for switching between 0 V and the\noutput of an LFO:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    level       = L1.4 # 0 or 1}    level       = L1.4 # 0 or 1\n\\immediate\\write\\patchexamples{    sine        = O1}    sine        = O1\n\\end{droidini}\n\nUsually the toggle button switches between the two values {\\t 0}\nand {\\t 1}. Sometimes you need different values. Therefore there\nare the two inputs {\\t offvalue} and {\\t onvalue} for two alternative\nvalues for these two states and the output {\\t output1} where you\ncan fetch that value (since {\\t led} will continue to send {\\t 0}\nor {\\t 1} in order for the LED to work properly). Here is an example\nfor a toggle button that switches a clock divider between {\\t 2} and\n{\\t 4}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B1.4}    button      = B1.4\n\\immediate\\write\\patchexamples{    led         = L1.4}    led         = L1.4\n\\immediate\\write\\patchexamples{    offvalue    = 2}    offvalue    = 2\n\\immediate\\write\\patchexamples{    onvalue     = 4}    onvalue     = 4\n\\immediate\\write\\patchexamples{    output      = _CLOCK_DIV}    output      = _CLOCK_DIV\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[clocktool]}[clocktool]\n\\immediate\\write\\patchexamples{    input       = G1 # external clock}    input       = G1 # external clock\n\\immediate\\write\\patchexamples{    output      = G2}    output      = G2\n\\immediate\\write\\patchexamples{    divide      = _CLOCK_DIV}    divide      = _CLOCK_DIV\n\\end{droidini}\n\nOf course {\\t offvalue} and {\\t onvalue} are CV controllable. How can\nmake this sense? Well -- as they can take variable inputs you can use\na togglebutton for directly switching between two different input CV signals.\nThe following example will send two different wave forms of an LFO to\n{\\t O1}. The button {\\t B3.1} switches between sawtooth and sine:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[lfo]}[lfo]\n\\immediate\\write\\patchexamples{    hz          = 2}    hz          = 2\n\\immediate\\write\\patchexamples{    sawtooth    = _SAWTOOTH}    sawtooth    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    sine        = _SINE}    sine        = _SINE\n\\immediate\\write\\patchexamples{}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button      = B3.1}    button      = B3.1\n\\immediate\\write\\patchexamples{    led         = L3.1}    led         = L3.1\n\\immediate\\write\\patchexamples{    offvalue    = _SAWTOOTH}    offvalue    = _SAWTOOTH\n\\immediate\\write\\patchexamples{    onvalue     = _SINE}    onvalue     = _SINE\n\\immediate\\write\\patchexamples{    output      = O1}    output      = O1\n\\end{droidini}\n\nHint: if you need to have not only two but three or four different states\nfor your button then have a look at the circuit {\\t button}.\n\n\\subsubsection*{Buttons with up to four layers}\n\nThe toggle button can overloaded with up to four functions. For switching\nbetween these layers you need a CV. This example assigned three different\nlayers to one button. Each layer has its own state.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[togglebutton]}[togglebutton]\n\\immediate\\write\\patchexamples{    button    = B1.4}    button    = B1.4\n\\immediate\\write\\patchexamples{    led       = L1.4}    led       = L1.4\n\\immediate\\write\\patchexamples{    output1   = _ENABLE_LOOP}    output1   = _ENABLE_LOOP\n\\immediate\\write\\patchexamples{    output2   = _FANCY_STUFF}    output2   = _FANCY_STUFF\n\\immediate\\write\\patchexamples{    output3   = _FOO_BAR}    output3   = _FOO_BAR\n\\immediate\\write\\patchexamples{    switch    = I1 * 2}    switch    = I1 * 2\n\\end{droidini}\n\nNow if {\\t I1} is near zero volts, then the button behaves like in the\nprevious example. But when you set it to 5 V (resulting in a number of\n{\\t 0.5} which is multiplied by {\\t 2} and thus evaluates to {\\t 1}),\nthen a second copy of the button is activated with its own state. The LED\nnow shows the state of that second button which {\\t output} will outputs\nthe value of the first button.", "inputs": [{"name": "button", "type": "trigger", "default": null, "description": "The actual push button. Usually you want to wire this to {\\t B1.1},\n{\\t B1.2} and so on: to one of the push buttons of your\ncontrollers. Each time that\ninput goes from low to high the state of the push button will toggle.\n", "essential": 0, "ramsize": 16}, {"name": "reset", "type": "trigger", "default": null, "description": "A positive trigger edge here will reset the\nbutton into the state ``not pressed'' -- regardless of\nits current state\n", "essential": 0, "ramsize": 16}, {"name": "onvalue", "type": "cv", "default": "1", "description": "Value sent to {\\t output} when the push button is on. Setting this to a\ndifferent value than the default value saves you attenuating its value\nlater on when you use it as a CV.\n", "essential": 0, "ramsize": 12}, {"name": "offvalue", "type": "cv", "default": "0", "description": "Value sent to {\\t output} when the push button is off.\n", "essential": 0, "ramsize": 12}, {"name": "doubleclickmode", "type": "gate", "default": "off", "description": "This input can enable a {\\it double click mode} when set to {\\t 1}.\nIn that mode the button only toggles it's constant state if you double\npress it in a short time. Otherwise it behaves like a momentary button,\nthat inverts the persisted state (which you toggle with the double click).\n", "essential": 0, "ramsize": 12}, {"name": "startvalue", "type": "gate", "default": null, "description": "State of the push button when you switch on your system. Setting this\nto {\\t on} or {\\t off} will force the button into that state. Using this\njack disables the persistence of the state! In switched mode this will\nbe used for the other button layers as well.\n", "essential": 0, "ramsize": 12}], "outputs": [{"name": "led", "type": "gate", "default": null, "description": "When the button's state is on a value of {\\t 1.0} will be sent to that\noutput -- regardless of the values in {\\t onvalue}\nand {\\t offvalue}. Usually you will wire this jack to the\nLED within the button, e.g. to {\\t L1.1}, {\\t L1.2}\nand so on\n", "essential": 0, "ramsize": 4}, {"name": "output", "type": "cv", "default": null, "description": "This jack will output either {\\t onvalue} or {\\t offvalue}\ndepending on the\nstate of the \\nth1 ... \\nth4 button.\nIf you have not wired those inputs then this is\nthe same as the {\\t led} output.\n", "essential": 0, "ramsize": 4}, {"name": "inverted", "type": "cv", "default": null, "description": "The same as {\\t output1}, but sends {\\t onvalue} when the\nbutton is off and {\\t offvalue} when the button is on.\nNote: there is no inverted version of {\\t output2} ... {\\t output4}.\n", "essential": 0, "ramsize": 4}, {"name": "negated", "type": "gate", "default": null, "description": "Similar to {\\t inverted}, but always sends {\\t 1} when the button\nis off and {\\t 0} when the button is on -- independent of the values\nof {\\t onvalue} and {\\t offvalue}.\n", "essential": 0, "ramsize": 4}], "presets": 0, "manual": 275, "ramsize": 48}, "transient": {"category": "modulation", "title": " Transient generator", "description": "This circuit creates (possibly very slow) linear transients from a defined start\nvalue to an end value.  The duration of that transition is either set in seconds\nor specified as a number of clock ticks. This circuit is built in a way that\nvery long transients are possible, even several days, weeks, months, years or\nwhatever you like.\n\nHere is a simple example:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 1V}    start = 1V\n\\immediate\\write\\patchexamples{    end = 3V}    end = 3V\n\\immediate\\write\\patchexamples{    duration = 600}    duration = 600\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nHere the duration is meant to be 600 seconds (10 minutes). So at the beginning {\\t O1} will\nbe at 1~V. Then it rises slowly until after ten minutes\nit reaches 3~V. There it stays forever.\n\nThere are two ways of restarting it again. Either you send a trigger\nto {\\t reset} or you set {\\t loop} to {\\t 1}. When {\\t loop} is\nactive, the transient will start over at {\\t start} immediately when\nit reaches {\\t end}:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 1V}    start = 1V\n\\immediate\\write\\patchexamples{    end = 3V}    end = 3V\n\\immediate\\write\\patchexamples{    duration = 600}    duration = 600\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\immediate\\write\\patchexamples{    reset = G1}    reset = G1\n\\immediate\\write\\patchexamples{    loop = 1}    loop = 1\n\\end{droidini}\n\nAs an alternative to seconds you can specify the length in terms of clock\nticks. This needs a steady clock signal patched into the {\\t clock} input.\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[transient]}[transient]\n\\immediate\\write\\patchexamples{    start = 0.2}    start = 0.2\n\\immediate\\write\\patchexamples{    end = 0.7}    end = 0.7\n\\immediate\\write\\patchexamples{    duration = 32}    duration = 32\n\\immediate\\write\\patchexamples{    clock = I1}    clock = I1\n\\immediate\\write\\patchexamples{    output = O1}    output = O1\n\\end{droidini}\n\nHere the duration of one transient is exactly 32 clock ticks. This makes\nit simpler to exactly align a transient with a musical structure of a song\nor the like.\n\n\\subsubsection*{Changes while in the air}\n\nAs {\\t start}, {\\t end} and {\\t duration} are CV inputs, they might change\nwhile the transient is running. This is how {\\t transient} behaves in such\nsituations:\n\nThe {\\t start} value is just taken into account whenever the transient starts.\nthis is:\n\n\\begin{itemize}\n\\item When the \\droid starts\n\\item When there is a trigger at {\\t reset}\n\\item When the transient reaches the end and {\\t loop} is on.\n\\end{itemize}\n\nWhenever that happens, the current output level is set to {\\t start}. Also\nthe output {\\t phase} is set to 0. Phase is a kind of internal clock that\nmeasures which part of the transient has been run through already.\n\nAt any given time {\\t transient} assumes that the {\\it phase} times the\nduration equals the time left. And the distance to go in the remaining time\nis the current distance from the current output level to the end. These two\nvalues directly translate into a slope.  This slope now determines how fast\nthe output level is moving and into which direction.\n\nFrom this follows:\n\n\\begin{itemize}\n\\item When you make the duration longer in-flight, the speed of change will get slower.\n\\item When you change {\\t start} in-flight, nothing happens.\n\\item When you change {\\t end} in-flight to a value that is ``farther'' away from the\ncurrent level, the speed of change increases.\n\\item If you change {\\t end} to be the current level of the transient,\nit seems to stop, but in fact the slope is just zero and it\nstill lasts until the duration is over.\n\\item The output level is always smooth. No sudden steps.\nWith one exception: When the transient resets to its start value.\n\\end{itemize}\n\nIn pingpong mode (see the table of inputs for details) this changes accordingly. While\nthe transient is on its way back, consider {\\t start} and {\\t end} exchanged.\n\n\\clearpage", "inputs": [{"name": "start", "type": "cv", "default": "0", "description": "Start value of the transient\n", "essential": 2, "ramsize": 12}, {"name": "end", "type": "cv", "default": "1", "description": "Target value of the transient\n", "essential": 2, "ramsize": 12}, {"name": "duration", "type": "cv", "default": "1", "description": "Duration: if the {\\t clock} input is used, it is in clock ticks.\nOtherwise it is in seconds. A negative duration will be treated as\nzero. And a zero duration will make the output always be at {\\t\nend} level.\n", "essential": 2, "ramsize": 12}, {"name": "loop", "type": "gate", "default": "0", "description": "If this is set to {\\t 1}, the transient will start over\nagain as soon as it reaches the end.\n", "essential": 1, "ramsize": 12}, {"name": "pingpong", "type": "gate", "default": "0", "description": "If this set to {\\t 1}, the transient will start moving\nbackwards towards the start when it has reached end. It will swing\nback and forth, in fact looping infinitely.\n", "essential": 0, "ramsize": 12}, {"name": "freeze", "type": "gate", "default": "0", "description": "while this is set to {\\t 1}, the transient it frozen at its\ncurrent position.\n", "essential": 0, "ramsize": 12}, {"name": "reset", "type": "trigger", "default": null, "description": "A trigger here will immediately set the transient back to\nits start value.\n", "essential": 1, "ramsize": 16}, {"name": "clock", "type": "trigger", "default": null, "description": "If you patch a clock here, the duration will be set in terms\nof clock ticks, not of seconds. This needs to be a steady clock\nin order to get predictable results.\n", "essential": 0, "ramsize": 30}], "outputs": [{"name": "output", "type": "cv", "default": null, "description": "Here comes the current value of the transient.\n", "essential": 1, "ramsize": 4}, {"name": "phase", "type": "cv", "default": null, "description": "This output reflects the current phase of the transient. It behaves\nas if {\\t start} would be 0 and {\\t end} would be 1.\n", "essential": 0, "ramsize": 4}, {"name": "endoftransient", "type": "gate", "default": null, "description": "When loop and pingpong is off, this output goes to {\\t 1} when\nthe transient has reached the end -- and stays there.\nIn loop mode just a short trigger is sent.\nIn pingpong mode that trigger is not sent when the transient has\nreach the {\\t end}-value, but when it is back at start\n(i.e. after one full cycle).\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 277, "ramsize": 56}, "triggerdelay": {"category": "clock", "title": " Trigger Delay with multi tap and optional clocking", "description": "This circuit implements a CV controllable delay for a trigger or gate signal.\nIt listens for triggers at {\\t input} and sends the same triggers {\\it later}\nto the {\\t output}. It does {\\it not} look at the voltage level of the inputs.\nThe output triggers are always sent with 10~V ({\\t I1 ... I8}) or 5~V (on the\nG8 expander).\n\nAs a difference to an analog trigger delay this circuit is capable of keeping\nmemory of up to 16 triggers. This means it is able to process further\nincoming triggers while previous triggers are still in the delay. This allows you\nto delay complex rhythmic patterns, e.g. in order to reuse the output of one\ntrack of a trigger sequencer shifted in time for another instrument.\n\nFurthermore, it is able to retain the gate length of the original input signal and output\nthe delayed gate with exactly the same length.\n\nHere is the simplest possible example, which delays an incoming gates / triggers\nby exactly one second:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\end{droidini}\n\nYou can set the delay in seconds via the {\\t delay} jack. And if you patch\n{\\t gatelength}, the original gate length is being ignored and overridden\nby this value (also in seconds):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    delay      = 0.1 # 0.1 seconds}    delay      = 0.1 # 0.1 seconds\n\\immediate\\write\\patchexamples{    gatelength = 0.05 # 50 ms}    gatelength = 0.05 # 50 ms\n\\end{droidini}\n\n\\subsubsection*{Clocked mode}\n\n{\\t triggerdelay} supports a clocked mode, in which all timing\nis relative to an input clock. You enable clocked mode by simply patching\na steady clock into {\\t clock}. Now {\\t delay} and {\\t gatelength} are\nrelative to {\\it one clock cycle}.\n\nThe following example delays all input triggers by one clock cycle\n(which is the default):\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    clock      = G3}    clock      = G3\n\\end{droidini}\n\nIf you specify {\\t delay} and/or {\\t gatelength} they are now measured\nin clock cycles:\n\n\\immediate\\write\\patchexamples{page: \\thepage\\ \\circuitname}\\begin{droidini}\n\\immediate\\write\\patchexamples{[triggerdelay]}[triggerdelay]\n\\immediate\\write\\patchexamples{    input      = G1}    input      = G1\n\\immediate\\write\\patchexamples{    output     = G2}    output     = G2\n\\immediate\\write\\patchexamples{    clock      = G3}    clock      = G3\n\\immediate\\write\\patchexamples{    delay      = 16 # clock cycles}    delay      = 16 # clock cycles\n\\immediate\\write\\patchexamples{    gatelength = 0.5 # half a clock cycle}    gatelength = 0.5 # half a clock cycle\n\\end{droidini}", "inputs": [{"name": "input", "type": "gate", "default": "0", "description": "Patch triggers or gates to be delayed here.\n", "essential": 2, "ramsize": 16}, {"name": "delay", "type": "cv", "default": "1", "description": "Amount of time the incoming triggers are being delayed. When {\\t clock} is\npatched, this is in relation to one clock cycle, so a delay of\n4 will delay the input pattern by exactly 4 beats. Fractions are\nallowed also. If {\\t clock} is not patched, this parameter\nis in {\\it seconds}. So for example in order to delay by 100~ms\nyou need a delay of {\\t 0.1}.\n", "essential": 2, "ramsize": 12}, {"name": "gatelength", "type": "cv", "default": "unpatched", "description": "Unless you patch this jack the length of the output gates is\nexactly the length of the input gates. By use of this parameter you\noverride that length and set a fixed length in {\\it seconds} -- or\nif {\\t clock} is being used -- in clock cycles.\n", "essential": 1, "ramsize": 12}, {"name": "repeats", "type": "integer", "default": "1", "description": "Number of times the delayed trigger is being repeated. Each\nfurther repetition is with the same delay.\n", "essential": 1, "ramsize": 12}, {"name": "mute", "type": "gate", "default": "0", "description": "A high gate signal suppresses any further output gates. However, the current\ngate is finished normally.\n", "essential": 0, "ramsize": 12}, {"name": "clock", "type": "trigger", "default": null, "description": "When you patch this input, the trigger delay runs in clocked\nmode. In this mode {\\t delay} is relative to one clock cycle. I.e. a delay\nif {\\t 0.5} will delay the trigger by half a clock cycle. The same holds\nfor {\\t gatelength}. That is measured in clock cycles, too.\n", "essential": 0, "ramsize": 30}], "outputs": [{"name": "output", "type": "gate", "default": null, "description": "Outputs the delayed triggers/gates, while keeping the gate length --\nunless you have changed that\n", "essential": 2, "ramsize": 4}, {"name": "overflow", "type": "gate", "default": null, "description": "Whenever there are more input triggers than this circuit can keep\nmemory of, this output outputs a gate of 0.5~sec length. You can\nwire this to an LED in order to know when this happens.\n", "essential": 0, "ramsize": 8}], "presets": 0, "manual": 279, "ramsize": 248}}, "controllers": {"p2b8": {"ramsize": 144}, "p4b2": {"ramsize": 144}, "p8s8": {"ramsize": 216}, "b32": {"ramsize": 320}, "p10": {"ramsize": 168}, "s10": {"ramsize": 96}, "m4": {"ramsize": 296}, "e4": {"ramsize": 256}, "x7": {"ramsize": 1000}}}